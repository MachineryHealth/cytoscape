/**  Copyright (c) 2003 Institute for Systems Biology
 **  This program is free software; you can redistribute it and/or modify
 **  it under the terms of the GNU General Public License as published by
 **  the Free Software Foundation; either version 2 of the License, or
 **  any later version.
 **
 **  This program is distributed in the hope that it will be useful,
 **  but WITHOUT ANY WARRANTY; without even the implied warranty of
 **  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  The software and
 **  documentation provided hereunder is on an "as is" basis, and the
 **  Institute for Systems Biology has no obligations to provide maintenance, 
 **  support, updates, enhancements or modifications.  In no event shall the
 **  Institute for Systems Biology be liable to any party for direct, 
 **  indirect, special,incidental or consequential damages, including 
 **  lost profits, arising out of the use of this software and its 
 **  documentation, even if the Institute for Systems Biology 
 **  has been advised of the possibility of such damage. See the
 **  GNU General Public License for more details.
 **   
 **  You should have received a copy of the GNU General Public License
 **  along with this program; if not, write to the Free Software
 **  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 **/
//--------------------------------------------------------------------------------
// PairwiseDistanceBinaryTreeSorter.java
//--------------------------------------------------------------------------------
package common.algorithms.hierarchicalClustering;
//--------------------------------------------------------------------------------
import javax.swing.tree.TreeNode;
import java.util.HashMap;
import java.util.Set;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.Comparator;
import java.util.Arrays;
import java.util.Iterator;
import java.util.NoSuchElementException;
//--------------------------------------------------------------------------------
public abstract class PairwiseDistanceBinaryTreeSorter {

    // NodeDatum orientations:
    public static final int UNDETERMINED = -1;
    public static final int FIRST_FACE_OUTSIDE = 0;
    public static final int LAST_FACE_OUTSIDE = 1;
    
    // binary tree is assumed to be generated by a clustering algorithm.
    public static TreeNode[] sortLeaves (
					 TreeNode binary_tree_root,
					 Comparator node_pair_comparator
					 ) {
	
	NodeData node_data = new NodeData();
	
	TreeNode node = binary_tree_root;
	TreeNode parent = null;
	TreeNode other_node;
	NodeData.NodeDatum node_datum;
	NodeData.NodeDatum parent_datum;
	NodeData.NodeDatum other_node_datum;
	int next_node_index = -1;
	int face_index_a;
	int face_index_b;
	while( node != null ) {
	    if( node.isLeaf() ) {
		node_datum = node_data.addNodeDatum( node );
		
		next_node_index++;
		while( ( parent != null ) &&
		       next_node_index >= parent.getChildCount() ) {
		    node_datum = ( NodeData.NodeDatum )node_data.get( node );
		    parent_datum = node_data.addNodeDatum( parent );
		    
		    if( parent.getChildCount() == 2 ) { // there's 2 children.  We're #2.
			other_node = parent.getChildAt( 0 );
			other_node_datum =
			    ( NodeData.NodeDatum )node_data.get( other_node );
			
			// Now reorient the children
			if( !( node.isLeaf() && other_node.isLeaf() ) ) {
			    // Which of the candidate faces of our node are closest to which
			    // of the candidate faces of our other node?
			    NodePair[] candidate_couples =
				candidateCouples( other_node_datum, node_datum );
			    // Sort them to find the couple(s) with least distance
			    Arrays.sort( candidate_couples, node_pair_comparator );
	      
			    // How many least-distance couples are there?
			    int least_distance_couples_count = 1;
			    for( int i = 0; i < ( candidate_couples.length - 1 ); i++ ) {
				if( node_pair_comparator.compare(
								 candidate_couples[ i ],
								 candidate_couples[ i + 1 ]
								 ) == 0 ) { // If couples at i and at i + 1 are equidistant
				    least_distance_couples_count++;
				} else {
				    break;
				}
			    }

			    // Select the least distance ones.
			    parent_datum.firstFaces.select(
							   parent_datum.node,
							   aSet( candidate_couples, least_distance_couples_count )
							   );
			    parent_datum.lastFaces.select(
							  parent_datum.node,
							  bSet( candidate_couples, least_distance_couples_count )
							  );
	      
			} // End processing candidate couples
		    } // End if there's 2 children
		    // Switch to a parent
		    node = parent;
		    parent = node.getParent();
		    if( parent != null ) {
			next_node_index = ( parent.getIndex( node ) + 1 );
		    }
		} // End while node is the last child of its parent
		if( parent == null ) {
		    break;
		}
		node = parent.getChildAt( next_node_index );
	    } else {
		// If it's not a leaf, then we're seeing a new parent node.  We will
		// come back to this after we have processed its children.
		parent = node;
		next_node_index = 0;
		node = parent.getChildAt( next_node_index );
	    }
	} // End while node != null, keep 'em flipping.
	
	// TODO: REMOVE?
	// Do a walk along the sordid sorted leaves, building up a list.
	LinkedList list = new LinkedList();
	node = binary_tree_root;
	boolean next_out_first = true;
	while( node != null ) {
	    node_datum = ( NodeData.NodeDatum )node_data.get( node );
	    next_out_first = next_out_first;
	    if( node.isLeaf() ) {
		parent_datum = ( NodeData.NodeDatum )node_data.get( parent );
		
		list.addLast( node );
		
		if( next_node_index ==
		    ( ( parent_datum.orientation == LAST_FACE_OUTSIDE ) ?
		      1 : 0 ) ) { // We have just done the out face
		    if( parent_datum.outFirst ) {
			// We've done the outside one already so let's go inside.
			next_node_index =
			    ( ( parent_datum.orientation == LAST_FACE_OUTSIDE ) ?
			      0 : 1 );
			// Since we're going inside, switch orientations.
			next_out_first = false;
		    } else {
			// Since we've done both inside and outside, let's move on.
			next_node_index = 2;
		    }
		} else { // We're at the in face
		    if( parent_datum.outFirst ) {
			// Since we've done both inside and outside, let's move on.
			next_node_index = 2;
		    } else {
			// We've done the inside one already so let's go outside.
			next_node_index =
			    ( ( parent_datum.orientation == LAST_FACE_OUTSIDE ) ?
			      1 : 0 );
			// We're implicitly undoing a swap, which we'll undo now.
			next_out_first = false;
		    }
		}
		while( next_node_index >= parent.getChildCount() ) {
		    node = parent;
		    node_datum = ( NodeData.NodeDatum )node_data.get( node );
		    parent = node.getParent();
		    if( parent == null ) {
			return ( TreeNode[] )list.toArray( new TreeNode[ 0 ] );
		    }
		    parent_datum = ( NodeData.NodeDatum )node_data.get( parent );
		    next_node_index = parent.getIndex( node );
		    if( next_node_index ==
			( ( parent_datum.orientation == LAST_FACE_OUTSIDE ) ?
			  1 : 0 ) ) { // We have just done the out face
			if( parent_datum.outFirst ) {
			    // We've done the outside one already so let's go inside.
			    next_node_index =
				( ( parent_datum.orientation == LAST_FACE_OUTSIDE ) ?
				  0 : 1 );
			    // Since we're going inside, switch orientations.
			    next_out_first = false;
			} else {
			    // Since we've done both inside and outside, let's move on.
			    next_node_index = 2;
			}
		    } else { // We're at the in face
			if( parent_datum.outFirst ) {
			    // Since we've done both inside and outside, let's move on.
			    next_node_index = 2;
			} else {
			    // We've done the inside one already so let's go outside.
			    next_node_index =
				( ( parent_datum.orientation == LAST_FACE_OUTSIDE ) ?
				  1 : 0 );
			    // We're implicitly undoing a swap, which we'll undo now.
			    next_out_first = false;
			}
		    }
		}
		node = parent.getChildAt( next_node_index );
		node_datum = ( NodeData.NodeDatum )node_data.get( node );
		node_datum.outFirst = next_out_first;
	    } else {
		parent = node;
		next_node_index =
		    ( ( node_datum.orientation == LAST_FACE_OUTSIDE ) ?
		      ( node_datum.outFirst ? 1 : 0 ) :
		      ( node_datum.outFirst ? 0 : 1 ) );
		if( ( next_node_index == 1 ) &&
		    ( parent.getChildCount() == 1 ) ) {
		    next_node_index = 0;
		    node_datum.outFirst = true;
		}
		node = parent.getChildAt( next_node_index );
	    }
	}
	return null;
    } // static sortLeaves(..)
    
    protected static NodePair[] candidateCouples (
						  NodeData.NodeDatum c_datum,
						  NodeData.NodeDatum d_datum
						  ) {
	int c_candidate_count = 0;
	if( c_datum.orientation == FIRST_FACE_OUTSIDE ) {
	    c_candidate_count = c_datum.firstFaces.size();
	} else if( c_datum.orientation == LAST_FACE_OUTSIDE ) {
	    c_candidate_count = c_datum.lastFaces.size();
	} else {
	    c_candidate_count =
		( c_datum.firstFaces.size() + c_datum.lastFaces.size() );
	}
	int d_candidate_count = 0;
	if( d_datum.orientation == FIRST_FACE_OUTSIDE ) {
	    d_candidate_count = d_datum.firstFaces.size();
	} else if( d_datum.orientation == LAST_FACE_OUTSIDE ) {
	    d_candidate_count = d_datum.lastFaces.size();
	} else {
	    d_candidate_count =
		( d_datum.firstFaces.size() + d_datum.lastFaces.size() );
	}
	NodePair[] candidate_couples =
	    new NodePair[ c_candidate_count * d_candidate_count ];
	TreeNode c_candidate;
	TreeNode d_candidate;
	for( int c_candidate_i = 0;
	     c_candidate_i < c_candidate_count;
	     c_candidate_i++ ) {
	    // Figure out the c part of the candidate pair
	    if( c_datum.orientation == FIRST_FACE_OUTSIDE ) {
		c_candidate = c_datum.firstFaces.get( c_candidate_i );
	    } else if( c_datum.orientation == LAST_FACE_OUTSIDE ) {
		c_candidate = c_datum.lastFaces.get( c_candidate_i );
	    } else if( c_candidate_i < c_datum.firstFaces.size() ) {
		c_candidate = c_datum.firstFaces.get( c_candidate_i );
	    } else {
		c_candidate =
		    c_datum.lastFaces.get( c_candidate_i - c_datum.firstFaces.size() );
	    }
	    for( int d_candidate_i = 0;
		 d_candidate_i < d_candidate_count;
		 d_candidate_i++ ) {
		// Figure out the d part of the candidate pair
		if( d_datum.orientation == FIRST_FACE_OUTSIDE ) {
		    d_candidate = d_datum.firstFaces.get( d_candidate_i );
		} else if( d_datum.orientation == LAST_FACE_OUTSIDE ) {
		    d_candidate = d_datum.lastFaces.get( d_candidate_i );
		} else if( d_candidate_i < d_datum.firstFaces.size() ) {
		    d_candidate = d_datum.firstFaces.get( d_candidate_i );
		} else {
		    d_candidate =
			d_datum.lastFaces.get( d_candidate_i - d_datum.firstFaces.size() );
		}
		// Make the pair.
		candidate_couples[ ( c_candidate_i * d_candidate_count ) + d_candidate_i ] =
		    new NodePair( c_candidate, d_candidate );
	    } // End for d_candidate_i
	} // End for c_candidate_i
	return candidate_couples;
    } // static candidateCouples(..)
    
    protected static Set aSet ( NodePair[] node_pairs, int count ) {
	HashSet set = new HashSet();
	for( int i = 0; i < count; i++ ) {
	    set.add( node_pairs[ i ].a );
	}
	return set;
    } // static aSet(..)
    
    protected static Set bSet ( NodePair[] node_pairs, int count ) {
	HashSet set = new HashSet();
	for( int i = 0; i < count; i++ ) {
	    set.add( node_pairs[ i ].b );
	}
	return set;
    } // static bSet(..)

    public static class NodeData
	extends HashMap {
      
	public NodeDatum addNodeDatum ( TreeNode for_node ) {
	    NodeDatum new_node_datum = new NodeDatum( for_node );
	    put( for_node, new_node_datum );
	    return new_node_datum;
	} // addNodeDatum(..)
      
	public class NodeDatum {
	    public TreeNode node;
	    public int orientation;
	    public NodeDatumFaces firstFaces;
	    public NodeDatumFaces lastFaces;
	    boolean outFirst;
  
	    public NodeDatum ( TreeNode node ) {
		this.node = node;
		orientation = UNDETERMINED;
		firstFaces = new NodeDatumFaces( true );
		lastFaces = new NodeDatumFaces( false );
		outFirst = true;
	    }
  
	    public class NodeDatumFaces {

		protected boolean firstFace;
		protected NodeDatum relevantChildDatum;

		public NodeDatumFaces ( boolean first_face ) {
		    firstFace = first_face;
		    // Here's a good time to point out that the orientation is fixed if
		    // there's not 2 children.
		    if( node.isLeaf() || ( node.getChildCount() == 1 ) ) {
			orientation = FIRST_FACE_OUTSIDE;
		    }
		    if( node.isLeaf() ) {
			relevantChildDatum = NodeDatum.this;
		    } else if( firstFace && ( orientation != LAST_FACE_OUTSIDE ) ) {
			relevantChildDatum =
			    ( NodeDatum )NodeData.this.get( node.getChildAt( 0 ) );
		    } else if( !firstFace && ( orientation != FIRST_FACE_OUTSIDE ) ) {
			relevantChildDatum =
			    ( NodeDatum )NodeData.this.get( node.getChildAt( 1 ) );
		    }
		}

		public int size () {
		    if( node.isLeaf() || ( node.getChildCount() == 1 ) ) {
			if( firstFace ) {
			    return 1;
			} else {
			    return 0;
			}
		    }
		    // If we're on the inside then there's no faces at all.
		    if( ( relevantChildDatum != null ) &&
			( ( firstFace && ( orientation == LAST_FACE_OUTSIDE ) ) ||
			  ( !firstFace && ( orientation == FIRST_FACE_OUTSIDE ) ) ) ) {
			relevantChildDatum = null;
		    }
		    if( relevantChildDatum == null ) {
			return 0;
		    }
		    return ( relevantChildDatum.firstFaces.size() +
			     relevantChildDatum.lastFaces.size() );
		} // size()

		public TreeNode get ( int index ) {
		    if( node.isLeaf() ) {
			if( ( index == 0 ) && firstFace ) {
			    return node;
			} else {
			    throw new NoSuchElementException( "\"" + node + "\"." + ( firstFace ? "firstFace" : "lastFace" ) + ".get( " + index + " ): Node is a leaf and this is the last face or the index is out of range." );
			    //return null;
			}
		    }
		    if( node.getChildCount() == 1 ) {
			if( ( index == 0 ) && firstFace ) {
			    return node.getChildAt( 0 );
			} else {
			    throw new NoSuchElementException( "\"" + node + "\"." + ( firstFace ? "firstFace" : "lastFace" ) + ".get( " + index + " ): Node has one child and this is the last face or the index is out of range." );
			    //return null;
			}
		    }

		    // If we're on the inside then there's no faces at all.
		    if( ( relevantChildDatum != null ) &&
			( ( firstFace && ( orientation == LAST_FACE_OUTSIDE ) ) ||
			  ( !firstFace && ( orientation == FIRST_FACE_OUTSIDE ) ) ) ) {
			relevantChildDatum = null;
		    }
		    if( relevantChildDatum == null ) {
			throw new NoSuchElementException( "\"" + node + "\"." + ( firstFace ? "firstFace" : "lastFace" ) + ".get( " + index + " ): relevantChildDatum is null.  Orientation is " + ( ( orientation == FIRST_FACE_OUTSIDE ) ? "FIRST_FACE_OUTSIDE" : ( ( orientation == LAST_FACE_OUTSIDE ) ? "LAST_FACE_OUTSIDE" : "UNDETERMINED" ) ) + "." );
			//return null;
		    }
		    if( index < relevantChildDatum.firstFaces.size() ) {
			return relevantChildDatum.firstFaces.get( index );
		    } else {
			return
			    relevantChildDatum.lastFaces.get(
							     index +
							     relevantChildDatum.firstFaces.size()
							     );
		    }
		} // get( int )

		public boolean contains ( TreeNode query_node ) {
		    if( node.isLeaf() ) {
			if( firstFace && ( query_node == node ) ) {
			    return true;
			} else {
			    return false;
			}
		    }
		    if( node.getChildCount() == 1 ) {
			if( firstFace && ( query_node.getParent() == node ) ) {
			    return true;
			} else {
			    return false;
			}
		    }
		    // If we're on the inside then there's no faces at all.
		    if( ( relevantChildDatum != null ) &&
			( ( firstFace && ( orientation == LAST_FACE_OUTSIDE ) ) ||
			  ( !firstFace && ( orientation == FIRST_FACE_OUTSIDE ) ) ) ) {
			relevantChildDatum = null;
		    }
		    if( relevantChildDatum == null ) {
			return false;
		    }
		    return ( relevantChildDatum.firstFaces.contains( query_node ) ||
			     relevantChildDatum.lastFaces.contains( query_node ) );
		} // contains( TreeNode )

		public void select (
				    TreeNode source,
				    Set nodes_to_select_as_couple_members
				    ) {
		    if( relevantChildDatum.orientation != UNDETERMINED ) {
			return;
		    }
		    // Find the subsets that include our relevant child's first and last
		    // faces.
		    HashSet first_subset = new HashSet();
		    HashSet last_subset = new HashSet();
		    Iterator ntsacm_iterator =
			nodes_to_select_as_couple_members.iterator();
		    TreeNode candidate_node;
		    while( ntsacm_iterator.hasNext() ) {
			candidate_node = ( TreeNode )ntsacm_iterator.next();
			if( relevantChildDatum.firstFaces.contains( candidate_node ) ) {
			    first_subset.add( candidate_node );
			} else if( relevantChildDatum.lastFaces.contains( candidate_node ) ) {
			    last_subset.add( candidate_node );
			}
		    }

		    if( first_subset.isEmpty() && last_subset.isEmpty() ) {
			throw new RuntimeException( "ASSERTION FAILED: Both subsets are empty." );
		    } else if( first_subset.isEmpty() ) {
			if( source == node ) {
			    // The first subset doesn't have any of the selected nodes, so it
			    // gets to go on the outside where it won't get in the way.
			    relevantChildDatum.orientation = FIRST_FACE_OUTSIDE;
			} else {
			    // If the source node is above node then we're already on
			    // the inside and we need to expose the subset with the goods.
			    relevantChildDatum.orientation = LAST_FACE_OUTSIDE;
			}
			relevantChildDatum.lastFaces.select( source, last_subset );
		    } else if( last_subset.isEmpty() ) {
			if( source == node ) {
			    // The last subset doesn't have any of the selected nodes, so it
			    // gets to go on the outside where it won't get in the way.
			    relevantChildDatum.orientation = LAST_FACE_OUTSIDE;
			} else {
			    // If the source node is above node then we're already on
			    // the inside and we need to expose the subset with the goods.
			    relevantChildDatum.orientation = FIRST_FACE_OUTSIDE;
			}
			relevantChildDatum.firstFaces.select( source, first_subset );
		    } else {
			// There's selections in both children.  We'll have to leave our
			// orientation undetermined for now.
			relevantChildDatum.firstFaces.select( source, first_subset );
			relevantChildDatum.lastFaces.select( source, last_subset );
		    }
		} // select(..)

	    } // inner class NodeDatumFaces
  
	} // inner class NodeDatum

    } // static inner class NodeData

    /**
     * NodePair is an unordered pair of TreeNodes: the pair ( a, b ) equals the
     * pair ( b, a ).
     */
    public static class NodePair {
	public TreeNode a;
	public TreeNode b;

	public NodePair ( TreeNode a, TreeNode b ) {
	    this.a = a;
	    this.b = b;
	}

	/**
	 * @return ( ( ( a == other_a ) && ( b == other_b ) ) ||
	 *         ( ( a == other_b ) && ( b == other_a ) ) )
	 */
	public boolean equals ( Object other_object ) {
	    if( !( other_object instanceof NodePair ) ) {
		return false;
	    }
	    TreeNode other_a = ( ( NodePair )other_object ).a;
	    TreeNode other_b = ( ( NodePair )other_object ).b;
	    return ( ( ( a == other_a ) && ( b == other_b ) ) ||
		     ( ( a == other_b ) && ( b == other_a ) ) );
	} // equals(..)

	/**
	 * @return the sum of the hashCodes of a and b.
	 */
	public int hashCode () {
	    long hash_code = 0;
	    if( a != null ) {
		hash_code = a.hashCode();
	    }
	    if( b != null ) {
		hash_code += b.hashCode();
	    }
	    return ( int )( hash_code % Integer.MAX_VALUE );
	} // hashCode()
    } // static inner class NodePair

} // class PairwiseDistanceBinaryTreeSorter
