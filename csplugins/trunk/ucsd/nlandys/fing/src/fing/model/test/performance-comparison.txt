ADJACENT EDGES TEST:

  Testing:
    RootGraph.getAdjacentEdgeIndicesArray(int, boolean, boolean, boolean)

  Importance:
    Getting touching edges lists for a node is very similar to getting
    node neighbors.  Both operations are the foundation of depth first
    and breadth first graph searching.  Therefore, good performance
    of this method is extremely important.

  Description of test:
    This test creates N nodes and E edges (an even mix of directed and
    undirected) in a RootGraph.  The topology of RootGraph created is
    defined by [random] bytes read from standard input.  For every node
    in the RootGraph, getAdjacentEdgeIndicesArray() is called on that
    node.  Because getAdjacentEdgeIndicesArray() takes three boolean
    input parameters defining which adjacent edges we're looking for,
    this test over all nodes should be repeated eight times, each time
    with a different set of boolean input parameters.  However, four of
    these boolean combinations cause the Luna implementation of
    RootGraph to throw NullPointerException in getAdjacentEdges().
    Therefore, this test is only repeated 4 times, each with a different
    set of boolean inputs:
      iteration 1: getAdjacentEdgeIndicesArray(int, true, true, true)
      iteration 2: getAdjacentEdgeIndicesArray(int, true, false, true)
      iteration 3: getAdjacentEdgeIndicesArray(int, false, false, false)
      iteration 4: getAdjacentEdgeIndicesArray(int, false, false, false)

  Test circumstances:
    Tests were performed on a 2.4GHz P4, with 512M RAM, and 256M memory
    was allocated to the JVM.

  Test results:

             Milliseconds taken to perform test case:

    graph size                          |  Fing  |  Luna  |
  --------------------------------------+--------+--------+
       7 nodes,      20 edges           |      2 |      3 |
     100 nodes,     500 edges           |      6 |     42 |
     100 nodes,   10000 edges           |      8 |     84 |
    1000 nodes,   20000 edges           |     25 |   1185 |
    1000 nodes,   39998 edges           |     45 |   1700 |
    2000 nodes,   20000 edges           |     30 |   3900 |
    4000 nodes,   20000 edges           |     32 |  16300 |
    8000 nodes,   20000 edges           |     42 |  64800 |
   16000 nodes,   20000 edges           |     94 | 258300 |
   39999 nodes,   39999 edges           |     93 |1743190 |
   16000 nodes,  100000 edges           |    127 |   fail |
   50000 nodes,  400000 edges           |    440 |   fail |
  100000 nodes, 1000000 edges           |   1050 |   fail |
  --------------------------------------+--------+--------+

  Afterthoughts:
    The implementation could be really sped up if the interface
    changes; instead of returning an array of integers, return
    an iteration over integers.  This would prevent a lot of
    unnecessary array allocation.


=======================================================================
CONNECTING EDGES TEST:

  Testing: A deprecated method:
    RootGraph.getEdgeIndicesArray(int, int, boolean, boolean)

  Importance:
    This method has been deprecated -- it is suggested to use
    getAdjacentEdgeIndicesArray(int, boolean, boolean, boolean) instead.
    I can't think of an important algorithm that requires the operation
    of getting all edges connecting two nodes.

  Description of test:
    This test creates N nodes and E edges (an even mix of directed and
    undirected) in a RootGraph.  The topology of RootGraph created is
    defined by [random] bytes read from standard input.  For every pair
    nodes whose order of creation was i, i+1, in the RootGraph,
    getEdgeIndicesArray() is called on that pair.  Because
    getEdgeIndicesArray() takes two boolean input parameters, this test
    is be repeated four times, each time with a different set of
    boolean input parameters.

  Test circumstances:
    Tests were performed on a 2.4GHz P4, with 512M RAM, and 256M memory
    was allocated to the JVM.

  Test results:

             Milliseconds taken to perform test case:

    graph size                          |  Fing  |  Luna  |
  --------------------------------------+--------+--------+
       7 nodes,      20 edges           |      3 |      2 |
     100 nodes,     500 edges           |     12 |     13 |
     100 nodes,   10000 edges           |     20 |      4 |
    1000 nodes,   20000 edges           |     47 |     10 |
    1000 nodes,   39998 edges           |     75 |     10 |
    2000 nodes,   20000 edges           |     53 |     11 |
    4000 nodes,   20000 edges           |     57 |     16 |
    8000 nodes,   20000 edges           |     70 |     20 |
   16000 nodes,   20000 edges           |    130 |     27 |
   39999 nodes,   39999 edges           |        |        |
   16000 nodes,  100000 edges           |    215 |   fail |
   50000 nodes,  400000 edges           |    800 |   fail |
  100000 nodes, 1000000 edges           |   2000 |   fail |
  --------------------------------------+--------+--------+

  Afterthoughts:
    This method was deprecated for a good reason -- it's not used
    by algorithms and it's not worth optimizing.  In the Fing
    implementation, this method iterates over all edges touching one
    of the nodes, choosing those edges which also touch the other node.
    Therefore, the time complexity of this method is linear with respect
    to the number of edges touching one of the input nodes.  It's
    possible to arrange the adjacent edge lists into tree-like
    structures in order to optimize this operation; this idea was
    discussed, and then it was decided to use plain old linked lists
    of adjacent edges in favor of trees, for the sake of simplicity of
    implementation.


=======================================================================
NODE NEIGHBORS TEST:

  Testing: A deprecated method:
    RootGraph.neighborsList(Node)

  Importance:
    This method has been deprecated -- it is suggested to use
    getAdjacentEdgeIndicesArray(int, boolean, boolean, boolean) instead.
    This method (or the one that returns adjacent edges) is typically
    used in graph depth-first and breadth-first search algorithms; a
    complete search of a graph would essentially call neighborsList()
    on every node exactly once by the time the search algorithm
    finished.

  Description of test:
    This test creates N nodes and E edges (an even mix of directed and
    undirected) in a RootGraph.  The topology of RootGraph created is
    defined by [random] bytes read from standard input.  For every node
    in the RootGraph, neighborsList() is called on that node.

  Test circumstances:
    Tests were performed on a 2.4GHz P4, with 512M RAM, and 256M memory
    was allocated to the JVM.

  Test results:

             Milliseconds taken to perform test case:

    graph size                          |  Fing  |  Luna  |
  --------------------------------------+--------+--------+
       7 nodes,      20 edges           |      3 |      2 |
     100 nodes,     500 edges           |     12 |     19 |
     100 nodes,   10000 edges           |     25 |     14 |
    1000 nodes,   20000 edges           |     52 |    285 |
    1000 nodes,   39998 edges           |     83 |    300 |
    2000 nodes,   20000 edges           |     61 |   1040 |
    4000 nodes,   20000 edges           |     57 |   5000 |
    8000 nodes,   20000 edges           |     68 |  21000 |
   16000 nodes,   20000 edges           |    116 |  84000 |
   39999 nodes,   39999 edges           |    170 | 563274 |
   16000 nodes,  100000 edges           |    215 |   fail |
   50000 nodes,  400000 edges           |    800 |   fail |
  100000 nodes, 1000000 edges           |   2000 |   fail |
  --------------------------------------+--------+--------+
