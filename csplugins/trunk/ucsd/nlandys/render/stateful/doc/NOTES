Thinking about the design goals of the rendering engine is very exciting
because many algorithmic puzzles are revealed in the process.

Design points, in no particular order:

LAYERING
========

Nodes can overlap on the canvas.  When two nodes overlap, one will be on
top and the other will be on bottom.  When a mouse is used to select
the overlapping region, the top node should be selected, not the bottom.
It should be possible, in an intuitive manner, to change to layering of
nodes.  Perhaps this could be done simply by placing the last-selected
node at the very top.  Now we're beginning to see that there is a total
ordering on all nodes in a graph.  The ordering of nodes not mutated
should remain the same with respect to each other; only nodes that are
intentionally mutated (layer order changed) should change.  For rendering,
nodes in the very back should be rendered first.  We need a good data
structure for finding out all nodes in order from back to front, and
only those nodes which are "currently visible".  That is, this data
structure will be changing very rapidly as we pan to other regions of
the graph.

Let's go through a scenario to better understand what is happening.
Say we have a graph with a million nodes (ignore the edges for now).
An R-tree structure for holding the nodes with their sizes and positions
is already established.  The rendering engine is told to render a given
rectangular area which intersects 100 of the nodes.  The R-tree is able
to return those 100 nodes in approximately O(M + Log(N)) time (where N is
the total number of nodes and M is the number of nodes returned, 100).
Our task is to order those 100 


LEMMA 1
=======

Given a set A and a set B which is slightly different from set A,
compute the sets B \ A and A \ B.

Place all elements of A into hastable H1 and place all elements of B into
hashtable H2.  To compute B \ A, initialize an empty set S1.
iterate through the elements in B, and for each element test for its
presence in H1; if the element is not in H1, add that element to S1.
A similar procedure for computing A \ B.  Therefore, the sets B \ A and
A \ B can each be computed in O(N + M) time where N is the cardinality of
A and M is the cardinality of B.  Memory consumption O(N + M).
