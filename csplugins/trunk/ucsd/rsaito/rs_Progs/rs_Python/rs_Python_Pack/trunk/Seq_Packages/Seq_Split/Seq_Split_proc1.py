#!/usr/bin/env python

import os
import sys
import stat
import subprocess

from Data_Struct.Dict_Restrict import Dict_Restrict
from Data_Process.split_and_merge1 import Split_and_Merge
from Seq_Packages.Seq.MultiFasta2 import MultiFasta_MEM
 

class Seq_Split_proc(Split_and_Merge):
    def init(self):

        param_def = Dict_Restrict({ 'num'     : 4,
                                    'wfile'   : "/tmp/testfile-",
                                    'cmd'     : r"sleep `expr $RANDOM %% 10`; echo Handling %s" })
        param_def.set_h(self.param)
        self.param = param_def
                
        mode_def = Dict_Restrict({ 'parseid' : False,
                                   'manual'  : False,
                                   'mess'    : False,
                                   'verbose' : False,
                                   'shuffle' : False,
                                   'misc'    : None
                                    })
        mode_def.set_h(self.mode)
        self.mode = mode_def
        
    def split(self):
        filename = self.obj_to_split
        num      = self.param['num']
                
        mfmem = MultiFasta_MEM(filename,
                               parseid = self.mode.get('parseid', False), 
                               shuffle = self.mode.get('shuffle', False))
                
        if self.mode.get('verbose', False):   
            print "Number of sequences:", len(mfmem.get_ids())
        
        mfs = mfmem.divide_to_seqs_set(num)

        if self.mode.get('verbose', False):
            print "Split OK."
            for i in range(len(mfs)):
                print "File #%d: %d sequences" % (i, len(mfs[i].get_ids()))
        
        self.split_ok = mfs # List of MultiFasta_MEM objects
        self.mf_files, self.res_files, self.sh_files = self.split_file__()

        for i in range(len(self.split_ok)):
            multi_fasta = self.split_ok[i]
            mffile_name = self.mf_files[i]
            fh = open(mffile_name, "w")
            fh.write(multi_fasta.out_fasta_all())
            fh.close()
    
    def split_file__(self):
        mf_files  = []
        res_files = []
        sh_files  = []
        basefile_name = self.param['wfile'] + str(os.getpid())

        for counter in range(len(self.split_ok)):
           
            mffile_name  = basefile_name + "_" + str(counter) + ".fasta"
            resfile_name = basefile_name + "_" + str(counter) + "_res"
            shfile_name  = basefile_name + "_" + str(counter) + ".sh"

            mf_files.append(mffile_name)
            res_files.append(resfile_name)
            sh_files.append(shfile_name)

        return mf_files, res_files, sh_files
   
    def process(self):
        if self.mode.get('manual', False):
            self.process_m__()
        else:
            self.process_a__()
    
    def process_m__(self):
        for i in range(len(self.mf_files)):
            fasta_file  = self.mf_files[i]
            result_file = self.res_files[i]
            sh_file     = self.sh_files[i]
            invoke = self.param['cmd'] % (fasta_file)
            
            fh = open(sh_file, "w")
            fh.write("""# This script was automatically generated by Seq_Split_proc.py.
%s > %s
""" % (invoke, result_file.split("/")[-1]))
            fh.close()
            os.chmod(sh_file, 
                     stat.S_IRWXU | stat.S_IRWXG | stat.S_IRWXO)
    
    def process_a__(self):
        procs   = []
        invokes = []
        
        for i in range(len(self.mf_files)):
            fasta_file  = self.mf_files[i]
            result_file = self.res_files[i]
            invoke = self.param['cmd'] % (fasta_file)
            proc = subprocess.Popen([invoke], shell = True, stdout = open(result_file, "w"))
            procs.append(proc) 
            invokes.append(invoke)    
            if self.mode.get('verbose', False):   
                print "Invoked:", invoke
    
        # proc = subprocess.Popen(["ls", "no_such_file"])
        # procs.append(proc)
        # invokes.append("ls XXXXX")
        
        for proc in procs:
            retc = proc.wait()
            if retc != 0:
                sys.stderr.write("Process %d (%s) has returned code %d.\n" 
                                 % (proc.pid, invokes[procs.index(proc)], retc))
                raise Exception, "Calculation aborted."
            
            if self.mode.get('verbose', False):
                print "Process %d (%s) terminated with code %d." % (proc.pid, invokes[procs.index(proc)], retc)
    
    def merge(self):
        if self.mode.get('manual', False):
            return

        res_files  = self.res_files        
        merge_file = self.param['wfile'] + "result"

        merge_results(res_files, merge_file)
    
    def finish(self):
        if self.mode.get('mess', False):
            return
        if self.mode.get('manual', False):
            return
        
        for i in range(len(self.mf_files)):
            fasta_file  = self.mf_files[i]
            result_file = self.res_files[i]
            sh_file     = self.sh_files[i]
            os.remove(fasta_file)
            os.remove(result_file)


def merge_results(res_files, merge_file):
        fh = open(merge_file, "w")
        for res_file in res_files:
            for line in open(res_file, "r"):
                fh.write(line)   
        fh.close() 


if __name__ == "__main__":
    
    import Usefuls.TmpFile as TMP
    tmpseq = TMP.TmpFile_II("""
>Seq1|First The first sequence
aaaattttccccgggg
aaaattttccccgggg

>Seq2|Second The second sequence
acgtacgt
acgtacgt

>Seq3|Third|San Mittsume

aattccgg
aaccggtt

>Seq4|Fourth|Yon Yottsume

aattcnnn
aaccggtt

>Seq5

aattcnnn
aaccggtt

>Seq6

aattcnnn
aaccggtt

>Seq7

aattcnnn
aaccggtt

>Seq8

aattcnnn
aaccggtt

>Seq9

aattcnnn
aaccggtt
aattcnnn
aaccggtt

>Seq10

aattcnnn
aaccggtt
aattcnnn
aaccggtt

""")
    
    ssp = Seq_Split_proc(tmpseq.filename(),
                         { 'num'     : 3,
                           'wfile'   : "/tmp/testfile-",
                           'cmd'     : r"sleep `expr $RANDOM %% 10`; echo blastall -i %s" },
                         { 'parseid' : False,
                           'manual'  : False,
                           'mess'    : True,
                           'verbose' : True,
                           'shuffle' : False,
                           'misc'    : None })
    
    ssp = Seq_Split_proc(tmpseq.filename(),
                         { 'num'     : 3,
                           'wfile'   : "/tmp/testfile_d-",
                           'cmd'     : r"sleep `expr $RANDOM %% 10`; echo blastall -i %s" },
                         {})

    
