#!/usr/bin/env python
#

""" Using BLAT is easy;
With sequence alignment:
blat -out=pslx subject_DB.fna query.fna outfile

Withoug sequence alignment:
blat -out=psl subject_DB.fna query.fna outfile


http://genome.brc.mcw.edu/FAQ/FAQformat#format2

PSL lines represent alignments, and are typically taken from files generated by BLAT or psLayout. See the BLAT documentation for more details. All of the following fields are required on each data line within a PSL file:

   1. matches - Number of bases that match that aren't repeats
   2. misMatches - Number of bases that don't match
   3. repMatches - Number of bases that match but are part of repeats
   4. nCount - Number of 'N' bases
   5. qNumInsert - Number of inserts in query
   6. qBaseInsert - Number of bases inserted in query
   7. tNumInsert - Number of inserts in target
   8. tBaseInsert - Number of bases inserted in target
   9. strand - '+' or '-' for query strand. For translated alignments, second '+'or '-' is for genomic strand
  10. qName - Query sequence name
  11. qSize - Query sequence size
  12. qStart - Alignment start position in query
  13. qEnd - Alignment end position in query
  14. tName - Target sequence name
  15. tSize - Target sequence size
  16. tStart - Alignment start position in target
  17. tEnd - Alignment end position in target
  18. blockCount - Number of blocks in the alignment (a block contains no gaps)
  19. blockSizes - Comma-separated list of sizes of each block
  20. qStarts - Comma-separated list of starting positions of each block in query
  21. tStarts - Comma-separated list of starting positions of each block in target 

Example:
Here is an example of an annotation track in PSL format. Note that line breaks have been inserted into the PSL lines in this example for documentation display purposes. Click here for a copy of this example that can be pasted into the browser without editing.

track name=fishBlats description="Fish BLAT" useScore=1
59 9 0 0 1 823 1 96 +- FS_CONTIG_48080_1 1955 171 1062 chr22
    47748585 13073589 13073753 2 48,20,  171,1042,  34674832,34674976,
59 7 0 0 1 55 1 55 +- FS_CONTIG_26780_1 2825 2456 2577 chr22
    47748585 13073626 13073747 2 21,45,  2456,2532,  34674838,34674914,
59 7 0 0 1 55 1 55 -+ FS_CONTIG_26780_1 2825 2455 2676 chr22
    47748585 13073727 13073848 2 45,21,  249,349,  13073727,13073827,

Be aware that the coordinates for a negative strand in a PSL line are handled in a special way. In the qStart and qEnd fields, the coordinates indicate the position where the query matches from the point of view of the forward strand, even when the match is on the reverse strand. However, in the qStarts list, the coordinates are reversed.

Example:
Here is a 30-mer containing 2 blocks that align on the minus strand and 2 blocks that align on the plus strand (this sometimes can happen in response to assembly errors):

0         1         2         3 tens position in query  
0123456789012345678901234567890 ones position in query   
            ++++          +++++ plus strand alignment on query   
    --------    ----------      minus strand alignment on query   

Plus strand:   
     qStart=12 
     qEnd=31 
     blockSizes=4,5 
     qStarts=12,26 
                  
Minus strand:   
     qStart=4 
     qEnd=26 
     blockSizes=10,8 
     qStarts=5,19   

Essentially, the minus strand blockSizes and qStarts are what you would get if you reverse-complemented the query. However, the qStart and qEnd are not reversed. To convert one to the other:

     qStart = qSize - revQEnd
     qEnd = qSize - revQStart

"""

""" Sample

psLayout version 3

match   mis-    rep.    N's     Q gap   Q gap   T gap   T gap   strand  Q               Q       Q       Q       T               T       T       T       block   blockSizes      qStarts  tStarts
        match   match           count   bases   count   bases           name            size    start   end     name            size    start   end     count
---------------------------------------------------------------------------------------------------------------------------------------------------------------
188     1       0       1       0       0       1       100     -       tmpseq3 190     0       190     lcl|testseq     300     0       290     2       100,90, 0,100,  0,200,

BLASTN 2.2.11 [blat]

Reference:  Kent, WJ. (2002) BLAT - The BLAST-like alignment tool

Query= tmpseq3
         (190 letters)

Database: testseq.fna 
           1 sequences; 300 total letters

Searching.done
                                                                 Score    E
Sequences producing significant alignments:                      (bits) Value

lcl|testseq                                                           194   1e-49
lcl|testseq                                                           176   4e-44



>lcl|testseq 
          Length = 300

 Score = 194 bits (501), Expect = 1e-49
 Identities = 99/100 (99%)
 Strand = Minus / Plus

Query: 190 ccccctccccacccccccccaaccccccccaaacccccccaaaaccccccaaaaaccccc 131
           ||||| ||||||||||||||||||||||||||||||||||||||||||||||||||||||
Sbjct: 1   ccccccccccacccccccccaaccccccccaaacccccccaaaaccccccaaaaaccccc 60

Query: 130 aaaaaaccccaaaaaaacccaaaaaaaaccaaaaaaaaac 91
           ||||||||||||||||||||||||||||||||||||||||
Sbjct: 61  aaaaaaccccaaaaaaacccaaaaaaaaccaaaaaaaaac 100


 Score = 176 bits (454), Expect = 4e-44
 Identities = 89/90 (99%)
 Strand = Minus / Plus

Query: 90  gggggnggggtgggggggggttggggggggtttgggggggttttggggggtttttggggg 31
           ||||| ||||||||||||||||||||||||||||||||||||||||||||||||||||||
Sbjct: 201 ggggggggggtgggggggggttggggggggtttgggggggttttggggggtttttggggg 260

Query: 30  ttttttggggtttttttgggttttttttgg 1
           ||||||||||||||||||||||||||||||
Sbjct: 261 ttttttggggtttttttgggttttttttgg 290

  Database: testseq.fna
"""

import re

NUM_Match = re.compile(r'^\d')

class BLAT_hit:
    def __init__(self, 
                 query_id = None,
                 subject_id = None,
                 query_len = None,
                 subject_len = None,
                 strand = None,
                 query_start = None,
                 query_end = None,
                 subject_start = None,
                 subject_end = None,
                 blocks = None,
                 block_sizes = None,
                 query_starts = None,
                 subject_starts = None,
                 query_aligns = None,
                 subject_aligns = None,
                 matches = None):
        
        self.matches = matches
        self.query_id = query_id
        self.query_len = query_len
        self.query_start = query_start
        self.query_end = query_end
        self.subject_id = subject_id
        self.subject_len = subject_len
        
         # Origin is 0. start, end indicates bases from start to end - 1.
        self.subject_start = subject_start
        self.subject_end = subject_end
        
        self.strand = strand
        self.blocks = blocks
        self.block_sizes = block_sizes
        self.query_starts = query_starts
        self.subject_starts = subject_starts
        self.query_aligns = query_aligns
        self.subject_aligns = subject_aligns      
    
    def get_matches(self):
        return self.matches
    
    def get_query_id(self):
        return self.query_id
    
    def get_subject_id(self):
        return self.subject_id
    
    def get_strand(self):
        return self.strand
    
    def get_subject_start(self):
        return self.subject_start
    
    def get_subject_end(self):
        return self.subject_end
    
    def get_block_sizes(self):
        return self.block_sizes
    
    def block_map(self):
        """ 
        Returned query positions p_start, p_end on '+' strand means bases from p_start to p_end - 1.
        Returned query positions p_end, p_start on '-' strand means bases from p_start to p_end - 1 which aligns
        to antisense strand of subject (target) sequence.

        """

        b_map = []
        for i in range(len(self.query_starts)):
            query_start   = self.query_starts[i]
            subject_start = self.subject_starts[i]
            block_size    = self.block_sizes[i]
            if self.strand == "+":
                b_map.append((query_start, # + 1 omitted
                              query_start + block_size,
                              subject_start, # + 1 omitted
                              subject_start + block_size))
            elif self.strand == "-":
                b_map.append((self.query_len - query_start,
                              self.query_len - query_start - block_size, # + 1 omitted
                              subject_start, # + 1 omitted
                              subject_start + block_size))
            else:
                raise "Strand information blank ..."

        return b_map
                
    def __repr__(self):
        return self.__dict__.__repr__()

class BLAT_psl:
    def __init__(self, pslx_out_file, bestonly = False, UCSC_map = False, MultiID = False, Version = True):
        self.blat_matches    = {}
        self.blat_best_match = {}
        self.read_psl(pslx_out_file, bestonly, UCSC_map, MultiID, Version)
    
    def regist_psl(self,
                   matches,
                   strand,
                   query_id,
                   query_len,
                   query_start,
                   query_end,
                   subject_id,
                   subject_len,
                   subject_start,
                   subject_end,
                   blocks,
                   block_sizes,
                   query_starts,
                   subject_starts,
                   bestonly = False
                   ):
        
        if query_id not in self.blat_matches:
            self.blat_matches[ query_id ] = []
            self.blat_best_match[ query_id ] = 0
                
        if bestonly is False:
            self.blat_matches[ query_id ].append(BLAT_hit( matches = matches,
                                                           strand = strand,
                                                           query_id = query_id,
                                                           query_len = query_len,
                                                           query_start = query_start,
                                                           query_end = query_end,
                                                           subject_id = subject_id,
                                                           subject_len = subject_len,
                                                           subject_start = subject_start,
                                                           subject_end = subject_end,
                                                           blocks = blocks,
                                                           block_sizes = block_sizes,
                                                           query_starts = query_starts,
                                                           subject_starts = subject_starts,
                                                           # query_aligns = query_aligns,
                                                           # subject_aligns = subject_aligns)
                                                           ))                                 
                
        if matches > self.blat_best_match[ query_id ]:
            self.blat_best_match[ query_id ] = matches
            if bestonly is True:
                self.blat_matches[ query_id ] = [ BLAT_hit( matches = matches,
                                                            strand  = strand,
                                                            query_id = query_id,
                                                            query_len = query_len,
                                                            query_start = query_start,
                                                            query_end = query_end,
                                                            subject_id = subject_id,
                                                            subject_len = subject_len,
                                                            subject_start = subject_start,
                                                            subject_end = subject_end,
                                                            blocks = blocks,
                                                            block_sizes = block_sizes,
                                                            query_starts = query_starts,
                                                            subject_starts = subject_starts,
                                                            # query_aligns = query_aligns,
                                                            # subject_aligns = subject_aligns
                                                            ) ]                                               
            
            # print matches, query_id, subject_id, query_align, subject_align
    
    
    def read_psl(self, pslx_out_file, bestonly = False,
                 UCSC_map = False, MultiID = False, Version = True):    
    
        for line in open(pslx_out_file):
            r = line.rstrip().split("\t")
            if not NUM_Match.search(line) or len(r) < 18:
                continue
            if UCSC_map:
                r.pop(0)
                
            matches        = int(r[ 0])
            strand         = r[ 8]
            query_id_str   = r[ 9]
            query_len      = int(r[10])
            query_start    = int(r[11])
            query_end      = int(r[12])
            subject_id_str = r[13]
            subject_len    = int(r[14])
            subject_start  = int(r[15])
            subject_end    = int(r[16])
            blocks         = int(r[17])
            block_sizes    = map(lambda x:int(x), r[18].rstrip(",").split(","))
            query_starts   = map(lambda x:int(x), r[19].rstrip(",").split(","))
            subject_starts = map(lambda x:int(x), r[20].rstrip(",").split(","))
            # query_aligns   = r[21].rstrip(",").split(",")
            # subject_aligns = r[22].rstrip(",").split(",")

            if MultiID and '|' in query_id_str:
                query_ids    = []
                query_ids_wt = query_id_str.split('|')
                i = 1
                while i < len(query_ids_wt):
                    query_ids.append(query_ids_wt[i])
                    i += 2
            else:
                query_ids   = [ query_id_str   ] 
                               
            if MultiID and '|' in subject_id_str:
                subject_ids    = []
                subject_ids_wt = subject_id_str.split('|')
                i = 1
                while i < len(subject_ids_wt):
                    subject_ids.append(subject_ids_wt[i])
                    i += 2
            else:
                subject_ids = [ subject_id_str ]
                    

            for query_id in query_ids:
                for subject_id in subject_ids:
                    if Version is False:
                        query_id   = query_id.split('.')[0]
                        subject_id = subject_id.split('.')[0]
                        
                    self.regist_psl(matches,
                                    strand,
                                    query_id,
                                    query_len,
                                    query_start,
                                    query_end,
                                    subject_id,
                                    subject_len,
                                    subject_start,
                                    subject_end,
                                    blocks,
                                    block_sizes,
                                    query_starts,
                                    subject_starts,
                                    bestonly)

    def sort_by_match(self):
        for query_id in self:
            self.blat_matches[query_id].sort(lambda m1, m2: m2.get_matches() - m1.get_matches())

    def largest_block_sizes_sort(self, query_id):
        
        matches = self[ query_id ]
        res = []
        for match in matches:
            res.append(max(match.get_block_sizes()))
        res.sort(lambda x, y: y - x)
        return res
    

    def __iter__(self):
        return self.blat_matches.__iter__()

    def __getitem__(self, query_id):
        return self.blat_matches[ query_id ]


if __name__ == "__main__":
    from Usefuls.rsConfig import RSC_II
    rsc = RSC_II("rsSAT_Config")    

    blatres = BLAT_psl(rsc.Human11k_Cancer_ONC_Map_hg17_BLAT_all,
                       bestonly = False,
                       UCSC_map = False, MultiID = True, Version = True)
    blatres.sort_by_match()
    
    for entry in blatres:
        for hit in blatres[entry]:
            # print entry, blatres[entry]
            # print entry, blatres[entry][0].get_subject_id(), blatres[entry][0].get_strand(), blatres[entry][0].block_map()
            print entry, hit.get_subject_id(), hit.get_strand(), hit.get_matches(), blatres.largest_block_sizes_sort(entry)
    
    print    
        
    import Usefuls.TmpFile
    tmp_obj = Usefuls.TmpFile.TmpFile_III("""

match   mis-    rep.    N's     Q gap   Q gap   T gap   T gap   strand  Q               Q       Q       Q       T               T       T       T       block   blockSizes      qStarts  tStarts
        match   match           count   bases   count   bases           name            size    start   end     name            size    start   end     count
---------------------------------------------------------------------------------------------------------------------------------------------------------------
188     1       0       1       0       0       1       100     -       tmpseq3 190     0       190     lcl|testseq     300     0       290     2       100,90, 0,100,  0,200,


""")
    blatres = BLAT_psl(tmp_obj.filename(),
                       bestonly = True,
                       UCSC_map = False, MultiID = True, Version = True)
    for entry in blatres:
        # print entry, blatres[entry]
        print entry, blatres[entry][0].get_subject_id(), blatres[entry][0].get_strand(), blatres[entry][0].block_map()

