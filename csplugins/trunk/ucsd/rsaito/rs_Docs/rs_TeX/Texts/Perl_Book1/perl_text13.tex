\documentclass[a4j,twoside]{jbook}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%package
\usepackage{fancyhdr}
\usepackage{fancybox}
\usepackage{makeidx}
\makeindex
\def\seename{$\Longrightarrow$}

%\setcounter{chapter}{0}
%\setcounter{section}{0}
%\setcounter{figure}{0}
%\setcounter{table}{0}
%\setcounter{footnote}{0}
%\setcounter{equation}{0}

\newcounter{question}[chapter]
\setcounter{question}{1}

%renewcommand
\renewcommand{\cleardoublepage}{\clearpage}
\renewcommand{\headrulewidth}{1.0pt}
\renewcommand{\footrulewidth}{0.0pt}
\renewcommand{\thechapter}{\arabic{chapter}}
\renewcommand{\thesection}{\arabic{section}}

%header, footer
\pagestyle{fancy}
\lhead[\thepage]{}
\rhead[]{\thepage}
\chead[第\thechapter 章]{\rightmark}
\cfoot{}

%page space
\setlength{\textwidth}{\paperwidth}
\setlength{\headwidth}{\paperwidth}
\addtolength{\headwidth}{-2in}
\addtolength{\textwidth}{-2in}
\setlength{\evensidemargin}{1pt}
\setlength{\oddsidemargin}{1pt}
\setlength{\textheight}{\paperheight}
\addtolength{\textheight}{-2in}
\setlength{\topmargin}{0pt}
\setlength{\headheight}{1em}
\setlength{\headsep}{1em}
\addtolength{\textheight}{-2em}

\newenvironment{waku} 
{\begin{Sbox}\begin{minipage}{0.9\textwidth}} 
{\end{minipage}\end{Sbox}\shadowbox{\TheSbox}} 

%title
\title{\Huge 初学者のためのPerlによる\\バイオプログラミング演習}
\author{
\LARGE
松井 求・斎藤 輪太郎 著 \\
\LARGE
冨田 勝 監修
}
\date{}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}

\maketitle

\chapter*{はじめに}
\paragraph{
~ポストゲノムの時代を迎え分子生物学の実験データが大変な勢いで蓄積されている．これら膨大な量の公共データと自分が出した実験データを比較，解析し，有用な情報を抽出するためにはBioinformaticsを縦横無尽に駆使することが必要不可欠である．すでに現在までに様々な目的に応じた有用なソフトウェアが開発され，多くは無料で配布されている．既存のプロトコルにそった解析で間に合うのであればこれらのソフトウェアを用いる事で十分な結果が見込まれるであろう．しかし独自の仮説に基づいた解析を行う，大量のデータを相手にする，複数のソフトウェアを組み合わせて用いるといった場合はそれだけでは不十分である．このような場合は自分でプログラムを書いて柔軟にソフトウェアを組み合わせかつ作業を自動化する，あるいは自前で計算をこなすことが求められる．このような用途に用いられるプログラミング言語に必要なのは外部のソフトウェアを自由に操作する事ができること，そして自前で計算やテキスト処理をこなす能力をもつことである．さらには初心者でも簡単に習得でき，他の広い分野にも応用できる汎用的な言語であればなお好ましい．このような要望に十分に答えうる言語のひとつがPerlである．\\
~~PerlはCGIに代表される現代のWebコンテンツを維持する為に無くてはならない言語として知られており，同時にそのまま"テキストデータ"であるゲノム情報，あるいは生化学データなどを解析することが非常に得意な言語でもある．さらに記述法の自由度が高い為に初学者がなじみやすいという特徴も併せ持つ．しかしながらこれまでは，他言語の経験のあるプログラマや情報学者を対象にしたプログラミングの解説書は多数出版されているもののプログラミングの経験のない分子生物学者にとってはかなり敷居の高い内容となってしまっており，必ずしもBioinformatics に向けたPerl の学習環境が整っているとは言えなかった．忙しい研究の合間に，あるいは実習の合間にプログラミングを習得していくことを想定した場合，必要なのは多量の情報を詰め込んだ解説書ではなく，必要最小限の事項のみを網羅した演習形式の解説書であると考える．このようなものが手元にあれば短期間に効率のよく研究に必要なPerlのプログラミング技術を理解し習得する事ができると思われる．\\
~~本書はこのような要請に応えるべく，慶應義塾大学湘南藤沢キャンパス(SFC)で行なわれている実習形式の講義，"ゲノム解析プログラミング実習"で用いられている講義資料を元に大幅な加筆，修正を施したものである．講義の対象は主にプログラミング経験のない学部1,2年生であり，従って本書の対象はプログラミングの知識を前提としない生物学者および生物学専攻の学生となる．本書の内容は大まかに基礎演習と実践演習の二部に分かれる．まず第1,2章でPerlプログラミングの基礎をひととおり網羅した．各確認事項ごとに練習問題，及び解答をつけたので一題ずつ解いていくことで効率よく必要事項を学ぶ事ができると思われる．さらに3章でゲノム配列解析，遺伝子発現データの解析，生化学データの解析の実習問題をあげた．この問題を通して実用的なプログラミング能力を習得していただきい．また本書に掲載したプログラム，およびサンプルデータはすべて以下のWebページに載せた．参考にしていただければと思う．\\
http://www.../\\
~~最後に本書を執筆するにあたってお世話になった方々にお礼申し上げたい．まず鈴木治夫氏，永安悟史氏にはお忙しい中本書執筆にご協力いただいた．そして慶應義塾大学先端生命研究室の皆さん，特に岡田祐輝氏には多くの貴重なご指摘，ご意見をいただいた．この場を借りて感謝申し上げる．また本書の出版にあたってピアソン・エデュケーションの藤村行俊氏には大変お世話になった．深く感謝を申し上げる．
}
\begin{flushright}
2006年12月24日 松井求
\end{flushright}
\tableofcontents

\chapter{Perlプログラミングを始めるまえに}
\section{準備するもの} 必要なものはPCだけです．Perl\index{Perl}プログラミングはLinux, Mac, WindowsといったほとんどすべてのOS\footnote{Perlはプラットフォームに非依存，かつフリーな言語です．以下にPerlの環境を用意する上で有用な文献，Webページをあげます．}で可能です．本書ではLinuxでの作業を想定して述べていきますが，他のOSでもほとんど同様にできるはずです．例えばLinuxは始めからPerlが含まれており，それはプロンプトを開いてすぐに確認することができます．Mac OSXにも同様にはじめからPerlが含まれていてやはりTerminal上で全く同様に行うことができます．Windowsでプログラミングを行う場合には若干のツールのインストールが必要かもしれません．ActivePerlあるいはCygwin\index{Cygwin}等を使うと便利でしょう．詳しくはマシン管理者に問い合わせてみてください．\\
　本書を学習するにあたっては即実用に役立つようにとの目的からあえて詳しい説明を省いた箇所があります．より深く学習されたい方はぜひリファレンスを手元に用意するとよいと思います．あるいはそういった資料はネット上に充実しています．参考にしてみてください．

\section{login, logout\index{login, logout}}
\begin{description}
\item{解説} Linuxではコマンドによってコンピュータに命令を与えます．以下に最低限知っておくべきコマンドをあげます．どれも重要なコマンドですのでひとつづつ動作を確認してみましょう．
\begin{table}[h]
\begin{center}

\caption{代表的なコマンド}

\begin{tabular}{lll}\hline
コマンド&意味&例文\\ \hline
ls\index{ls}&ディレクトリの中身を表示&ls ディレクトリ\\ %\hline
cd\index{cd}&カレントディレクトリの移動&cd ディレクトリ\\ %\hline
cp\index{cp}&ファイルのコピー&cp 元ファイル 新規ファイル\\ %\hline
mkdir\index{mkdir}&ディレクトリの新規作成&mkdir 新規ディレクトリ\\ %\hline
less\index{less}&ファイルの中身を表示&less ファイル\\ %\hline
mv\index{mv}&ファイル，ディレクトリの移動&mv 元ファイル 新規ファイル\\ %\hline
rm\index{rm}&ファイルの削除&rm ファイル\\ %\hline
emacs\index{emacs}&emacs(エディタ)の起動&emacs -nw ファイル\\ %\hline
exit\index{exit}&ログアウト&exit\\ %\hline
chmod\index{chmod}&パーミッション変更&chmod 755 ファイル\\ %\hline
perl\index{perl}&Perlインタプリタの起動&perl HelloWolrd.pl\\ \hline
\end{tabular}
\end{center}
\end{table}
\item{問題\stepcounter{question}\thequestion (★☆☆☆☆)} ホームディレクトリの下にperl$\_ $exerというディレクトリを作成してください．以後の作業はこのディレクトリで行いましょう．
\end{description}

\section{Perlとは}
\begin{description}
\item{解説} コンピュータは指令に従って計算を行う機械です．使用者はなんらかの方法でコンピュータに指令を出さなくてはいけません．そのひとつの方法としてコンピュータに対する指令を順番にファイルに書き込みコンピュータに手渡すという方法があります．この場合コンピュータはそのファイルを読み込み，書いてある指令を順にこなしていくわけですが，指令の書き方/文法は様々なものがあります．その文法のひとつがPerl言語です．
\item{問題\stepcounter{question}\thequestion (★☆☆☆☆)} perlというコマンドを打ってみましょう．すると入力待ち状態になります．そこで以下のように記述し，計算結果を表示させてみてください(\%はプロンプト)．8と出力されれば正解です．\\
\begin{waku}
\begin{verbatim}
% perl 
print 5+3;
_ _END_ _
\end{verbatim}
\end{waku}
\end{description}

\section{Perlの書き方}
\begin{description}
\item{解説} 今見たようにPerlは適宜起動して作業を行わせることができますが，スクリプトとして保存して繰り返し使用することも可能です．このようなPerlスクリプトを書く上で必要なのがエディタです．Linuxで代表的なエディタ\index{えでぃた@エディタ}にはEmacs\index{Emacs}とviがありますが，ここではEmacsを使います\footnote{Windowsではメモ帳，xyzzy，秀丸等があります．使いやすいものを用いてください}．以下に基本的なコマンドをあげます．特にC+z⇔fgは効率のいいプログラミングに必須でしょう．\\
\begin{table}[h]
\begin{center}

\caption{Emacsの主なコマンド}

\begin{tabular}{ll}\hline
\multicolumn{2}{c}{シェル内での移動}\\ \hline
emacs -nw&同ウィンドウ内で起動\\ %\hline
emacs $\& $&別のウィンドウで起動\\ %\hline
C-z&Emacsの中断，シェルに戻る\\ %\hline
fg&シェルから中断したEmacsに戻る\\ \hline
\multicolumn{2}{c}{保存}\\ \hline
C-x C-s&ファイルへの保存\\ %\hline
C-x C-w&別ファイル名で保存\\ \hline
\multicolumn{2}{c}{編集}\\ \hline
C-k&カーソル上の文字から行末までの削除\\ %\hline
C-w&リージョンの削除\\ %\hline
M-w&リージョンのコピー\\ %\hline
C-y&キルバッファの内容の取り出し\\ %\hline
C-x u&操作の取り消し\\ %\hline
C-x z&操作の繰り返し\\ %\hline
C-s&カーソル以降の文字列検索\\ %\hline
C-r&カーソル以前の文字列検索\\ \hline
\end{tabular}
\end{center}
\end{table}

\item{問題\stepcounter{question}\thequestion (★☆☆☆☆)} まず以下のようにしてEmacsを起動してください．\\
\begin{waku}
\begin{verbatim}
% emacs -nw nucleotide.txt
\end{verbatim}
\end{waku}\\
そして以下の内容を書き込み，保存しましょう．するとnucleotide.txtというファイルができているはずです．lessコマンドで観覧してみてください．\\
\begin{waku}
\begin{verbatim}
adenine
thymine
cytosine
guanine
\end{verbatim}
\end{waku}
\end{description}

\section{Perlの動かし方}
\begin{description}
\item{解説} Perlプログラムを実行するにはperlインタプリタにファイル(perlスクリプト)を渡し，実行してもらう必要があります．まずEmacsを起動して以下の内容を書き込みましょう．\\
\begin{waku}
\begin{verbatim}
% emacs -nw test.pl 	#emacsの起動，perlスクリプトの編集
\end{verbatim}
\end{waku}\\
書き込む内容\\
\begin{waku}
\begin{verbatim}
print "Hello, World!\n";
\end{verbatim}
\end{waku}\\
保存してシェルに戻ったら以下のコマンドを打ち込む．\\
\begin{waku}
\begin{verbatim}
% perl test.pl
\end{verbatim}
\end{waku}\\
これでtest.plというperlスクリプトが実行されます．結果を確認してみてください．ところでtest.plの中身は以降勉強していくとして，一般のperlスクリプトの先頭には次のように書いてある場合があります．\\
\begin{waku}
\begin{verbatim}
#!/usr/bin/perl

プログラム．．．
\end{verbatim}
\end{waku}\\
これはこのスクリプトを読み込んで実行するものとしてperlインタプリタを指定している，という文です．ためしに\\
\begin{waku}
\begin{verbatim}
% which perl
\end{verbatim}
\end{waku}\\
というコマンドを打ってみましょう．/usr/bin/perlなどという応答が帰ってくるはずです．これは/usr/binというディレクトリの下にperlインタプリタが置いてあることを意味しています．つまり\verb|#!/usr/bin/perl|と書いてあるスクリプトはそれに続く命令文を/usr/bin/perlに読み込んでもらうということになるのです．
\\
さて，この機構を利用して実行するには先ほどとは違い以下のようにします．\\
\begin{waku}
\begin{verbatim}
% emacs test.pl -nw	#編集
(% chmod 755 test.pl	#実行権を与える)
% ./test.pl		#実行
\end{verbatim}
\end{waku}\\
perlというコマンドがいらなくなったのは分かりましたか？実際にはどちらの方法でスクリプトを実行させてもかまいません．例えばインタプリタが置いてある場所はシステムごとに異なるので\verb|#!|の行を省略するという考え方もありますし，それとの中間的な方法として\\
\verb|#!/usr/bin/env perl|\\
と書く人もいます\footnote{chmodはパーミッションを変更するコマンドです．}．
\end{description}

\chapter{Perl入門}

第2章ではPerlでプログラムを書く為に必要なスキルを一通り身に付けることを目標とします．とはいってもPerlはシンプルな言語です．覚える事柄は多くありません．1) データを保持する入れ物としての変数，2) それを操作する関数や演算子，3)そして作業の流れを制御するループや条件分岐，の扱い方を覚えるだけでほとんどの作業に適用することができるようになります．本章では上に上げた三つの事柄を網羅した練習問題63題を用意しました．順に解いていく事で無理無く必要事項をマスターできるでしょう．

\section{標準出力\index{ひょうじゅんしゅつりょく@標準出力}}
\begin{description}
\item{解説} print文で文字列または数値を表示することができます．\verb|\n|は改行を表します\footnote{セミコロンに注意！}．先ほど取り上げた以下の例は"Hello, World!"と画面上に出力させる命令文です．\\
\begin{waku}
\begin{verbatim}
print “Hello, world!", "\n”;
\end{verbatim}
\end{waku}
\item{問題\stepcounter{question}\thequestion (★☆☆☆☆)} 
123 x 456の答えを，”123 x 456 =”という文字列の後に表示しましょう．
\item{ヒント} $2*3$で2$\times$3が計算できます．また,(カンマ)で区切られた文字列は連続して出力されます．
\end{description}

\section{スカラー変数\index{すからーへんすう@スカラー変数}}
\begin{description}
\item{解説} \verb|"$名前”でスカラー変数になります．文字列と数値のどちらも同様にスカラー変数に代入することができます．変数に値を代入する演算子は"="で，これは右側の値を左側の変数に代入するという意味になります．|\\
\begin{waku}
\begin{verbatim}
$nucleotide = "uracil";
print $nucleotide, “\n”;
\end{verbatim}
\end{waku}
\item{問題\stepcounter{question}\thequestion (★☆☆☆☆)} 
\verb|変数$xに86400, $yに365を代入し，$z = $x * $yとして，$zの値を表示しましょう．|

\item{解説} \verb|変数の中の値を増やす方法がいくつかあります．$x = $x + 10で$xの値が10増えます．また$x ++は$x = $x + 1と等価です．|\\
\begin{waku}
\begin{verbatim}
$x = 3;
$x = $x + 5;
print $x, “\n”;
\end{verbatim}
\end{waku}
\item{問題\stepcounter{question}\thequestion (★☆☆☆☆)} 
\verb|$xに10を，$yに5を代入しましょう．そして$xに$x+$yを代入して$xの中身を出力しましょう．|
\end{description}

\section{配列変数\index{はいれつへんすう@配列変数}}
\begin{description}
\item{解説} \verb|”@名前”で配列を扱うことができます．@arrayでarrayという名前の配列を扱うことができます．$array[3]で@arrayの中の4番目の要素を取り出すことができます．以下の例ではcytosineが出力されるはずです|\footnote{Perlの中では1番目のものは0番目と認識されます．同様に2,3,...番目のものは1,2,...となります．}．\\
\begin{waku}
\begin{verbatim}
@nucleotide = (“adenine”, “thymine”, "cytosine”, “guanine”);
print $nucleotide[2], “\n”;
\end{verbatim}
\end{waku}
\item{問題\stepcounter{question}\thequestion (★☆☆☆☆)} \verb|”Sunday”, “Monday”, “Tuesday”, …, “Saturday”を@weekの中に入れましょう．そして，配列の中の３番目の要素を出力しましょう．|
\end{description}

\section{split\index{split}関数}
\begin{description}
\item{解説} splitを使うと，文字列を区切り文字で区切って，配列に格納することができます．\\
\begin{waku}
\begin{verbatim}
$str = “a,b,c,d,e”;
@array = split(/,/, $str);
print $array[2];
\end{verbatim}
\end{waku}
\item{問題\stepcounter{question}\thequestion (★★☆☆☆)} \verb|文字列”Sun-Mon-Tue-Wed-Thr-Fri-Sat”を$week_strに格納し，それをsplitで曜日ごとに区切って@week_arrayに格納し3番目の要素を表示しましょう．|
\end{description}

\section{ループ\index{るーぷ@ループ}}
\subsection{while\index{while}文}
\begin{description}
\item{解説} \verb|while文を使うと，( )で囲まれた条件が満たされている間，{ }で囲まれた箇所が何度も実行されます．|\\
\begin{waku}
\begin{verbatim}
$x = 1;
while($x < 5){
   print “Hello!\n”;
   print “Variable is now $x\n”;
   $x ++;
}
\end{verbatim}
\end{waku}
\item{問題\stepcounter{question}\thequestion (★★☆☆☆)} while文を使って以下のような出力をしてみましょう．\\
\begin{waku}
\begin{verbatim}
There are 2 sheep.
There are 4 sheep.
There are 6 sheep.
There are 8 sheep.
There are 10 sheep.
There are 12 sheep.
\end{verbatim}
\end{waku}
\item{問題\stepcounter{question}\thequestion (★★☆☆☆)} 1, 2, 4, 8, 16, …と2のべき乗を100000を超えるまで出力してみましょう．
\item{問題\stepcounter{question}\thequestion (★★☆☆☆)} while文を使って$3\times 5\times 7\times 9\times 11\times 13\times 15$を計算しましょう．
\end{description}

\subsection{for\index{for}文}
\begin{description}
\item{解説} \verb|for文を使うと，( )で囲まれた条件が満たされている間，{ }で囲まれた箇所が繰り返し実行されます．ただし( )の中身は以下の書式に従う必要があります．|\\
\item{書式} \verb|for( 初期化式; 条件式; 増分式){ 処理 }|\\
式は空白でもかまわないが小カッコの中にはセミコロンが必ず2つ含まれなければならない．また初期化式などを複数書きたい場合はカンマで区切る．\\
\begin{waku}
\begin{verbatim}
for( my($i, $j)=(0,0); $i<=10; $i++, $j = $i*$i ){
   print “$i\t$j\n”;
}
\end{verbatim}
\end{waku}\\
またこれは以下のループと同等です．\\
\begin{waku}
\begin{verbatim}
my($i, $j) = (0,0);
while($i<=10){
    my $j = $i*$i;
    print “$i\t$j\n”;
    $i++;
}
\end{verbatim}
\end{waku}
\item{問題\stepcounter{question}\thequestion (★☆☆☆☆)} $1,2,3,\ldots,99,100$の数字を降べきの順(100, 99, \ldots , 1)に出力しましょう．
\end{description}

\subsection{foreach\index{foreach}文}
\begin{description}
\item{解説} \verb|foreach文を使うと配列の要素を順番に取り出し処理することができます．|\\
\item{書式} \verb|foreach $変数( @配列){ 処理 }|\\
\verb|$変数は省略することが可能です．省略した場合，配列の要素は$_に代入されます．また@配列の代わりにリストを使用することも可能です．以下はリストを応用した例です．例文中の0..100は(0,1,2,...,99,100)というリストを表します．|\\
\begin{waku}
\begin{verbatim}
foreach my $i(0..100){
    my $j = $i*$i;
    print “$i\t$j\n”;
}
\end{verbatim}
\end{waku}
\item{問題\stepcounter{question}\thequestion (★★★☆☆)}1日が月曜日の4月のカレンダーを出力しましょう．\\
\begin{waku}
\begin{verbatim}
1	月
2	火
.	.
.	.
.	.	
\end{verbatim}
\end{waku}\\
もしくは\\
\begin{waku}
\begin{verbatim}
月 火 水 木 金 土 日
1 2 3 4 5 6 7 8 
9 ...
}
\end{verbatim}
\end{waku}\\
\verb|のどちらでもかまいません．最初の例の場合はあらかじめ月曜から日曜までの曜日のリスト(配列)を用意し，%演算子を使うと余りが計算できることを利用すると解決できます．例えば$R = 10%7 で$Rに3が代入されます．つまり4月10日は水曜日ということが分かります|\footnote{演算子については後ほど詳しく解説します．}．
\end{description}

\section{ハッシュ\index{はっしゅ@ハッシュ}\index{hash}}
\subsection{静的なハッシュ作成\index{せいてきなはっしゅさくせい@静的なハッシュ作成}}
\begin{description}
\item{解説} \verb|”%名前”でハッシュを扱うことができます．%hashでhashという名前のハッシュを扱うことができます．ハッシュは”辞書”のようなものです．以下のようにして”辞書”を作成し利用することが出来ます．”辞書”でいう見出しをキー(key)，説明を値(value)と呼びます．|\\
\begin{waku}
\begin{verbatim}
%nucleotide = (
    "a"   =>	"adenine",
    "t"   =>	"thymine",
    "c" =>	"cytosine",
    "g" =>	"guanine"
);
print "$nucleotide{c}\n";
\end{verbatim}
\end{waku}
\item{問題\stepcounter{question}\thequestion (★☆☆☆☆)} いくつかのアミノ酸の略称と正式名称を対応させたハッシュ\%aminoを作成しましょう．いくつかのアミノ酸について略称と正式名称を並べて出力しましょう．
\end{description}

\subsection{動的なハッシュ作成\index{どうてきなはっしゅさくせい@動的なハッシュ作成}}
\begin{description}
\item{解説} \verb|上の例文では静的に%nucleotideを作りましたが，さらに以下のような操作によってエントリーを追加することが出来ます．|\\
\begin{waku}
\begin{verbatim}
%nucleotide = (
    "a"   =>	"adenine",
    "t"   =>	"thymine",
    "c" =>	"cytosine",
    "g" =>	"guanine"
);
$nucleotide{u} = "uracil";
print “$nucleotide{u}\n”;
print “$nucleotide{a}\n”;
\end{verbatim}
\end{waku}
\item{問題\stepcounter{question}\thequestion (★☆☆☆☆)} \verb|上の問題で作った%aminoに後からエントリーを追加しましょう．|
\end{description}

\subsection{ハッシュのキーの取り出し(keys\index{keys}関数，values\index{values}関数)}
\begin{description}
\item{解説} \verb|keys関数を使うとハッシュのキーをリスト化することが出来ます．foreach文と組み合わせることでハッシュの中身を順番に処理することが出来ます．また似た関数にvaluesがあります．これはハッシュのvalueをリスト化します． |\\
\begin{waku}
\begin{verbatim}
%nucleotide = (
    "a"   =>	"adenine",
    "t"   =>	"thymine",
    "c" =>	"cytosine",
    "g" =>	"guanine"
);
foreach my $key(keys %nucleotide){
    print “$key\t$nucleotide{$key}\n”;
}
\end{verbatim}
\end{waku}
\item{問題\stepcounter{question}\thequestion (★☆☆☆☆)} \verb|%aminoに含まれるエントリーを全て出力しましょう．|
\end{description}

\subsection{ハッシュのキーの取り出し(each\index{each}関数)}
\begin{description}
\item{解説} \verb|each関数を使うとキーと値を一組ずつ取り出すことが出来ます．each関数はwhile文と組み合わせて使うことに注意．|\\
\begin{waku}
\begin{verbatim}
%nucleotide = (
    "a"   =>	"adenine",
    "t"   =>	"thymine",
    "c" =>	"cytosine",
    "g" =>	"guanine"
);
while(($key, $value) = each %nucleotide){
    print “$key\t$value\n”;
}
\end{verbatim}
\end{waku}
\item{問題\stepcounter{question}\thequestion (★☆☆☆☆)} \verb|さきのkeys関数を使ったプログラムをeach関数を使ったプログラムに書き換えましょう|
\end{description}

\subsection{ハッシュを用いたカウント\index{かうんと@カウント}}
\begin{description}
\item{解説} \verb|ハッシュを用いると各要素の数を効率的にカウントすることが出来ます．対象とする要素数が多い場合，あるいは未知の場合有効です． |\\
\begin{waku}
\begin{verbatim}
my $seq = ‘aacgtgatgtcgtagtacgatgc’;
my %count;
$count{$_}++ for split ‘’, $seq;
for(keys %count){
    print “$_\t$count{$_}\n”;
}
\end{verbatim}
\end{waku}
\item{問題\stepcounter{question}\thequestion (★★☆☆☆)} \verb|上の例文を実行し，アルゴリズムを理解しましょう|
\end{description}

\section{ファイルの読み込み\index{ふぁいるのよみこみ@ファイルの読み込み}}
\begin{description}
\item{解説} \verb|openでファイルをオープンした後，while(<FILE>)でファイルを一行ずつ全部読み込むことができます．読み込んだ行は$_に格納されます．|\\
\begin{waku}
\begin{verbatim}
open(FILE, “nucleotide.txt”);
while(<FILE>){
   print $_;
}
close FILE;
\end{verbatim}
\end{waku}
\item{問題\stepcounter{question}\thequestion (★☆☆☆☆)} nucleotide.txtの最後の一行を表示するプログラムを書きましょう．

\item{解説} chompを使用すると，行末の改行を取り除くことができます．\\
\begin{waku}
\begin{verbatim}
open(FILE, “nucleotide.txt”);
while(<FILE>){
   chomp;
   print $_;
   print “\n”; # 行末の改行が取り除かれているので，ここで改行を行わなければ 
   # ならない．
}
close FILE;
\end{verbatim}
\end{waku}
\item{問題\stepcounter{question}\thequestion (★☆☆☆☆)} nucleotide.txtの各行をコンマでつなげて表示するプログラムを書きましょう．
\item{出力結果}\\
\begin{waku}
\begin{verbatim}
adenine,thymine,cytosine,guanine
\end{verbatim}
\end{waku}
\item{問題\stepcounter{question}\thequestion (★☆☆☆☆)} 以下の文章をnucleotide2.txtとして作成し，一行目と二行目を入れ替えるプログラムを書きましょう．各行の区切り文字はタブとします．
\item{fruit.txt} \\
\begin{waku}
\begin{verbatim}
a    adenine
t    thymine
c    cytosine
g    guanine
\end{verbatim}
\end{waku}
\item{出力結果}\\
\begin{waku}
\begin{verbatim}
adenine    a
thymine    t
cytosine   c
guanine    g
\end{verbatim}
\end{waku}

\item{問題\stepcounter{question}\thequestion (★★★☆☆)} さらにopendir\index{opendir}とreaddir\index{readdir}を使うことでディレクトリに含まれるファイルをすべて処理することができます．今いるディレクトリを開き，含まれるファイルをすべて表示するようなプログラムを作成しましょう．
\end{description}

\section{演算子\index{えんざんし@演算子}}
\subsection{算術演算子\index{さんじゅつえんざんし@算術演算子}}
\begin{description}
\item{解説} \verb|perlには加減乗除等の算術演算子がいくつか用意されています．基本的な演算子は一通り理解しておきましょう．同時に”+＝”といった短縮表現及び++の意味も確認しましょう|\footnote{++はオートインクリメントという演算子で変数の値を一つ増やす作用をします．同様に--はオートディクリメントといわれ，変数の値を一つ減らします．}．

\begin{table}[h]
\begin{center}
\caption{算術・論理演算子\index{ろんりえんざんし@論理演算子}}
\begin{tabular}{lll}\hline
演算子&意味&書式\\ \hline
$a+b$&足し算&$a+b$\\ %\hline
$a-b$&引き算&$a-b$\\ %\hline
$a\times b$&かけ算&$a*b$\\ %\hline
$a / b$&割り算&$a/b$\\ %\hline
$a \div b$の余&剰余&$a\% b$\\ %\hline
$a^b$&累乗&$a**b$\\ %\hline
$a\cap b$&論理積(かつ)&$a\&\&b$\\ %\hline
$a\cup b$&論理和(または)&$a||b$\\ %\hline
$\neg a$&否定&$! a$ \\ \hline
\end{tabular}
\end{center}
\end{table}

\item{書式} 演算と代入：\verb|$hoge = $foo + $bar;|\\
短絡表現：\verb|$hoge += $foo; #($hoge = $hoge+$foo と同じ)|\\
オートインクリメント：\verb|$hoge ++;|\index{おーといんくりめんと@オートインクリメント}\\
\begin{waku}
\begin{verbatim}
$add    = 5+3;	print $add,	“\n”;
$take   = 5-3;	print $take,	“\n”;
$time   = 5*3;	print $time,	“\n”;
$divid  = 5/3;	print $divid,	“\n”;
$add   += 2;		print $add,	“\n”;
$take  -= 2;		print $take,	“\n”;
$times *= 2;		print $times,	“\n”;
$divid /= 2;		print $divid,	“\n”;
\end{verbatim}
\end{waku}
\item{問題\stepcounter{question}\thequestion (★☆☆☆☆)} 0,1,2,\ldots,10の整数をランダムに100回出力しましょう．ただし以下の条件を満たしたプログラムにしてください．\\
 a) 0の場合，ZEROという文字列に置き換えて出力してください\\
 b) 条件分岐は使わずに演算子を用いましょう
\item{ヒント1} \verb|0~10の間のランダムな整数を得たい場合，$number = int(rand(10));\index{rand}とすると良いでしょう．|
\item{ヒント2} \verb+$hoge = $foo || $bar; とすると，$fooの値が0だった場合，$barが$hogeに代入されます．一方$fooの値が0以外であった場合は$fooが$hogeに代入されます．+
\end{description}

\subsection{文字列演算子\index{もじれつえんざんし@文字列演算子}}
\begin{description}
\item{解説} \verb|数値演算子と同様に文字列を操作する演算子もいくつか用意されています．特に文字列結合演算子(．ドット)はマスターしておきましょう．|\\

\begin{table}[h]
\begin{center}
\caption{文字列演算子}
\begin{tabular}{ll}\hline
意味&書式\\ \hline
文字列をつなげる&a . b\\ %\hline
文字列を繰り返す&a x 3\\ \hline
\end{tabular}
\end{center}
\end{table}

\begin{waku}
\begin{verbatim}
$seq	 = ‘hoge’.”\n”;	print $seq;
$seq	 = ‘hoge’ x 3;	print $seq;
$seq	.= ”\n”;		print $seq;
$seq	x= 3;			print $seq;
\end{verbatim}
\end{waku}
\item{問題\stepcounter{question}\thequestion (★☆☆☆☆)} aからzまで順につなげた26文字の文字列を作りましょう．そしてそれを10回繰り返した260文字の文字列を出力しましょう．
\end{description}

\subsection{比較演算子\index{ひかくえんざんし@比較演算子}}
\begin{description}
\item{解説} \verb|数学における等号/不等号と同様に数値を比較し，その結果を返す比較演算子が用意されています．以下の例文を実行し演算子の働きを確かめましょう．|

\begin{table}[h]
\begin{center}
\caption{比較演算子}
\begin{tabular}{lll}\hline
数式&意味&書式\\ \hline
\multicolumn{3}{c}{数値比較}\\ \hline
$a = b$&等しい&a==b\\ %\hline
$a\neq b$&等しくない&a!=b\\ %\hline
$a<b$&小さい&$a<b$\\ %\hline
$a>b$&大きい&$a>b$\\ %\hline
$a\leq b$&以下&$a<=b$\\ %\hline
$a\geq b$&以上&$a>=b$\\ %\hline
&比較&$a <=> b$\\ \hline
\multicolumn{3}{c}{文字列比較}\\ \hline
&同一文字列&a eq b\\ %\hline
&同一文字列ではない&a ne b\\ %\hline
&文字列の比較&a cmp b\\ \hline
\end{tabular}
\end{center}
\end{table}

\item{注意} ・ $==$と$=$の違いに気をつける\\
 \ ・ $=>$と$->$は比較演算子ではない．$>=$との書き間違えに注意\\
 \ ・ 数値比較演算子と文字列比較演算子の違いに注意．eqと==を混合しないように\\
\begin{waku}
\begin{verbatim}
$judge	 = (5==3);		print $judge;
$judge	 = (‘b’ eq ‘b’);	print $judge;
$judge	 = (15<=>5);		print $judge;
$judge	 = (‘aa’ cmp ‘bb’);	print $judge;
\end{verbatim}
\end{waku}
\item{問題\stepcounter{question}\thequestion (★☆☆☆☆)} \verb|$firstと$secondにランダムに数を代入しましょう．そして二つの数字を比較した結果と共に出力してください．|
\end{description}

\section{条件分岐\index{じょうけんぶんき@条件分岐}}
\subsection{if\index{if}/elsif\index{elsif}/else\index{else}}
\begin{description}
\item{解説} \verb|”アルゴリズム”とはある問題を解決する手順のことですが，以下の三つの要素でほぼどのようなアルゴリズムも実装可能です\footnote{興味のある人はダイクストラの構造化定理についてしらべみましょう}．if/elsif/elseという三段階の条件分岐を正確に使いこなすことがうまいPerl使いへの近道となります．|
\begin{description}
\item{1)} 手続きA→B→Cと順番に式を実行していく
\item{2)} ループA→B→C→A→B→C→\ldots とある条件のもと式の塊をくりかえす
\item{3)} 条件分岐Aの結果が真なら次にB，偽ならCを行う
\end{description}
\begin{waku}
\begin{verbatim}
my $seq = ‘acgtagtcgtgtga’;
my $length = length $seq;
my $ans;
if($length >= 20){
    $ans = ‘long’;
}
elsif($length <= 5){
    $ans = ‘short’;
}
else{
    $ans = ‘middle’;
}
print “The sequence is $ans\n”;
\end{verbatim}
\end{waku}
\item{問題\stepcounter{question}\thequestion (★☆☆☆☆)} 閏年を判定するプログラムを作りましょう
\end{description}

\subsection{last\index{last}, next\index{next}, redo\index{redo}}
\begin{description}
\item{解説} \verb|ループを途中で強制的にスキップする，もしくは抜け出したいときがあります．これを実現する関数が三つほど用意されています．違いをよく確認しておきましょう|
\begin{description}
\item{last} 直ちにループを抜け出す
\item{next} 直ちに次のループに入り，next以降のブロック要素は無視され
る．
\item{redo} nextと同じく次のループに入る．ただし条件式はスルーされる．
\end{description}
次の例はredoを使った有名な文例です．あるファイルの文中，\verb|\(バックスラッシュ)|で終わる行を次の行と連結して表示します．\\
\begin{waku}
\begin{verbatim}
while(<FILE>){
    if(/\\\n/){
            chomp;
            s/\\//g;
            $next = <FILE>;
            $_   .=  $next;
            redo;
        }
        print;
}
\end{verbatim}
\end{waku}
\item{問題\stepcounter{question}\thequestion (★☆☆☆☆)} 上の例を実際に実行しredoの代わりにnextやlastを使えない理由を考えましょう．
\end{description}

\subsection{三項演算子\index{さんこうえんざんし@三項演算子}}
\begin{description}
\item{解説} \verb|Aが真ならばB，偽ならばCという文を簡潔に表現することが出来ます．|\\
\begin{waku}
\begin{verbatim}
my($foo, $bar) = (20, 30);
$foo = ($foo >= $bar)? $foo: $bar;
print $foo;
\end{verbatim}
\end{waku}
\item{問題\stepcounter{question}\thequestion (★☆☆☆☆)} 先ほど作った閏年判定プログラムを三項演算子を用いて書き換えましょう．
\end{description}

\section{正規表現\index{せいきひょうげん@正規表現}}
\subsection{マッチ演算子\index{まっちえんざんし@マッチ演算子}}
\begin{description}
\item{解説} \verb|ある文字列があり，あるキーワードでマッチさせたいとき正規表現を用います．|
\item{書式} \verb|$sequence =~ /pattern/;|\\
\verb|=~は二文字でひとつの演算子です．=と~の間に空白はあけてはいけません．またpatternは”/”二つで囲みます．さらにpatternは変数を含むことが出来ます．この場合変数は展開された後，patternとして参照されます．|\\
\begin{waku}
\begin{verbatim}
my $seq   = ‘aucugcugccaugguguagc’;
my $kozak = ‘gccaugg’;
if($seq =~ /$kozak/){
    print “Kozak\n”;
}
else{
    print “Non kozak\n”;
}
\end{verbatim}
\end{waku}
\item{問題\stepcounter{question}\thequestion (★☆☆☆☆)} ランダムな塩基配列を作り，その中にatgと(tag/tga/taa)という二つのパターンが同時に存在するか調べ，結果を出力しましょう．
\end{description}

\subsection{メタキャラクタ\index{めたきゃらくた@メタキャラクタ}，ワイルドカード\index{わいるどかーど@ワイルドカード}，後方参照\index{こうほうさんしょう@後方参照}}
\begin{description}
\item{解説} Perlはあいまい検索\index{あいまいけんさく@あいまい検索}を行うことが出来ます．よく用いる正規表現(メタキャラクタ)はリファレンスにまとめましたので参考にしてください．
\begin{verbatim}
．(ドット)などメタキャラクタとなる文字は正規表現内では文字列としては認識されないため，文字列としての．(ドット)とマッチさせたいときは\．のように\(バックスラッシュ)でエスケープさせる必要があります．さらに小カッコで囲うとその内容は$1,$2,$3…と\1,\2,\3…に入ります．正規表現の外では$を，正規表現内では\1を使います．また，複数の小カッコがあるとき，囲われた内容の入る変数は開きカッコの順番で決まります．
\end{verbatim}
\begin{waku}
\begin{verbatim}
my $haiku = ‘Tabiniyande YumehaKarenowo Kakemeguru’;
my $data = ‘Hideki’s uniform number is 55.’;
my $html = ‘<p>hoge <I>hogehoge</I> hoge</p> ’

if($haiku =~ /^(\S+)\s+(\S+)\s+(\S+)$/){
    print “$1\n”;
    print “$2\n”;
    print “$3\n”;
}
if($data =~ /(\d+)/){
    print “$1\n”;
}
if($html =~ /^<([^>]+)>(.*?)<\/\1>/){
    print “$2\n”;
}
if($haiku =~ /\b(\S+[aiu])\b/;){
    print “$1\n”;
}
\end{verbatim}
\end{waku}
\item{問題\stepcounter{question}\thequestion (★☆☆☆☆)}  300塩基長のランダムな塩基配列を作り，atgの前後6塩基ずつを全て表示してください．
\item{ヒント} while(/ pattern /g){ 処理 }でマッチの結果を順に見ることが出来ます．
\end{description}

\subsection{量指定子\index{りょうしていし@量指定子}}
\begin{description}
\item{解説} \verb|文字の連続に関して指定が出来ます．|\\
\begin{waku}
\begin{verbatim}
my $mRNA = ‘atgtgctgatcgtagctgaaaaaaaaa’;
if($mRNA =~ /^([a-z]+)a{5,}$/){
         print “$1\n”;
}
else{
         print “$mRNA\n”;
}
\end{verbatim}
\end{waku}
\item{問題\stepcounter{question}\thequestion (★☆☆☆☆)} 300塩基長のランダムな塩基配列を作り，cかgのみからなる10bp以上の長さの領域があるかどうかを判定しましょう．
\end{description}

\section{関数\index{かんすう@関数}}
\subsection{組み込み関数\index{くみこみかんすう@組み込み関数}}
\begin{description}
\item{解説} \verb|print，split等すでにいくつ使ってきましたが，perlにはたくさんの関数が用意されています．最初は以下にあげたものを知っていれば十分です．このうちいくつかは後のセクションで扱います．|\\
\begin{waku}
\begin{verbatim}
出力：        print, printf
算術計算：    log, sqrt, sin/cos, exp, abs, int, rand
文字列操作：  length, reverse, index/rindex, substr, lc/uc, chomp
             split/join, s///g, tr///, sprintf
配列操作：    shift, unshift, pop, push, sort, reverse, map, grep, splice
ハッシュ操作： keys/values, each, exists/defined, delete
制御：        last, next, redo, exit, die, return
宣言：        my, sub
システム:     open/close, opendir/readdir, select, system, package, use
\end{verbatim}
\end{waku}
\item{問題\stepcounter{question}\thequestion (★☆☆☆☆)} 上にあげた関数の機能を調べましょう．
\end{description}

\subsection{ユーザ関数\index{ゆーざかんすう@ユーザ関数}}
\begin{description}
\item{解説} \verb|組み込み関数と同様な関数をユーザが作ることが出来ます．|\\
\verb|sub 関数名{ 処理 }|\\
\verb|とすることで関数を宣言します．使うときは|\\
\verb|&関数名(引数1，引数2，・・・)|\\
\verb|です．&と小カッコは条件によって省略できます|\\

以下の例は相補鎖を求める関数です\\
\begin{waku}
\begin{verbatim}
sub complement{
    my $seq = shift;
    $seq =~ tr/atcgATCG/tagcTAGC/;
    $seq = reverse $seq;
    return $seq;
}

my $seq = ‘ttaactgatgctgtcgatctagctcat’;
print &complement($seq), “\n”;
\end{verbatim}
\end{waku}
\item{問題\stepcounter{question}\thequestion (★☆☆☆☆)} \\
a) reverse関数を自分で実装しましょう．\\
b) 塩基を含む配列を与えるとエントロピーを計算する関数を実装しましょう
\item{ヒント} reverse関数はループ及び配列の引数をうまく用いて作ると良いでし
ょうエントロピー$H$は$P_{i}$を塩基$i$の出現頻度をしたとき
\[H=-\sum_{n=a,t,c,g}P(n)\log_{2}P(n)\]
で定義されます．ただしここでは$0\log 0 := 0$とします
\end{description}

\section{リファレンス\index{りふぁれんす@リファレンス}}
\subsection{明示的なリファレンス作成}
\begin{description}
\item{解説} \verb|リファレンスは変数の住所のようなものです．値自体ではなく名前のみをやり取りすることでメモリーの節約やプログラムの効率の向上に寄与します．また関数に配列や複数の変数を渡すケース，あるいは多元配列/ハッシュの実装に用いられます．|\\
\begin{waku}
\begin{verbatim}
my $seq = ‘atgctgtagctgtgatgctgatgcg’;
my $seq_ref = \$seq;
my @array = (‘a’, ‘b’, ‘c’, ‘d’, ‘e’, ‘f’);
my $array_ref1 = \@array;
my %hash = (‘a’, 1, ‘b’, 2, ‘c’, 3);
my $hash_ref = \%hash;
sub hello{print “Hello $_[0]\n”}
my sub_ref = \&hello;

print $$seq_ref, “\n”; 
print $array_ref->[1], “\n”;
print $hash_ref->{a}, “\n”;
print $sub_ref->(‘john’), “\n”;
\end{verbatim}
\end{waku}
\item{問題\stepcounter{question}\thequestion (★☆☆☆☆)} 先ほど作ったreverse関数を参照渡しに変更しましょう
\end{description}

\subsection{無名配列\index{むめいはいれつ@無名配列}}
\begin{description}
\item{解説} \verb|上では\を用いてリファレンスを明示的に作成しましたが，[ ]もしくは{ }を用いてより直接的にリファレンスを作成することが出来ます．これらを無名配列/ハッシュ/関数といいます．|\\
\begin{waku}
\begin{verbatim}
@array = (‘a’, ‘b’, ‘c’, ‘d’, ‘e’, ‘f’);
$array_ref1 = [@array];
$array_ref2 = [‘a’, ‘b’, ‘c’, ‘d’, ‘e’, ‘f’];
$hash_ref = {‘a’, 1, ‘b’, 2, ‘c’, 3};
$sub_ref = sub{print “Hello $_[0]”};

print $array[1], “\n”;
print $array_ref1->[1], “\n”;
print $array_ref2->[1], “\n”;
print $hash_ref->{a}, “\n”;
print $sub_ref->(‘john’), “\n”;
\end{verbatim}
\end{waku}
\item{問題\stepcounter{question}\thequestion (★☆☆☆☆)} 各自配列を作り，さらにそのリファレンスを作ってください．ただしリファレンス演算子\index{りふぁれんすえんざんし@リファレンス演算子}を用いた方法，無名配列を用いた方法の二通りを行ってください．そのあと元の配列を変え，リファレンスの中身を見てみましょう．
\end{description}

\subsection{多元配列\index{たげんはいれつ@多元配列}，行列\index{ぎょうれつ@行列}}
\begin{description}
\item{解説} \verb|リファレンスを用いて多元配列を作成することが出来ます．|\\
\begin{waku}
\begin{verbatim}
@array = ([1, 2, 3], [4, 5, 6], [7, 8, 9]);
$array_ref = [[1, 2, 3], [4, 5, 6], [7, 8, 9]];

print $array[1][1], “\n”;
print $array_ref->[1][1], “\n”;
\end{verbatim}
\end{waku}
\end{description}

\subsection{多元ハッシュ\index{たげんはっしゅ@多元ハッシュ}，構造体\index{こうぞうたい@構造体}}
\begin{description}
\item{解説} 多元配列と同様に多元ハッシュも作成することが出来ます．さらにスカラー変数，配列，関数等を要素に含む構造体likeなデータ構造も実現できます．\\
\begin{waku}
\begin{verbatim}
%hash = (
    a => {1, 3, 2, 2},
    t => {1, 5, 2, 5},
    c => {1, 3, 2, 1},
    g => {1, 4}
)
$hash{g}{2} = 1;

print $hash{g}{2}, “\n”;
\end{verbatim}
\end{waku}
\item{問題\stepcounter{question}\thequestion (★☆☆☆☆)} スカラー変数，配列，ハッシュ，関数への各リファレンスを含む多元ハッシュを構築しましょう．そしてそれぞれ出力し動作を確認しましょう．
\end{description}

\section{文字列操作\index{もじれつそうさ@文字列操作}}
\subsection{部分文字列の操作}
\begin{description}
\item{解説} substr\index{substr}を使うと文字列の操作を行うことが出来ます．\\
\begin{waku}
\begin{verbatim}
my $seq = ‘abcdefg’;
my $part1 = substr($seq, 2, 2);
my $part2 = substr($seq, -2, 2);
print $seq, “\n” ;
print $part1, “\n”;
print $part2, “\n”;

substr($seq, 0, 2) = ‘xy’;
substr($seq, 0, 2, ‘pq’);

print $seq;
\end{verbatim}
\end{waku}
\item{問題\stepcounter{question}\thequestion (★☆☆☆☆)} 300文字のランダム塩基配列を作りましょう．そしてコドンごとに頻度をカウントし，数の多い順に表示してください．
\end{description}

\subsection{パターンの検索\index{ぱたーんけんさく@パターン検索}}
\begin{description}
\item{解説} m//\index{m}，index\index{index}，rindexはパターンを検索する関数です．m//は実は正規表現で出てきた\verb|”=~ /pattern/”|のダブルスラッシュのことです．このようにmは省略できますが，あえてつけた場合\verb|”=~ m#pattern#”|のようにパターンをスラッシュ以外の記号で囲うことが出来ます．index/rindexは文字列から最左(右)のパターンマッチの位置を返す関数でパターンマッチに失敗したときは-1を返します．\\
\begin{waku}
\begin{verbatim}
$seq = ‘actgacgatgatgtgcatgc’;
($forward, $behind) = /([atcg]{6})atg([atcg]{6})/ for $seq;
$l_pos = index($seq, ‘atg’, 0);
$r_pos = rindex($seq, ‘atg’);

print “$forward\t$behind\n”;
print “$l_pos\t$r_pos\n”;
\end{verbatim}
\end{waku}
\item{問題\stepcounter{question}\thequestion (★☆☆☆☆)} index/rindexは最左，もしくは最右の要素しか見つけることが出来ませんが，それだと目的にそぐわない場合があります．そこでパターンの見つかった場所全てを返すwindex関数を実装してみましょう．ループとうまく組み合わせるとよいでしょう．
\end{description}

\subsection{置換\index{ちかん@置換}}
\begin{description}
\item{解説} \verb|s//，tr///はそれぞれ文字列の置換を行う関数です．|\\
\begin{waku}
\begin{verbatim}
#$seqから塩基以外の文字をのぞく
$seq =~ s/[^a-z]//g;

#カウント(二つの式は同じ意味)
$count = $seq =~ tr/gcGC/gcGC/;
$count = tr/gcGC/gcGC/ for $seq;
\end{verbatim}
\end{waku}
\item{問題\stepcounter{question}\thequestion (★☆☆☆☆)} 置換演算子を用いて塩基配列中におけるGCの数をカウントしましょう．
\end{description}

\section{配列操作\index{はいれつそうさ@配列操作}}
\subsection{末端要素の操作}
\begin{description}
\item{解説} \verb|配列の末端要素を操作する関数は4つ用意されています．|
\begin{description}
\item{shift}	先頭要素をひとつ削除\index{shift}
\item{pop}	末尾要素をひとつ削除\index{pop}
\item{unshift} 先頭に要素を追加\index{unshift}
\item{push} 末尾に要素を追加\index{push}
\end{description}
\begin{waku}
\begin{verbatim}
my @test1 = (‘a’, ‘b’, ‘c’);
my @test2 = (‘d’, ‘e’, ‘f’);
my $shift = shift @test1;
my $pop = pop @test1;
unshift( @test2, ‘c’ )
push( @test2, ‘g’ );

print “$shift\n”;
print “$pop\n”
print “@test1\n”;
print “@test2\n”;
\end{verbatim}
\end{waku}
\item{問題\stepcounter{question}\thequestion (★☆☆☆☆)} これらの関数を用いて配列の最初と最後の要素を入れ替えましょう．
\end{description}

\subsection{要素の置換\index{はいれつようそのちかん@配列要素の置換}}
\begin{description}
\item{解説} \verb|substrは文字列の操作を行う関数ですが，同様に配列の操作を行う関数にsplice\index{splice}があります．書式はほぼsubstrと同じです．|\\
\begin{waku}
\begin{verbatim}
my @test = (‘a’, ‘b’, ‘c’, ‘d’, ‘e’, ‘f’, ‘g’);
my @test2 = splice(@test, 3, 2);
splice(@test, 1, 2, (‘a’, ‘b’));

print “@test\n”;
print “@test2\n”;
\end{verbatim}
\end{waku}
\item{問題\stepcounter{question}\thequestion (★☆☆☆☆)} spliceを使ってshift，unshift，push，popと同じ動作をする関数を作ってみましょう．
\end{description}

\subsection{スライス\index{すらいす@スライス}}
\begin{description}
\item{解説} \verb|配列の要素をひとつとってくるときは$array[0]としますが，スライスを用いると同時に複数の要素を取ることが出来ます．|\\
\item{書式} \verb|($first, $second) = @array[0,1];|\\
\verb|$の代わりに@を使います．ハッシュも同様にスライスを適用可能です|\\
\begin{waku}
\begin{verbatim}
my $seq = ‘abcdef’;
my @array = (‘a’, ‘b’, ‘c’, ‘d’, ‘e’, ‘f’);
my %hash = (‘a’, 1, ‘b’, 2, ‘c’, 3);
my @chr = ( split(‘’, $seq) )[0,1,2];
my @num = @hash{@array[2,1]};

print “@chr\n”;
print “@num\n”;
\end{verbatim}
\end{waku}
\item{問題\stepcounter{question}\thequestion (★☆☆☆☆)} 配列を作成し，スライスを用いて要素の交換を行いましょう．
\end{description}

\subsection{負の引数\index{ふのひきすう@負の引数}}
\begin{description}
\item{解説} \verb|配列の最後の要素へは最後の要素の添え字を表す$#配列名を利用し|
\begin{verbatim}
$hoge[$#hoge]
でアクセスすることが出来ますが，負の引数を用いて
$hoge[-1]
でもアクセスできます．同様に最後からn番目の要素は
$hoge[-n]
です．
\end{verbatim}
\begin{waku}
\begin{verbatim}
@array = (‘a’, ‘b’, ‘c’, ‘d’, ‘e’, ‘f’);
print $#array, “\n”;
print $array[$#array], “\n”;
print $array[-1], “\n”;
\end{verbatim}
\end{waku}
\item{問題\stepcounter{question}\thequestion (★☆☆☆☆)} スライスを用いて最初と最後の要素を入れ替えましょう．
\end{description}

\subsection{ソート\index{そーと@ソート}}
\begin{description}
\item{解説} ソートを行うsort\index{sort}関数はデフォルトでは辞書順に従った並べかえを行いますが，正確に数値の大きさ順にそろえる，複雑な並べ替えを行いたいといった場合，並べ替え方を指定することも出来ます\footnote{デフォルトのままだと例えば12,3,23をソートした場合12, 23, 3と並べてしまいます．}．以下は塩基の長さについてまず綴りの短い順に並べ，同じ長さの名前に関してはアルファベット順に並べています．\\
\begin{waku}
\begin{verbatim}
my @nuc = (‘adenine’, ‘guanine’, ‘thymine’, ‘cytosine’, 'uracil');
my @sorted = sort{
    length $a <=> length $b ||
    $a cmp $b	
}@nuc;
\end{verbatim}
\end{waku}
\item{問題\stepcounter{question}\thequestion (★☆☆☆☆)} \\
\verb|@number = (1, 5, 30, 22, 3, 9);|\\を作成し以下の二つのソートの動作比較をしましょう\\
\verb|sort @number|\\
\verb|sotr{$a <=> $b}@number|
\end{description}

\subsection{配列の編集}
\begin{description}
\item{解説} map\index{map}とgrep\index{grep}は配列の編集に威力を発揮する関数です．以下に基本的な使用例をあげますが，是非sortと共に使いこなせるようにしておきましょう．\\
\begin{waku}
\begin{verbatim}
my @even = map{$_*2}0..50;
my @quadric = map{[$_, $_**2]}0..20;
my @lion_king = grep{/lion king/i}@musical;

#以下は@dataのデータを%other_dataに記述されたデータにしたがってソートする効率の良い方法”Schwartz変換”です．
my data_sorted =
map{$_->[0]}
sort{$a->[1] <=> $b->[1]}
map{[$_, $other_data{$_}]}@data;
\end{verbatim}
\end{waku}
\item{問題\stepcounter{question}\thequestion (★☆☆☆☆)} 要素のダブリを含む配列からダブリを除くようなプログラムを作成しましょう．ただしgrepを用いた方法とハッシュを用いた方法の2通りを考えてください．
\item{問題\stepcounter{question}\thequestion (★☆☆☆☆)} 実際にSchwartz変換\index{シューウォーツへんかん@Schwartz変換}を使ってみましょう
\end{description}

\section{外部入出力，制御\index{がいぶにゅうしゅつりょく@外部入出力}}
\subsection{ファイルへの書き出し\index{ふぁいるへのかきだし@ファイルへの書き出し}}
\begin{description}
\item{解説} \verb|読み込み用にファイルを開く場合は|
\begin{verbatim}open FILE, hoge.txt;
としました．同様に書き出し用のファイルを開くことも出来ます．
open FILE, “>output.txt”;
これでoutput.txtというファイルが新たに生成され，データを書き込むことが出来ます．ただし，>では既存のファイルを上書きしてしまうためそれを避けるために>>を用いることもあります．>は無条件に新規ファイルの生成を行いますが，>>は同名のファイルがなかった場合は新規作成，あった場合は末尾にデータを追加します．
\end{verbatim}
\begin{waku}
\begin{verbatim}
open FILE, “>output.txt” or die;
print “one\n”;
print FILE “two\n”;
select FILE;
print “three\n”;
select STDOUT;
print “four\n”;
\end{verbatim}
\end{waku}
\item{問題\stepcounter{question}\thequestion (★☆☆☆☆)} 上のコードを実行し，動作を確認しましょう．
\end{description}

\subsection{@ARGV\index{"@ ARGV}}
\begin{description}
\item{解説} スクリプトへの引数は@ARGV(ARGument Vector)に収められています．\\
コマンドライン上\\
\begin{waku}
\begin{verbatim}
% view_one_line.pl nucleotide.txt 5
\end{verbatim}
\end{waku}\\
スクリプト\\
\begin{waku}
\begin{verbatim}
#!/usr/bin/perl

open FILE, $ARGV[0] or die”Can’t open $ARGV[0]:$!”;
my @line = <FILE>;
print “$line[$ARGV[1]-1]\n”;
\end{verbatim}
\end{waku}
\item{問題\stepcounter{question}\thequestion (★☆☆☆☆)} 複数の数値を引数として受け取り，平均を出力するスクリプトを作成しましょう．
\end{description}

\subsection{外部コマンドの使用\index{がいぶこまんどのしよう@外部コマンドの使用}}
\begin{description}
\item{解説} 外部コマンドを使用する場合，system\index{system}関数を使う，あるいはバッククォーテオションを使うという二通りの方法があります．\\
\begin{waku}
\begin{verbatim}
system(“ls -l”);
my @who = `who`;
for(@who){
    my @line = split;
    print “$line[0]\t$line[4]\n”;
}
\end{verbatim}
\end{waku}
\item{問題\stepcounter{question}\thequestion (★☆☆☆☆)} lastコマンドの出力を受け取り，PCへのアクセス回数を表示させましょう．
\end{description}

\section{囲い文字\index{かこいもじ@囲い文字}}
\subsection{クォーテーション\index{くぉーてーしょん@クォーテーション}}
\begin{description}
\item{解説} クォーテーションは三種類あります．
\begin{description}
\item{“/qq} （ダブルクォーテーション）\index{だぶるくぉーてーしょん@ダブルクォーテーション}\\
文字列．変数/エスケープ文字が含まれていた場合，解釈される．\\
\verb|“$hoge\n”	← $hogeの中身が展開され，改行が付加される|\\
\verb|qq#$hoge\n#	← 上に同じ．囲い文字は自由．|\\
\item{‘/q} （シングルクォーテーション）\index{しんぐるくぉーてーしょん@シングルクォーテーション}\\
文字列．ただし変数は展開せず”そのまま”に解釈される．\\
\verb|‘$hoge\n’ ← $hoge\nという文字列|\\
\verb|q#$hoge\n# ← 上に同じ|\\
\item{`/qx} （バッククォーテーション）\index{ばっくくぉーてーしょん@バッククォーテーション}\\
中にコマンドを書く．するとコマンドは実行され，結果が返される．\\
\verb|$who =`who`; ← whoというコマンドの実行結果が$whoに入る|\\
\verb|$who =qx#who# ← 上に同じ|\\
\item{qw} 
空白区切りでリストを作る．カンマ・囲いは不要．\\
\verb|@chr = qw(a b c d e f g);|\\
\end{description}
\begin{waku}
\begin{verbatim}
my $foo = ’bar’;
my @continent = qw(Africa Antarctica Australia Eurasia
 North_America South_America);

print ‘$foo\n’;
print “$foo\n”;
print `who`;
print “$continent[1]\n”;
\end{verbatim}
\end{waku}
\item{問題\stepcounter{question}\thequestion (★☆☆☆☆)} コマンドラインからファイル名を受け取り，.txtという拡張子をつけて適当に文字列を書き込みましょう．
\item{問題\stepcounter{question}\thequestion (★☆☆☆☆)} lynxと組み合わせて簡単なweblobotを作成しましょう．例えばGenbankからファイルをダウンロードし，アノテーションを抽出するようなweblobotを作成しましょう．
\end{description}

\subsection{$[\ ]$}
\begin{description}
\item{解説} \verb|[ ]は文脈によって以下のようなことなる意味を持ちます．|
\begin{description}
\item{配列の添え字}	\verb|$array[2]|
\item{スライスの添え字} \verb|@slice[3..5]|
\item{リファレンスの添え字} \verb|$array_ref->[6] or $$array_ref[6]|
\item{無名配列}	\verb|[1, 1, 2, 3, 5, 8, 13, 21]|
\end{description}
\begin{waku}
\begin{verbatim}
my $foo = ’a’;
my $bar = ’b’;

$ref1 = [$foo, $bar];
@ref2 = \($for, $bar);
\end{verbatim}
\end{waku}
\item{問題\stepcounter{question}\thequestion (★☆☆☆☆)} \verb|例文で出来てきた$ref1と@ref2の違いを理解しましょう．|
\end{description}

\subsection{$\{ \}$}
\begin{description}
\item{解説} \verb|{ }も文脈によって異なる意味を持ちます|
\begin{description}
\item{ハッシュの添え字} \verb|$hash{$key}|
\item{スライスの添え字} \verb|@hash{$key1, $key2}|
\item{リファレンスの添え字} \verb|$hash_ref->{$key} or $$hash_ref->{$key}|
\item{無名ハッシュ}	\verb|{1, ‘a’, 2, ‘b’, 3, ‘c’}|
\item{ループ} \verb|foreach(配列){処理}|
\item{ブロック}	\verb|do{処理}while(条件);|
\end{description}
特にdo{}while();文では最後のセミコロンを忘れないようにしてください．\\
\begin{waku}
\begin{verbatim}
my $hoge = ‘foo’;
{
    my $hoge = ‘bar’;
    print “$hoge\n”;
}
print ”$hoge\n”;
\end{verbatim}
\end{waku}
\item{問題\stepcounter{question}\thequestion (★☆☆☆☆)} 引数を保持し，再び与えられた引数が元の引数と合致するか判定するクロージャを実装しましょう．
\end{description}

\subsection{( )}
\begin{description}
\item{解説} \verb|( )に関しては特にリスト・配列・無名配列の違いを理解すること，正規表現に関するグループ化と後方参照を理解することが重要です．|\\
\begin{waku}
\begin{verbatim}
my $chr = ‘5a3b1’;
my @array;
@array = /((\d)a(\d(b))\d)/ for $chr;

printf “%s\n”, $_ for @array;
\end{verbatim}
\end{waku}
\item{問題\stepcounter{question}\thequestion (★☆☆☆☆)} 例文から後方参照のルールを確認しましょう．また配列と無名配列の違いも確認しておきましょう．
\end{description}

\subsection{$< >$}
\begin{description}
\item{解説} \verb|山カッコ演算子はファイルハンドルを受け取ると，それを読み込む演算子です．ハンドルが省略されるとSTDINを対象とします．また山カッコ演算子のデフォルト区切り文字は\n，つまり改行です．そのために文章を一行ずつ読み込めるわけですが，この区切り文字は以下のように変えることが出来ます．|
\begin{verbatim}
local $/ = “\n>”;
while(<FILE>){
	処理
}
\end{verbatim}
\verb|これでカッコの中だけ区切り文字が>(ただし直前に改行有り)に変えることが出来ます．以下はこれを利用して効率よくfst形式のファイルを加工している例です．|\\
\begin{waku}
\begin{verbatim}
open FST, hoge.fst or die;
{
    local $/ = “\n>”;
    while(<FST>){
        my($head, @seq) = split /\n/;
        my($seq = join ‘’, @seq) =~ s/[-a-zA-Z]//g;
        $head =~ s/>//;
        $fst{$head} = $seq;
    }
}
\end{verbatim}
\end{waku}
\item{問題\stepcounter{question}\thequestion (★☆☆☆☆)} ls -Rの結果をファイルに書き出し，それを効率よく読み込み，ハッシュに格納しましょう．
\end{description}

\subsection{/ /}
\begin{description}
\item{解説} \verb|正規表現の囲い文字です．正確にはマッチ演算子m//の省略形です．mが省略されると囲い文字は//でなければいけませんが，mを省略しない場合以下の例文のようなことが出来ます．|\\
\begin{waku}
\begin{verbatim}
my $matsui = ‘GODZILLA’;
my $slash = ‘//////’;

print ”55\n” if $matsui =~ m!GOD!;
print ”6slashes\n” if $slash =~ m#\/\/\/\/\/\/#;
\end{verbatim}
\end{waku}
\item{問題\stepcounter{question}\thequestion (★☆☆☆☆)} 100文字と3文字の文字列をそれぞれ作り，100文字の文字列中に3文字の文字列が含まれるかチェックする．という作業を100回繰り返し，結果を表示しましょう．
\end{description}

\section{デバグ\index{でばぐ@デバグ}の定石，コメントアウト\index{こめんとあうと@コメントアウト}}
\subsection{デバグしやすいコード}
\begin{description}
\item{解説} \verb|プログラムを作成する際には入力ミス，アルゴリズムの不備，想定外のエラーはつきものです．そういったエラーをバグといい，直すことをデバグといいます．デバグはプログラミングの重要な一行程であり，以下に効率よくデバグできるかは効率のいいプログラミングには必須のスキルとなります．|
\begin{itemize}
\item 中身を書く前にカッコを閉じる
\item コメントをつける
\item スペース・改行・インデントの幅を統一する\footnote{emacsを使用している場合はPerl-modeを使うと便利です．}
\item 抽象度の高いプログラムにする
\end{itemize}
\begin{waku}
\begin{verbatim}
1)
$hoge[ ]
↓
$hoge[5]

2)
substr( );
↓
substr($seq, 0, 3);

3)
while( ){ 

}
↓
while($num > 5){ 

}
↓
while($num > 5){ 
    print $num++;
}
\end{verbatim}
\end{waku}
\item{問題\stepcounter{question}\thequestion (★☆☆☆☆)} ここで使われているプログラミングのコツとはなんでしょうか．
\end{description}

\subsection{コメントアウトの仕方，デバグの手順}
\begin{description}
\item{解説} printout，コメントアウト，カット，$\_ \_ $END$\_ \_$，exit，die\\
デバグのときにはこれらを用いるといいでしょう．\\
(a) コメントアウト \verb|#に続く一行はインタプリタに無視されます|\\
\begin{waku}
\begin{verbatim}
#この行は無視されます
#この行は無視されます
print “Hello World\n”;
\end{verbatim}
\end{waku}\\
\\
(b) POD\index{POD}の応用 広い範囲をコメントアウトするときに用います\\
\begin{waku}
\begin{verbatim}
=c
この行は無視されます
この行は無視されます
=cut
print “Hello World\n”;
\end{verbatim}
\end{waku}\\
\\
(c) $\_ \_ $END$\_ \_$ \verb|以降のコードを無効にしたいときに用います．アンダーバーが計4つ使われていることに注意してください|\\
\begin{waku}
\begin{verbatim}
print “Hello World\n”;
__END__
これから後は無視されます
\end{verbatim}
\end{waku}\\
\\
(d) exit プログラムを強制的に終了したいときに用います．\index{exit}\\
\begin{waku}
\begin{verbatim}
print “Hello World\n”;
if($a != 1){
    exit;
    $aが1ではないときプログラムはここで終了します
}
\end{verbatim}
\end{waku}\\
\\
(e) die エラーによる強制終了にはdieを用います\index{die}\\
\begin{waku}
\begin{verbatim}
open FILE, ‘ecoli.fst’ or die”Can’t open ecoli.fst:$!”;
ecoli.fstが開けないとき，その旨出力してからプログラムが終了します
\end{verbatim}
\end{waku}
\item{問題\stepcounter{question}\thequestion (★☆☆☆☆)} 上に挙げた方法の動作をそれぞれ確認しましょう．
\end{description}

\subsection{ありがちなミス，対処法}
\begin{description}
\item{解説} スクリプトを作成中に起こるありがちなバグというものがあります．しかしそれに対する対処法を知っているとデバグが楽になります．以下にエラーメッセージ\index{えらーめっせーじ@エラーメッセージ}の例を示します．\\
\item{事例1} 変数の宣言忘れ or タイプミス or $\$ $等のつけ忘れ\\
\begin{waku}
\begin{verbatim}
・Global symbol "$hoge" requires explicit package name
・Bareword "hoge" not allowed while "strict subs"
・Odd number of elements in hash assignment
・HASH(0x9441c18)
・Type of arg 1 to keys must be hash (not private array)
\end{verbatim}
\end{waku}

\item{事例2} FILEが開けなかった or 外部環境が整っていない or ヘッダーが変\\
\begin{waku}
\begin{verbatim}
・Can't locate hoge.pm in @INC…
・Command not found.
\end{verbatim}
\end{waku}

\item{事例3} カッコの数があっていない\\
\begin{waku}
\begin{verbatim}
・Missing right curly or square bracket
・コードのないところでのエラーメッセージ
\end{verbatim}
\end{waku}

\item{事例4} 無限ループ or 深すぎる再帰\\
\begin{waku}
\begin{verbatim}
・Deep recursion on subroutine "main::hoge"
・プログラムが止まらない．
\end{verbatim}
\end{waku}

\item{事例5} フォーマットの読み間違い\\
\begin{waku}
\begin{verbatim}
・substr outside of string
・Use of uninitialized value
\end{verbatim}
\end{waku}
\item{問題\stepcounter{question}\thequestion (★☆☆☆☆)} 上に挙げたエラーを実際に出力させてみましょう．プログラムが止まらなくなってしまったらCtrl+Cで強制終了させることができます．
\end{description}

\section{モジュール\index{もじゅーる@モジュール}}
\subsection{作り方}
\begin{description}
\item{解説} \verb|プログラムの一部を別のファイルに記述し，後でそれを読み込み利用することが出来ます．この別ファイルのことをモジュールといいます．モジュールを活用することでプログラムの再利用性や可読性を向上させることが出来ます．以下は最低限の要件を満たしたモジュールの書き方です．|
\begin{waku}
\begin{verbatim}
#!/usr/bin/env perl
use strict;
package My_module;
require Exporter;
our @ISA = qw(Exporter AutoLoader);

our @EXPORT = qw(
                 hello_world
);
our $VERSION = '1.0';

sub hello_world{
    print “hello_world\n”;
}

1;
__END__
\end{verbatim}
\end{waku}
\item{問題\stepcounter{question}\thequestion (★☆☆☆☆)} 上の例文をMy$\_$module.pmというファイルに保存しましょう．
\end{description}

\subsection{使い方}
\begin{description}
\item{解説} \verb|use\index{use}関数を用いてモジュールをインポートすることが出来ます．|\\
\begin{waku}
\begin{verbatim}
use My_module;
hello_world;
\end{verbatim}
\end{waku}
\item{問題\stepcounter{question}\thequestion (★☆☆☆☆)} 上のようにして，作ったモジュールを利用してみましょう．
\item{問題\stepcounter{question}\thequestion (★☆☆☆☆)} nstore\index{nstore}を使って変数を保存し，さらに別のプログラムで再利用してみましょう．
\item{問題\stepcounter{question}\thequestion (★☆☆☆☆)} 任意のプログラム(Matinspector, clustalW, G等)を動かすexpectを作成し，それと組み合わせたモジュールを作成してください．そして引数を与えて実行しましょう．
\end{description}

\section{略記法，慣用句，定石}
\subsection{$\$ \_$を使う}
\begin{description}
\item{解説} 基本的に関数，ループ，演算子は引数を与えなくてはいけませんが，与えなかった場合デフォルトの引数を考慮してくれます．これを逆手にとって省略した書き方が可能です．デフォルトの引数には\verb|$_，@_，@ARGV，STDIN|などがあります．\\
\begin{waku}
\begin{verbatim}
printf “%s\t%s\n”, (split)[0, 7] for `w`;
\end{verbatim}
\end{waku}
\item{問題\stepcounter{question}\thequestion (★☆☆☆☆)} 上のコードを省略のない形に戻しましょう．
\end{description}

\subsection{カッコを減らす}
\begin{description}
\item{解説} いままでもでてきましたが，関数のデフォルトや特殊なループ表現を用いると，余計なカッコを減らすことが出来ます．無理に減らすのは逆効果ですが，決まったパターンの省略法を身につけると見やすいプログラムが書けます．例えば下の式は皆同じ意味です．\\
\begin{waku}
\begin{verbatim}
#i
foreach my $i(@array){
    my @elm = split(/ /, $i);
    print “$elm[0]\t$elm[1]\n”;
}

#ii
for(@array){
    my @elm = split(/ /, $i);
    printf “%s\t%s\n”, @elm[0,1];
}

#iii
printf “%s\t%s\n”, (split)[0,1] for @array;
\end{verbatim}
\end{waku}
\item{問題\stepcounter{question}\thequestion (★☆☆☆☆)} 今まで書いてきたコードを見直し，カッコが減らせる箇所がないか探して見ましょう．
\end{description}

\subsection{関数のデフォルト設定を生かす}
\begin{description}
\item{解説} \verb|関数のデフォルト設定を生かすと余分なコードが減り，見やすくなります．ユーザ関数の中でデフォルト設定を行いたいときは以下のように書くと良いでしょう|\\
\begin{waku}
\begin{verbatim}
sub hoge{	
    my($foo, $bar) = @_;
    $foo ||= 10;
    $bar ||= ‘atg’;
}
\end{verbatim}
\end{waku}
\item{問題\stepcounter{question}\thequestion (★☆☆☆☆)} デフォルト設定にはどういうものがあるか調べてみましょう．特に
\begin{itemize}
\item chomp
\item m//
\item s///g
\item shift
\item split
\end{itemize}
はデフォルト設定について把握しておきましょう．

\end{description}

\chapter{実践 Bioinformatics}
第2章でPerlの基礎をマスターしたのを受けて，第3章では実際の解析例を通して実用的なプログラミングスキルを身につけることを目指します．題材としてはBioinformaticsでは基盤となるテーマである遺伝子発現データの解析，相互作用データの解析，ゲノム配列解析の三つを選びました．これらの解析を体験する事でPerlスクリプトの書き方の定石をひととおり網羅することができるでしょう．また同時に関数の実装法，ハッシュ操作法，そしてファイルの読み込み法を復習します．この章をこなす事で目的に応じたプログラムを不自由無く書けるようになるはずです．

\section{Perlによる遺伝子発現データ\index{いでんしはつげんでーた@遺伝子発現データ}の解析}
\subsection{はじめに}
分子生物学の中でも最も重要なテーマの一つは遺伝子発現と遺伝子ネットワークの観察でしょう．複雑な遺伝子相互作用の俯瞰図は生命活動の仕組みを理解する上で欠かせない情報です．それらを解明する為に用いられるデータとして遺伝子発現データがあります．遺伝子発現データは各遺伝子の時期ごと，あるいは組織，条件ごとでの転写物の発現量を数値データで表したもので，それはそのまま遺伝子の"活性"を表す数値であると考えられます．近年ではマイクロアレイを用いた解析によって日々大量のデータが蓄積されつつあり，このような大量のデータを扱う上ではコンピュータスキルを駆使する事が必要不可欠です．本セクションでは遺伝子発現データの解析の一例として遺伝子相互作用の予測を体験することで，Bioinformaticsの実際の作業内容をイメージすることが目標となります．

\subsection{相関係数}
まず発現相関と機能的相関の関係について考えましょう．同時期に発現している遺伝子のグループは機能的相関があると考える事は妥当でしょうか？もちろん具体的な相互作用が観察されたわけではありませんので，当然グループの中には偶然似た発現の様相を示しただけで機能的につながりの無い候補も含まれているでしょう．しかし物理的な相互作用を想定した場合，同時期に発現した方が効率が良いと考えられるため機能的相関の推定に発現相関を用いる事は妥当だと考えられます．つまりマイクロアレイのデータの解析結果から発現量の変化が同期しているような遺伝子を探し出すことができれば，それは同一の機能を持つ，あるいは関係の深い遺伝子の組み合わせの候補が得られた事になるでしょう．そのような解析に用いられる基本的な指標の一つに相関係数があります．相関係数は二つのグループ間の従属関係の強弱を示す値です．今遺伝子1の発現データ$x_{11},x_{12},x_{13},\ldots ,x_{1n} $と，遺伝子２の発現データ$x_{21},x_{22},x_{23},\ldots  x_{2n}$が与えられたとき，相関係数$r_{12}$の計算式は以下の通りです．
\begin{displaymath}
\left\{
\begin{array}{l}
r_{12}=\frac{1}{n}\sum_{j=1}^{n}z_{1j}z_{2j} \\
z_{ij}=\frac{x_{ij}-\overline{x}_{i}}{\sigma_{i}}
\end{array}
\right.
\end{displaymath}
ここで，$\overline{x}_{1}$は遺伝子１の発現量の平均，$\overline{x}_{2}$は遺伝子2の発現量の平均を表します．また，$\sigma_{1}$は遺伝子1の発現量の標準偏差，$\sigma_{2}$は遺伝子2の発現量の標準偏差を表します．つまり平均と標準偏差を求めることができれば，相関係数を求めることができるのです．

\subsection{平均\index{へいきん@平均}の計算}
\begin{description}
\item{解説} まず与えられた配列の平均値を計算する関数を実装してみましょう．\\
\begin{waku}
\begin{verbatim}
sub average {
   my @data = @_;
   my $ndata = $#data + 1;
   my $total = 0;

   # @dataの合計を$totalに入れる処理

   return $total / $ndata;
}
\end{verbatim}
\end{waku}\\
以下の文で関数の動作確認ができます．2.5と表示されれば成功です．\\
\begin{waku}
\begin{verbatim}
my @x1 = (1.0, 2.0, 3.0, 4.0);
print average(@x1);
\end{verbatim}
\end{waku}\\
\item{問題\stepcounter{question}\thequestion } 平均を求める関数averageを実装しましょう．
\end{description}

\subsection{標準偏差\index{ひょうじゅんへんさ@標準偏差}の計算}
\begin{description}
\item{解説} 標準偏差の計算には以下のような関数を作ります．\\
\begin{waku}
\begin{verbatim}
sub sdev {
  my @data = @_;
  my $ndata = $#data + 1;
  my $average = average(@data);
  my $dev_total2 = 0;

  # (@dataの各要素 - @dataの平均)2の合計を$totalに入れる処理
   return sqrt($dev_total2 / $ndata);
}
\end{verbatim}
\end{waku}\\
以下の動作確認で2という答えが返ってくれば成功です．\\
\begin{waku}
\begin{verbatim}
my @x1 = (-1.0, -1.0, 3.0, 3.0);
print sdev(@x1);
\end{verbatim}
\end{waku}
\item{問題\stepcounter{question}\thequestion } 標準偏差を求める関数sdevを実装しましょう．
\end{description}

\subsection{相関係数\index{そうかんけいすう@相関係数}の計算}
\subsubsection{二つの配列の読み込み}
\begin{description}
\item{解説} 相関係数を計算するには，２つの配列を読み込む必要があります．配列が２つもあるので，リファレンスを使って配列を関数に渡してあげなければなりません．リファレンスの受け取りと，配列の中味の確認は以下のように行うことができます．\\
\begin{waku}
\begin{verbatim}
sub correlation {
   my $data1 = $_[0];
   my $data2 = $_[1];
　 print join(“,”, @$data1), “\n”;
   print join(“,”, @$data2), “\n”;
}
\end{verbatim}
\end{waku}\\
またリファレンスを関数に渡すには，\\
\begin{waku}
\begin{verbatim}
my @x1 = (1,3,5,7,9);
my @x2 = (0,2,4,6,8);
correlation(\@x1, \@x2);
\end{verbatim}
\end{waku}\\
のようにします．
\item{問題\stepcounter{question}\thequestion } 配列のリファレンスの受け渡しがちゃんとなされているか，上記プログラムは打ち込んで確認しましょう．
\end{description}

\subsubsection{欠損部分を排除}
\begin{description}
\item{解説} 各遺伝子に関して常に発現データを取得することができるとは限りません．そこで欠損部部を取り除く必要があります．\\
\begin{center}
\fbox{
\begin{tabular}{l}
$@\$ $data1 = (1, 2,0,””,5);\\
$@\$ $data2 = (0,””,3, 6,7);
\end{tabular}
}
 →  
\fbox{
\begin{tabular}{l}
$@$data1m = (1,0,5);\\
$@$data2m = (0,3,7);
\end{tabular}
}
\end{center}
この操作は以下のように書くことができます．実際に打ち込んで動作を確認しましょう．\\
\begin{waku}
\begin{verbatim}
sub correlation {
  my $data1 = $_[0];
  my $data2 = $_[1];
  my @data1m;
  my @data2m;
  for my $i (0..$#$data1){
    if(defined($data1->[$i]) && $data1->[$i] =~ /\d/ &&
       defined($data2->[$i]) && $data2->[$i] =~ /\d/){
      push(@data1m, $data1->[$i]);
      push(@data2m, $data2->[$i]);
    }
  }
  print join(",", @data1m), "\n";
  print join(",", @data2m), "\n";
}
\end{verbatim}
\end{waku}
\end{description}

\subsubsection{相関係数を求める}\index{そうかんけいすう@相関係数}
\begin{description}
\item{解説} 最後に相関係数を求める関数を完成させましょう．以下のようになるはずです．\\
\begin{waku}
\begin{verbatim}
sub correlation {
  my $data1 = $_[0];
  my $data2 = $_[1];
  my @data1m;
  my @data2m;
  for my $i (0..$#$data1){
    if(defined($data1->[$i]) && $data1->[$i] =~ /\d/ &&
       defined($data2->[$i]) && $data2->[$i] =~ /\d/){
      push(@data1m, $data1->[$i]);
      push(@data2m, $data2->[$i]);
    }
  }
  
  my $corr = 0;
  my $ndata = $#data1m + 1;  
  my $average1 = average(@data1m);
  my $average2 = average(@data2m);
  my $sdev1 = sdev(@data1m);
  my $sdev2 = sdev(@data2m);
  for my $i (0..$#data1m){
    $corr += 1.0/$ndata *
      ($data1m[$i] - $average1)*($data2m[$i] - $average2)
        / ($sdev1 * $sdev2);
  }   
  return $corr;
}
\end{verbatim}
\end{waku}\\
動作確認は以下のように行います．-1という答えが出れば成功です．\\
\begin{waku}
\begin{verbatim}
my @x1 = (1,"",-3, 7,-7);
my @x2 = (0, 2, 4,"", 8);
print correlation(\@x1, \@x2);
\end{verbatim}
\end{waku}\\
\item{問題\stepcounter{question}\thequestion } 相関係数を求めるプログラムを完成させましょう．
\end{description}

\subsection{遺伝子発現データを読み込む}
\begin{description}
\item{解説} 発現データは一般的に最初に遺伝子名(ORF)，そして遺伝子の機能，各時期・組織における発現量が並べられており，例えば表3.1のような構造となっています．そこで，遺伝子名が与えられたときに，対応する発現パターンを配列へのリファレンスで返すようなハッシュを作成します．以下のプログラムを打ち込んで，ハッシュによる遺伝子名と遺伝子発現パターンの対応付けができることを確認しましょう．

\begin{table}[h]
\begin{center}

\caption{遺伝子発現データの構造例}

\begin{tabular}{cccccc}\hline
Gene&aloha0&aloha7&aloha14&aloha21&aloha28\\ \hline
YBR166C&0.33&-0.17&0.04&-0.07&-0.09\\ %\hline
YOR357C&-0.64&-0.38&-0.32&-0.29&-0.22\\ %\hline
YLR292C&-0.23&0.19&-0.36&0.14&-0.40\\ %\hline
YGL112C&-0.69&-0.89&-0.74&-0.56&-0.64\\ %\hline
YIL118W&0.04&0.01&-0.81&&-0.30\\ %\hline
YDL120W&0.11&0.32&0.03&0.32&0.03\\ %\hline
YHL025W&-0.47&1.00&-0.51&-0.25&-0.71\\ \hline
\end{tabular}
\end{center}
\end{table}

\begin{waku}
\begin{verbatim}
my %exp;
my @exp = (0.33, -0.17, 0.04, -0.07, -0.09);
$exp{ "YOR166C"} = [ @exp ];
print join(",", @{$exp{ "YOR166C" }});
\end{verbatim}
\end{waku}\\
次に，与えられた発現データファイルより，遺伝子名とその発現パターンを上記のようにハッシュで結びつける関数を書きましょう．\\
\begin{waku}
\begin{verbatim}
sub read_expression {
  my $filename = $_[0];
  local *FH;
  my %exp;
  open(FH, $filename);
  my $header = <FH>;
  while(<FH>){
    chomp;
    my @r = split(/\t/);
    my $gene_name = shift @r;
    my $gene_func = shift @r; # 2列目に遺伝子の機能情報がある場合
    $exp{ $gene_name } = [ @r ];
  }
  close FH;
  return %exp;
}
\end{verbatim}
\end{waku}
\item{問題\stepcounter{question}\thequestion } YBR166CとYOR357Cの遺伝子発現パターンの相関係数を求めましょう．
\item{問題\stepcounter{question}\thequestion } 相関係数が0.7以上の遺伝子のペアを列挙しましょう．ペアとなる遺伝子の機能に一致は見られるでしょうか？Entrez Gene (http://www.ncbi.nlm.nih.gov/entrez/query.fcgi?db=gene) 等で調べてみましょう．
\end{description}

\newpage

\section{Perlによる生化学データの解析}
\subsection{はじめに}

本セクションではPerlのリファレンスの使い方を徹底的にマスターし，配列の重み行列の作成など配列解析に応用できる技術の取得を目指します．題材としてはタンパク質-タンパク質相互作用(PPI)データの簡単な解析とシグナル配列の探索をあげました．PPIの解析とシグナル配列の探索は古くからコンピュータ解析が活躍している分野です．これらの解析を体験する事で目的に応じたスクリプトの書き方も習得しましょう．

\subsection{ハッシュの復習}\index{はっしゅ@ハッシュ}
\begin{description}
\item{解説} Perlでハッシュは非常に頻繁に使われます．ある要素と他の要素を簡単に関係付けることができるので，非常に便利です．例えば，あるタンパク質がどのような機能を持っているかを記録していくときに，\\
\begin{waku}
\begin{verbatim}
my %func;
\end{verbatim}
\end{waku}\\
で，タンパク質名と機能を対応させるハッシュの変数を定義することができます．\\
\begin{waku}
\begin{verbatim}
$func{ "SAM1" } = "Metabolism";
$func{ "CRM1" } = "Transport";
$func{ "TAF25" } = "Transcription";
\end{verbatim}
\end{waku}\\
で実際にタンパク質名と機能とを対応させることができます．タンパク質名は“キー”となり，機能はその“値”となります．\\
\begin{waku}
\begin{verbatim}
my @proteins = keys(%func);
\end{verbatim}
\end{waku}\\
は\verb|%|funcに登録されている全てのキーを抽出し，配列に入れます．キーの順序は決まっていません．\\
\begin{waku}
\begin{verbatim}
foreach my $protein (@proteins){
   print "$protein\t$func{$protein}\n";
}
\end{verbatim}
\end{waku}\\
こうすると，登録されているタンパク質名とその機能の一覧が出力されます．あるキーがハッシュに登録されているかを調べるには，definedを使います．\\
\begin{waku}
\begin{verbatim}
if(defined($func{ "TAF25" })){
   print $func{ "TAF25" }, "\n"; 
}
\end{verbatim}
\end{waku}\\
\item{問題\stepcounter{question}\thequestion } TAB区切りのタンパク質間相互作用\index{たんぱくしつそうごさよう@タンパク質間相互作用}データのファイルと，タンパク質の機能を示したファイルをもとに，相互作用するタンパク質の機能を以下のように表示していくプログラムを作成しましょう．

\begin{waku}
\begin{verbatim}
タンパク質A	タンパク質B	タンパク質Aの機能	タンパク質Bの機能
タンパク質C	タンパク質D	タンパク質Cの機能	タンパク質Dの機能
タンパク質E	タンパク質F	タンパク質Eの機能	タンパク質Fの機能
                                                               :
\end{verbatim}
\end{waku}\\
タンパク質間相互作用ファイルの例：\\
\begin{waku}
\begin{verbatim}
MAK16   YJR044C
DRS2    YPL146C
PRP45   SYF1
\end{verbatim}
\end{waku}\\
タンパク質の機能ファイルの例：\\
\begin{waku}
\begin{verbatim}
SYF1    Cell_cycle_control
DRS2    Small_molecule_transport
MAK16   RNA_processing_modification
PRP45   RNA_processing_modification
YJR044C Unknown
YPL146C Unknown
\end{verbatim}
\end{waku}\\
結果の例\\
\begin{waku}
\begin{verbatim}
MAK16   YJR044C	RNA_processing_modification	Unknown
DRS2    YPL146C	Small_molecule_transport	Unknown
PRP45   SYF1	RNA_processing_modification	Cell_cycle_control
\end{verbatim}
\end{waku}\\
\item{問題\stepcounter{question}\thequestion } タンパク質間相互作用データのファイル中で各タンパク質が何回登場するか，ハッシュを用いてカウントして出力しましょう．
\end{description}

\subsection{関数へのリファレンスの受け渡し}\index{りふぁれんす@リファレンス}
\begin{description}
\item{解説} \verb|関数で直接複数の配列や複数のハッシュを受け取ることはできません．例えば以下は配列@aと@bの要素を先頭から掛け合わせてその総和を計算する関数i_productを定義していますが，これでは正しく動きません．|\\
\begin{waku}
\begin{verbatim}
#!/usr/bin/perl

use strict;

sub i_product {
	my(@vector1, @vector2) = @_;
	my $total = 0;
	foreach my $i (0..$#vector1){
	    $total += $vector1[$i] * $vector2[$i];
	}
	return $total;
}

my @a = (1,2,3);
my @b = (4,5,6);

print i_product(@a, @b);
\end{verbatim}
\end{waku}\\
\verb|なぜなら，i_product(@a, @b)としたときに，@aと@bの中味が展開され(1,2,3,4,5,6)となり，@aと@bの境界がなくなってしまうからです．このケースでは，@vector1に(1,2,3,4,5,6)が入ってしまい，@vector2には何も入りません．|\\\\
\verb|そこで配列そのものではなく，配列へのリファレンスを渡すことでこの問題を回避します．リファレンスは数値や文字列と同じ部類であるスカラーに入るので，問題なく複数のリファレンスの受け渡しを行うことができます．|\\
\begin{waku}
\begin{verbatim}
#!/usr/bin/perl

use strict;

sub i_product {
	my($vector_ref1, $vector_ref2) = @_;
	my $total = 0;
	foreach my $i (0..$#$vector_ref1){
	    $total += $vector_ref1->[$i] * $vector_ref2->[$i];
	}
	return $total;
}

my @a = (1,2,3);
my @b = (4,5,6);

print i_product(\@a, \@b);
\end{verbatim}
\end{waku}
\begin{itemize}
\item \verb|@aは配列(1,2,3)を表します．|
\item \verb|$vector_ref1は配列(1,2,3)へのリファレンスを表します．|
\item \verb|@$vector_ref1は配列(1,2,3)を表します．これは@aと等価です．|
\item \verb|$$vector_ref1[1]および$vector_ref1->[1]は配列@$vector_ref1の1番目の要素，つまり2を表します（0番目から数える）．|
\end{itemize}
配列だけでなく，ハッシュもリファレンスにして関数に渡すことができます．例えば下のプログラム(一部)を考えてみましょう．\\
\begin{waku}
\begin{verbatim}
sub test_hash_ref {
	my($h1_ref, $h2_ref) = @_;

}

%c = (“height” =>160, “weight”=> 55);
%d = (“height” =>175, “weight”=> 70);
test_hash_ref(\%c, \%d);
\end{verbatim}
\end{waku}
\begin{itemize}
\item \verb|%cはハッシュ(“height” =>160, “weight”=> 55)を表します．|
\item \verb|$h1_refはハッシュ(“height” =>160, “weight”=> 55)へのリファレンスを表します．|
\item \verb|%$h1_refはハッシュ(“height” =>160, “weight”=> 55)を表します．これは%cと等価です．|
\item \verb|$$h1_ref{“height”}および$h1_ref->{“height”}は160を表します．|
\end{itemize}
\item{問題\stepcounter{question}\thequestion } \verb|配列へのリファレンスとハッシュへのリファレンスを受け取り，配列をハッシュに従って置き換えたものを返す関数hash_transを作成しましょう．例えば，@a = (“a”, “b”, “a”, “c”)，%h = (“a” => “apple”, “b”=> “banana”, “c” => “candy”)としてhash_trans(\@a, \%h)とすると，(“apple”, “banana”, “apple”, “candy”)が返ってくるようにします．|
\end{description}

\subsection{リファレンスを含む配列とハッシュ}
\begin{description}
\item{解説} 今まで配列で扱ってきた要素は数値か，文字列でした．\\
\begin{waku}
\begin{verbatim}
@array = (“a”, “t”, “g”, “c);
\end{verbatim}
\end{waku}\\
しかしそれ以外に，配列へのリファレンスを配列の要素とすることができます．これを実現するためには，\\
\begin{waku}
\begin{verbatim}
@array2 = (“a”, “t”, [0, 1, 2, 3], “g”);
\end{verbatim}
\end{waku}\\
とします．あるいは，\\
\begin{waku}
\begin{verbatim}
@array3 = (0, 1, 2, 3);
\end{verbatim}
\end{waku}\\
という代入をしておき，\\
\begin{waku}
\begin{verbatim}
@array2 = (“a”, “t”, \@array3, “g”);
\end{verbatim}
\end{waku}\\
とすることもできます．この場合は@array3を操作すると，@array2の中味に影響が出ます．ここで，\\
\begin{itemize}
\item \verb|$array2[1]は”t”を表します．|
\item \verb|$array2[2]は(0, 1, 2, 3)へのリファレンスを表します．|
\item \verb|@{$array2[2]}は(0, 1, 2, 3)を表します．|
\item \verb|${$array2[2]}[3]は3を表します．もう少し見やすい表記で，$array[2]->[3]も3を表します．これをうまく使いこなすと，二次元配列の表現が可能になります．|
\end{itemize}
同様にして以下のようにしてハッシュへのリファレンスを含む配列を作ることも可能です．\\
\begin{waku}
\begin{verbatim}
@array4 = (“a”, “t”, {“X”=>123, “Y”=>456}, “g”);
\end{verbatim}
\end{waku}\\
\begin{itemize}
\item \verb|$array4[2]は{“X”=>123, “Y”=>456}へのリファレンスを表します．|
\item \verb|%{$array4[2]}は{“X”=>123, “Y”=>456}を表します．|
\item \verb|${$array4[2]}{“X”}は123を表します．もう少し見やすい表記で，$array4[2]->{“X”}も123を表します．|
\end{itemize}

リファレンスを要素に持つハッシュを作ることも可能です．これを実現させるためには例えば，以下のようにします．\\
\begin{waku}
\begin{verbatim}
%hash1 = (“X”=>100, “Y”=>{“a”=>12, “t”=>45}, “Z”=>200);
\end{verbatim}
\end{waku}\\
\begin{itemize}
\item \verb|$hash{“X”}は100を表します．|
\item \verb|$hash{“Y”}は{“a”=>12, “t”=>45}へのリファレンスを表します．|
\item \verb|%{$hash{“Y”}}は{“a”=>12, “t”=>45}を表します．|
\item \verb|${$hash{“Y”}}{“a”}は12を表します．もう少し見やすい表記で，$hash{“Y”}->{“a”}も12を表します．|
\end{itemize}

\item{問題\stepcounter{question}\thequestion } 配列へのリファレンスからなる配列の中味を表示する関数showarray2dを作成しましょう．\\
\begin{waku}
\begin{verbatim}
@a = ([1,2], [2,3], [1,1]);
print show_array_2d(@a);
\end{verbatim}
\end{waku}\\
とすると\\
\begin{waku}
\begin{verbatim}
1,2
2,3
1,1
\end{verbatim}
\end{waku}\\
のような出力が得られるようにします．\\

\item{問題\stepcounter{question}\thequestion } 行列\index{ぎょうれつ@行列}計算をする関数mproductを作成しましょう．\\
\begin{waku}
\begin{verbatim}
@a = ([1,2],[2,3],[1,1]);
@b = ([2,1],[1,2])
@c = m_product(\@a, \@b);
\end{verbatim}
\end{waku}\\
とすると，下記の計算が行われます．
\begin{displaymath}
\left(
\begin{array}{cc}
1&2\\
2&3\\
1&1
\end{array}
\right)
\left(
\begin{array}{cc}
2&1\\
1&2
\end{array}
\right)
=\left(
\begin{array}{cc}
4&5\\
7&8\\
2&3
\end{array}
\right)
\end{displaymath}
このとき，\@cは([4,5], [7,8], [3,3])となるようにしましょう．
\end{description}

\subsection{重み行列の作成}\index{おもみぎょうれつ@重み行列}
\begin{description}
\item{解説} 転写開始部位周辺や，開始コドン周辺は特定の塩基で偏っていることが知られています．どの位置でどの塩基にどれくらいの偏りがあるかを表現する１つの方法が重み行列を使うことです．\\
今，以下の開始コドン周辺の塩基配列を例にとりましょう．囲みが開始コドンです．\\
\begin{waku}
\begin{tabular}{p{4pt}p{4pt}p{4pt}}
agt&atg&act\\
cac&atg&aac\\
tag&atg&aga\\
tac&atg&cga\\
agc&atg&aga
\end{tabular}
\end{waku}\\
開始コドンのaの位置を0とし，その上流に行くに従って位置を1だけ引いていき，下流に行くに従って1だけ足していきます．すると各位置における各塩基の頻度を表した以下のような表ができます．

\begin{table}[h]
\begin{center}
\caption{度数表}
\begin{tabular}{cccccccccc}\hline
&-3&-2&-1&0&1&2&3&4&5\\\hline
A&2&3&0&5&0&0&4&1&3\\%\hline
C&1&0&3&0&0&0&1&1&1\\%\hline
G&0&2&1&0&0&5&0&3&0\\%\hline
T&2&0&1&0&5&0&0&0&1\\\hline
\end{tabular}
\end{center}
\end{table}

これを割合に直すと，以下のようになります．
\begin{table}[h]
\begin{center}
\caption{重み行列}
\begin{tabular}{cccccccccc}\hline
&-3&-2&-1&0&1&2&3&4&5\\\hline
A&0.4&0.6&0.0&1.0&0.0&0.0&0.8&0.2&0.6\\%\hline
C&0.2&0.0&0.6&0.0&0.0&0.0&0.2&0.2&0.2\\%\hline
G&0.0&0.4&0.2&0.0&0.0&1.0&0.0&0.6&0.0\\%\hline
T&0.4&0.0&0.2&0.0&1.0&0.0&0.0&0.0&0.2\\\hline
\end{tabular}
\end{center}
\end{table}

\verb|これを重み行列(weight matrix)といいます．重み行列はハッシュおよびリファレンスを使うと簡単に表現できます．重み行列を表すハッシュを%matrixとして，例えば$matrix{ -2 }->{ “c” }を-2の位置のcの頻度を表す数値にするのが分かりやすいでしょう．では，ここで与えられた塩基配列群から行列%matrixを返す関数return_matrixを作ってみましょう．|\\
\begin{waku}
\begin{verbatim}
sub return_matrix {
    my($seqs_ref, $start) = @_;
    # $seqs_refは塩基配列群へのリファレンス
    # $startが位置0を塩基配列の何番目にするかという数字
   my %matrix;
   my $j = 0;
   
   my $counted_flag; # 0か1の値を取るフラッグ．
   # 0: 長さ$j+1以上の配列が一本もない
   # 1: 長さ$j+1以上の配列が少なくとも一本はある

    do {
        $counted_flag = 0;
        for my $i (0..$#$seqs_ref){ # 配列の数だけ繰り返す
            if($j < length($seqs_ref->[$i])){ 
            # 配列一本の長さが$j+1以上かどうか確認．
            $counted_flag = 1; # フラッグを立てる
            my $nuc = substr($seqs_ref->[$i], $j, 1);
            # 対象配列の$j番目の塩基を取り出す．
            $matrix{ $j - $start }->{ $nuc } ++;
            # 行列中の値に反映させる
         } 
      }
      $j ++;
   } while ($counted_flag);

   return %matrix;
}
\end{verbatim}
\end{waku}\\
なお\\\index{do while}
\begin{waku}
\begin{verbatim}
do {“処理”} while(“条件”);
\end{verbatim}
\end{waku}\\
で，まず1回“処理”を行い，次からは“条件”が成立するときに“処理”を繰り返します．\\
\verb|上記プログラムを作成した上で下のように関数を呼び出すと，3番目の塩基を位置0としたときの行列%matrixを作成することができます．|\\
\begin{waku}
\begin{verbatim}
my @sequences = (“agtatgact”,
    “cacatgaac”,
    “tagatgaga”,
    “tacatgcga”,
    “agcatgaga” 
    );
my %matrix = return_matrix(\@sequences, 3);
\end{verbatim}
\end{waku}\\

\item{問題\stepcounter{question}\thequestion } 上記プログラムで，行列中の数値は度数そのもので，割合にはなっていません．これを割合にするようにプログラムを改良しましょう．
\verb|下記のdips_w_matrix関数は，重み行列$wm_ref(リファレンス)と表示開始位置$pos_from，表示終了位置$pos_toを受け取ると，その区間の重み行列を表示します．|\\
\begin{waku}
\begin{verbatim}
sub disp_w_matrix($$$){
    my($wm_ref, $pos_from, $pos_to) = @_;

    printf("%3s", " ");
    for my $position ($pos_from..$pos_to){
        printf("\t%4d", $position);
    }
    print "\n";

    printf("%3s", "--");
    for my $position ($pos_from..$pos_to){
        printf("\t%4s", "----");
    }
    print "\n";

    foreach my $nuc ("a", "c", "g", "t"){
        printf("%3s", $nuc);
        for my $position ($pos_from..$pos_to){
            my $val = $wm_ref->{$position}->{$nuc};
            if(!defined($val)){ $val = 0; }
            printf("\t%.2lf", $val);
        }
        print "\n";
    }
    print "\n";
}
\end{verbatim}
\end{waku}\\
\verb|下記の呼び出しで，重み行列%mの位置-1から2までの内容が表示されます．|\\
\begin{waku}
\begin{verbatim}
disp_w_matrix(\%m, -1,2);
\end{verbatim}
\end{waku}\\
\end{description}

\subsection{シグナル配列の探索}
\begin{description}
\item{解説} 今度は1塩基ごとではなく，複数の塩基配列パターンとして特異的なシグナルを検出する方法を学びます．\\
\begin{waku}
ac\fbox{agg}tagtatgact\\
caa\fbox{agg}tcaatgaac\\
ta\fbox{agg}ctcgatgaga\\
ta\fbox{agg}catcatgcga\\
agc\fbox{agg}ctgatgaga
\end{waku}\\

\verb|-7の位置の”agg”の出現度数は3，出現割合は3/5=0.6，-6の位置の”agg”の出現度数は2，出現割合は2/5=0.4になります．このように与えられた配列と位置，パターンに対して，度数やその割合を求める関数を作成しましょう．|\\
\begin{waku}
\begin{verbatim}
sub calc_freq($$$){
    my($seq_set_ref, $pos, $pat) = @_;
    # $seq_set_ref 塩基配列群へのリファレンス
    # $pos 求める位置．但し，塩基配列群の先頭の位置を0とする
    # $pat 出現頻度を求めるパターン

    my $total = 0; # 解析対象となった配列の数
    my $count = 0; # 配列パターン$patが位置$posに検出された配列数

    foreach my $seq (@$seq_set_ref){
	if($pos + length($pat) - 1 < length($seq) &&
	   substr($seq, $pos, length($pat)) =~ /^[acgt]+$/){
            # $posが配列の長さを超えないかの確認と，
            # a,c,g,t以外の塩基が含まれないかの確認
	    $total ++;
	    if(substr($seq, $pos, length($pat)) eq $pat){
	        $count ++; # 配列パターンが$patにマッチ
	    }
	}
    }

    return($count, $total);

}
\end{verbatim}
\end{waku}\\
上記関数を例えば\\
\begin{waku}
\begin{verbatim}
my @sequences = (“acaggtagtatgact”,
“caaaggtcaatgaac”,
“taaggctcgatgaga”,
“taaggcatcatgcga”,
“agcaggctgatgaga”);
my($count, $total) = calc_freq(\@sequences, 3, “agg”);
\end{verbatim}
\end{waku}\\
\verb|のように呼び出すと，3番目の位置に”agg”というパターンが出現する回数が数えられ，$countに2, $totalに解析対象となった配列数5が入ります．$count / $totalは出現割合を表します．|\\

\verb|実際にはどのパターンがどの位置で顕著に出現するかは分かりません．そこで決められた範囲内における決められた長さの塩基配列パターンの頻度を全て調べる必要があるでしょう．以下はある範囲内(下の例では先頭から0番目〜10番目の位置)の特定のパターン（下の例では”agg”）の頻度をプロットしていくプログラムの一例です．|\\
\begin{waku}
\begin{verbatim}
foreach my $pos (0..10){ # 調べる位置の範囲
   my($count, $total) = calc_freq(\@seq, $pos, "agg");
   print "$pos\t", $count / $total, "\n";
}
\end{verbatim}
\end{waku}\\
\verb|ハッシュを使うと，全パターンを１度に網羅することができます．下記の関数calc_freq_allでは，与えられた配列群$seq_set_refの中の指定された位置$posの決められた長さ$lenの塩基配列の出現回数をハッシュ%countで数えます．|\\
\begin{waku}
\begin{verbatim}
#!/usr/bin/perl

use strict;

sub calc_freq_all($$$){
  my($seq_set_ref, $pos, $len) = @_;
  # $seq_set_ref 塩基配列群へのリファレンス
  # $pos 求める位置．但し，塩基配列群の先頭の位置を0とする
  # $pat 出現頻度を求めるパターン
  
  my $total = 0; # 解析対象となった配列の数
  my %count; # 配列パターンが位置$posに検出された配列数
  
  foreach my $seq (@$seq_set_ref){
    if($pos + $len - 1 < length($seq) &&
       substr($seq, $pos, $len) =~ /^[acgt]+$/){
      # $posが配列の長さを超えないかの確認と，
      # a,c,g,t以外の塩基が含まれないかの確認
      $total ++;
      $count{ substr($seq, $pos, $len) } ++; # パターンの出現頻度を数える
    }
  }
  return(\%count, $total);
}
\end{verbatim}
\end{waku}\\
上記関数を例えば\\
\begin{waku}
\begin{verbatim}
my @sequences = ("acaggtagtatgact",
                 "caaaggtcaatgaac",
                 "taaggctcgatgaga",
                 "taaggcatcatgcga",
                 "agcaggctgatgaga");
my($count, $total) = calc_freq_all(\@sequences, 2, 3);
\end{verbatim}
\end{waku}\\
\verb|で，$count(この場合はリファレンスになります)に塩基配列の全パターンの出現回数を記録し，|\\
\begin{waku}
\begin{verbatim}
print $count->{"agg"}, “\n";
\end{verbatim}
\end{waku}\\
で例えば”agg”の出現回数を出力することができます．
\item{問題\stepcounter{question}\thequestion } \verb|決められた範囲($pos1から$pos2)において，特定位置に最も出現する4塩基パターンと，その位置を求める関数を作成しましょう．|
\end{description}

\newpage

\section{PerlによるGenBankファイルの解析}\index{GenBank}
\subsection{はじめに}
\begin{description}
\item{解説} 遺伝子の情報の多くは決まったフォーマットに従って記述されています．最もメジャーなフォーマットはGenBank形式と呼ばれるものでNCBI(http://www.ncbi.nlm.nih.gov/)に登録されている塩基配列，タンパク質配列のデータは全てこの形式で登録されています．本セクションではGenBank形式のファイルから情報を抽出し，さらに得られたデータを用いてゲノム配列解析を行ないます．この実習を通してGenBank形式のファイルを扱う技術が身に付くだけではなく，その他の様々な公共データベースを扱う為の応用的なスキルも身につくはずです．

\end{description}

\subsection{GenBankファイルの構造}
\begin{description}
\item{解説} GenBank形式は基本的に以下のような構造になっています．ダウンロードしたファイルと見比べてみましょう\\
\begin{waku}
\begin{verbatim}
LOCUS エントリー名
そのエントリーの塩基配列に関する情報
                    :                   
ORIGIN
そのエントリーの塩基配列
                    :                   
                    :                   
//
LOCUS エントリー名
そのエントリーの塩基配列に関する情報
                    :
                    : 
\end{verbatim}
\end{waku}\\
各塩基配列はエントリーという単位で格納されています．そして各エントリーは塩基配列の情報を記述するヘッダ部分(LOCUSからORIGINの間)と実際の塩基配列の情報が書かれている部分(ORIGINから//の間)に分かれています．霊長類，脊椎動物などのGenBankファイルには複数のエントリーが含まれています．しかし，大腸菌の全ゲノム配列などのGenBankファイルには１つのエントリーしか含まれていません．通常配列解析を行う場合は，GenBank中の各エントリー中の塩基配列と塩基配列に関する情報を照らし合わせながら，解析を行います．
\item{問題\stepcounter{question}\thequestion } NCBIから{\it Escherichia coli} K12 mg1655({\it E. coli})のComplete Genomeのファイルをダウンロードしてecoli.gbkという名前で保存しましょう．以後の解析ではこのファイルを用います．
\end{description}

\subsection{初歩的な塩基配列処理}
\begin{description}
\item{解説} では解析のごく初歩的な例として，各LOCUSの配列の先頭と末端5塩基を表示するプログラムを作成しましょう．下記のエントリーの例では，gaatt, ctatgが出力されます．\\
\begin{waku}
\begin{verbatim}
LOCUS       HSAPC3B       558 bp    RNA             PRI       10-NOV-1994
DEFINITION  Human mRNA for pre-apolipoprotein CIII. ←この配列はどういうものか
ACCESSION   X01388
NID         g28727
KEYWORDS    apolipoprotein; lipoprotein; signal peptide.
SOURCE      human.
  ORGANISM  Homo sapiens ← 生物名
            Eukaryotae; mitochondrial eukaryotes; Metazoa/Eumycota group;
            Metazoa; Eumetazoa; Bilateria; Coelomata; Deuterostomia; Chordata;
            Vertebrata; Gnathostomata; Osteichthyes; Sarcopterygii; Choanata;
            Tetrapoda; Amniota; Mammalia; Theria; Eutheria; Archonta; 
            Primates; Catarrhini; Hominidae; Homo.
REFERENCE   1  (bases 1 to 558)
  AUTHORS   Levy-Wilson,B., Appleby,V., Protter,A., Auperin,D. and
            Seilhamer,J.J.
  TITLE     Isolation and DNA sequence of full-length cDNA for human
            preapolipoprotein CIII
  JOURNAL   DNA 3 (5), 359-364 (1984)
  MEDLINE   85076166
FEATURES             Location/Qualifiers
     source          1..558
                     /organism="Homo sapiens"
     CDS             72..371  ←コード領域
                     /codon_start=1             ↓コードされているタンパク質名
                     /product="pre-apolipoprotein CIII" 
                     /db_xref="PID:g28728"      ↓コードされているアミノ酸配列
                     /translation="MQPRVLLVVALLALLASARASEAEDASLLSFMQGYMKHATKTA
                     KDALSSVQESQVAQQARGWVTDGFSSLKDYWSTVKDKFSEFWDLDPEVRPTSAVAA"
     sig_peptide     72..131
     mat_peptide     132..368
                     /product="apolipoprotein CIII"
     misc_feature    532..537
                     /note="polyA signal"
BASE COUNT      107 a    175 c    143 g    133 t
ORIGIN  ↓ここから下が実際の塩基配列
        1 gaattctttt tttttttttt tttgttgctc agttcatccc tagaggcagc tgctccagga
       61 acagaggtgc catgcagccc cgggtactcc ttgttgttgc cctcctggcg ctcctggcct
      121 ctgcccgagc ttcagaggcc gaggatgcct cccttctcag cttcatgcag ggttacatga
      181 agcacgccac caagaccgcc aaggatgcac tgagcagcgt gcaggagtcc caggtggccc
      241 agcaggccag gggctgggtg accgatggct tcagttccct gaaagactac tggagcaccg
      301 ttaaggacaa gttctctgag ttctgggatt tggaccctga ggtcagacca acttcagccg
      361 tggctgcctg agacctcaat accccaagtc cacctgccta tccatcctgc gagctccttg
      421 ggtcctgcaa tctccagggc tgcccctgta ggttgcttaa aagggacagt attctcagtg
      481 ctctcctacc ccacctcatg cctggccccc ctccaggcat gctggcctcc caataaagct
      541 ggacaagaag ctgctatg
//
\end{verbatim}
\end{waku}\\
まず$\$ $seqという変数に塩基配列を格納していき，格納し終わった段階で$\$ $seqの先頭と末尾の5塩基を表示するという方法を考えましょう．まず，塩基配列が格納されている部分はORIGINから//の間です．実はORIGINから//の間の文字を取り出すという方法を使った方が正確ですが，これについては後ほど触れることにして，ここでは塩基配列が書かれている行が，\\
\\
空白 数字 空白 塩基配列
\\\\
という順番で並んでいることを利用しましょう．これは正規表現で表すと，\\
\begin{waku}
\begin{verbatim}
/^ *[0-9]+ [a-z]/
\end{verbatim}
\end{waku}\\
になります．次にこの条件に合致する行から塩基配列を取り出して格納しておく必要があります．まず，塩基配列以外の文字（数値，空白など）を,\\
\begin{waku}
\begin{verbatim}
$_ =~ s/[^a-z]//g;
\end{verbatim}
\end{waku}\\
\verb|によって取り除き，次に配列格納変数$seqに以下のような文を使って配列を追加していきます．|\\
\begin{waku}
\begin{verbatim}
$seq = $seq . $_;
\end{verbatim}
\end{waku}\\
\verb|そして//という行を見つけたら，$seqの先頭と末尾の5文字をsubstrやlengthを使って表示します．substr関数は，|\\
\begin{waku}
\begin{verbatim}
$parts = substr($string, 0, 3);
\end{verbatim}
\end{waku}\\
のように（文字列, 切り出す場所, 切り出す文字数）という引数を与えて使います． なお，Perlでは先頭の文字は1番目ではなく0番目から始まることに注意して下さい．\\\\
また先頭にLOCUSという文字が現れたら，新しいエントリーの始まりなので，\\
\begin{waku}
\begin{verbatim}
$seq = “”;
\end{verbatim}
\end{waku}\\
として中味を空にします．\\
\begin{waku}
\begin{verbatim}
#!/usr/bin/perl

use strict;
local(*FILE);
my $seq = "";

open(FILE, $ARGV[0]) || die "Cannot open \"$ARGV[0]\": $!";
while(<FILE>){
    if($_ =~ /^LOCUS/){ $seq = ""; }
    elsif($_ =~ /^ *[0-9]+ [a-z]/){ 
            $_ =~ s/[^a-z]//g;
            $seq = $seq . $_;
    }
    elsif($_ =~ /^\/\//){
		#ここは考えましょう
    }
}
close FILE;
\end{verbatim}
\end{waku}
\item{問題\stepcounter{question}\thequestion } 上記の各LOCUSの配列の先頭と末端5塩基を表示するプログラムを完成させましょう．
\end{description}

\subsection{塩基配列に関する情報の格納とコード領域の解析}
\begin{description}
\item{解説} 次にCDS\index{CDS}（protein-CoDing Sequence; タンパク質コード配列）がATGで始まる割合を求めるPerlプログラムを作成しましょう．基本的な処理はファイルを一行ずつ読みながら，LOCUS, CDS, ORIGINのキーワードに注目することです．
\begin{enumerate}
\item LOCUSを見つけたら，エントリーが始まるので，様々な準備（初期化）をします．
\item CDSを見つけたら，CDS開始領域の情報を格納します．
\item ORIGINを見つけたら，塩基配列を変数（文字列）またはファイルに格納し，その後でCDS開始領域の情報をもとに開始領域がＡＴＧで始まっているか，判断します．
\end{enumerate}
処理の流れの骨格はファイルを読みながら，LOCUS, CDS, ORIGINというキーワードをチェックすることなので，プログラムは以下のような形になるでしょう．\\
\begin{waku}
\begin{verbatim}
#!/usr/bin/perl

use strict;

# ここにget_sequence, save_sequenceなどの関数を置く

my(@cds_start_set, $cds_start); # @cds_start_setに開始位置を記録していく
my($cds_count, $atg_count); # CDSの数，atgで始まるCDSの数をカウント
my $seq;
open(FILE, $ARGV[0]) || die "Cannot open \"$ARGV[0]\": $!\n";

$cds_count = 0;
$atg_count = 0;
while(<FILE>){ #1
   chomp; # 行末端の改行記号を消す
   if($_ =~ /^LOCUS/){
      #2
   }
   elsif($_ =~ /^     CDS/){
      #3
   }
   elsif($_ =~ /^ORIGIN/){
      #4,5
   }
}

close FILE;
\end{verbatim}
\end{waku}\\
\verb|1はもうこれで完成していますから，2〜5を完成させましょう．まず上記プログラムをそのまま打ち込み（ファイル名は例えばcds_start.plにする），|\\
\begin{waku}
\begin{verbatim}
./cds_start.pl test.seq
\end{verbatim}
\end{waku}\\
と打ちこんで実行してみましょう．何も出力されないはずです．エラーが出るようならプログラムを修正しましょう．
\item{問題\stepcounter{question}\thequestion } \verb|CDSの開始領域の位置の情報を@cds_start_setに格納しましょう(3の部分)．|\\
\verb|まず，grep\index{grep}コマンドを利用し，” CDS” の文字列を含んでいる行を検索しましょう．(ここでは%はShellのプロンプトを意味します)|\\
\begin{waku}
\begin{verbatim}
% grep " CDS" test.seq | less
\end{verbatim}
\end{waku}\\
以下のように表示されるはずです．\\
\begin{waku}
\begin{verbatim}
     CDS             join(3066..3157,3281..3503,4393..4521)
     CDS             466..>496
     CDS             1..849
     CDS             135..521
     CDS             9..695
     CDS             200..1444
     CDS             complement(1..297)
     CDS             64..444
     CDS             complement(116..403)
     CDS             1..90
     CDS             <1..>185
	:
\end{verbatim}
\end{waku}\\
\verb|今回は，”join”，”complement”，”<”，”>”といった文字列を含むCDSは除外します．つまり，格納すべきCDSの開始位置の情報は，上から順に，1，135，9，200，64，1，になります．|\\
さて\\
\begin{waku}
\begin{verbatim}
     CDS             1..849
\end{verbatim}
\end{waku}\\
\verb|のようなCDSの記述がある行を見つけたら，コード領域開始位置の1を取り出す処理が必要になります．CDS  1..849の1の部分をどうやって取り出すかですが，例えば1の部分をとりあえず$cds_startという変数に格納したい場合は，|\\
\begin{waku}
\begin{verbatim}
   if($_ =~ /^     CDS +([0-9]+)\.\.([0-9]+)/){
       $cds_start = $1;
                    :
                    :
   }
\end{verbatim}
\end{waku}\\
\verb|のようにするといいでしょう．$1は一番目の括弧内にマッチした正規表現，$2は二番目の括弧内にマッチした正規表現という意味になります．したがって$1にはコード領域の開始の位置の情報，$2にはコード領域の終わりの位置の情報（1..849なら849）が入ります．|
\verb|そして，CDSの開始領域をどのように記録していくかを考えなければなりません．CDSは１つのエントリーに複数含まれている場合があるので，格納するのは配列変数にするのがいいでしょう．例えば格納する配列変数が@cds_start_setという名前だとすれば，まず100を@cds_start_setに格納します．次に，|\\
\begin{waku}
\begin{verbatim}
     CDS             135..521
\end{verbatim}
\end{waku}\\
\verb|という行を見つけたら，135をまた@cds_start_setに格納します．この時点で$cds_start_set[0]は1，$cds_start_set[1]は135になるはずです．|\\
さて，実際の格納の手順ですが，push関数を使うことができます．push関数は配列の末尾に新しい要素を加える関数です．例えば，\\
\begin{waku}
\begin{verbatim}
@cds_start_set = (100, 200, 300);
\end{verbatim}
\end{waku}\\
のときに，\\
\begin{waku}
\begin{verbatim}
push(@cds_start_set, 1000);
\end{verbatim}
\end{waku}\\
\verb|とすると，@cds_start_setの要素は，(100, 200, 300, 1000)になります．これをうまく使いましょう．ちゃんとＣＤＳ開始位置の情報が入っているかprint文などを使って確認しながらプログラムを作成しましょう．|
\item{問題\stepcounter{question}\thequestion } ORIGINを見つけたら，まず塩基配列を文字列またはファイルとして格納しましょう（4の部分）．\\
塩基配列を文字列として格納するには，例えば以下のような関数を作り，use strictの直後などに置きます．\\
\begin{waku}
\begin{verbatim}
sub get_sequence {

   my($fh) = @_; #ファイルハンドル
   my $seq = "";
   my $seq_frag;

   while(<$fh>){
      if($_ =~ /^\/\//){ # //を見つけたら，そこで終了
         last;
      }
      else {
         $seq_frag = $_; #読みこんだ行の塩基配列を$seq_fragに格納する．
         $seq_frag =~ s/[^a-z]//g;  # 数字，空白などは削除．
         $seq = $seq . $seq_frag;
            # $seqに配列全体を格納
      }
   }
   return $seq;
}
\end{verbatim}
\end{waku}\\
そして4の適切な箇所で，\\
\begin{waku}
\begin{verbatim}
$seq = &get_sequence(*FILE); #ファイルハンドルを渡す
\end{verbatim}
\end{waku}\\
\verb|のように呼び出すと，$seqには塩基配列が格納されます．この方法は塩基配列がそれほど長くない場合に有効です．しかし，{\it E. coli}のGenBankファイルなど塩基配列が数百万の長さになる場合は，マシンによっては処理に時間がかかってしまいます．そこでこのような場合は，塩基配列だけが書かれているファイルを作成します．|\\
\begin{waku}
\begin{verbatim}
sub save_sequence {

    my($filename, $fh) = @_;
    my($seq_frag);
    local(*SEQFILE);

    open(SEQFILE, "> $filename");
# $filenameという名前のファイルを書きこみ用にオープンする

    while(<$fh>){
        if($_ =~ /^\/\//){
            last;
        }
        else {
            $seq_frag = $_;
            $seq_frag =~ s/[^a-z]//g;
            print SEQFILE $seq_frag;
        }
    }

    close SEQFILE;

}
\end{verbatim}
\end{waku}\\
この関数を\\
\begin{waku}
\begin{verbatim}
&save_sequence(“seq.tmp”,*FILE);
\end{verbatim}
\end{waku}\\
のように呼び出します．ちなみにファイルハンドルを関数の引数として渡すときは，\\
\begin{waku}
\begin{verbatim}
関数名（*ファイルハンドル名）;
\end{verbatim}
\end{waku}\\
で関数を呼び出し，受け取る関数では\\
\begin{waku}
\begin{verbatim}
my $ファイルハンドルを受け取る変数名 = $_[0];
\end{verbatim}
\end{waku}\\
で受け取ります．

\item{問題\stepcounter{question}\thequestion } \verb|塩基配列が入った文字列から@cds_start_setに基づいてＣＤＳ開始領域の塩基配列をみていきましょう（5の部分）．|\\
塩基配列を文字列変数としている場合は，例えばCDSの最初の3文字を表示したい場合は以下のようにするといいでしょう．\\
\begin{waku}
\begin{verbatim}
foreach $cds_start (@cds_start_set){
	  print substr($seq, $cds_start - 1, 3), "\n";
}
\end{verbatim}
\end{waku}\\
また塩基配列をファイルに格納している場合はSEQFILEをopenした後，\\
\begin{waku}
\begin{verbatim}
foreach $cds_start (@cds_start_set){
   seek(SEQFILE, $cds_start - 1, 0);
   read(SEQFILE, $seq, 3);
   print "$seq\n";
}
\end{verbatim}
\end{waku}\\
\verb|とするといいでしょう．あとは，$cds_countや$atg_countを使ってCDSの数やatgの数を数えていくだけです．|

\item{問題\stepcounter{question}\thequestion } CDS開始領域情報の初期化を行いましょう（2の部分）．\\
\verb|CDS開始領域情報は@cds_start_setなので，|\\
\begin{waku}
\begin{verbatim}
@cds_start_set = ();
\end{verbatim}
\end{waku}\\
でいいでしょう．

\item{問題\stepcounter{question}\thequestion } 問題15〜18を完成させ，コード領域（CDS）がATGで始まる割合を求めるPerlプログラムを作成しましょう．
\footnote{真核生物の場合，CDSの開始はほとんどATGです．ATGで始まらないエントリーは，CDSの一部の領域しか登録されていないか，CDSが偽遺伝子，データベースのエラーというものがほとんどです．原核生物ではCDSがATGから始まらない例が数多く知られています．}
\end{description}

\subsection{相補鎖の処理}\index{そうほさ@相補鎖}
\begin{description}
\item{解説} DNAは二重らせん構造をしています．そしてAの反対側にはTが，Cの反対側にはGが結合しています．反対側に結合しているDNA鎖を相補鎖と呼びます．\\
\begin{waku}
……ctagctagctagtgcatgtga……
……gatcgatcgatcacgtacact……   ←相補鎖
\end{waku}\\
遺伝子は相補鎖の方にコードされていることもあります．例えば以下の例では，下線の部分に遺伝子がコードされています．\\
\begin{waku}
………ggaggcttagcgtagcatcgt…………gcatatcgtacgcatatgatg…… GenBankに載っている配列
………cctccg\underline{aatcgcatcgtagca…………cgtatagcatgcgta}tactac…… 相補鎖
\end{waku}\\
この場合，GenBankの記述は以下のようになります．\\
\begin{waku}
\begin{verbatim}
CDS             complement(100..402)
\end{verbatim}
\end{waku}\\
相補鎖を扱うときには，まず塩基配列を逆向きにして，次にA→T，T→A，C→G，G→Cの変換を行わなければなりません．この相補鎖の扱いを課題を通して学びましょう．
\item{問題\stepcounter{question}\thequestion } {\it E. coli}のゲノムにおいて，各コード領域（CDS）の塩基配列を切り出し，配列変数に格納してゆき，最後にCDS配列を出力しましょう．このGenBankファイル(ecoli.gbk)には，LOCUSは1つしか含まれていません．\\\\
CDSの塩基配列を切り出すプログラムの骨組みは大体以下のようになります．\\
\begin{waku}
\begin{verbatim}
open(FILE, "ecoli.gbk")
|| die "Cannot open GenBank file : $! \n"; # エラー処理

while($_ = <FILE>){
    chomp;
    #1
    #2
}
close FILE;
#3
#4
\end{verbatim}
\end{waku}\\
以下の処理を1〜4の場所で行います．
\begin{enumerate}
\item \verb|“CDS”を発見したら，その開始位置と終了位置を配列変数（@cds_start_setと@cds_end_set）に格納する．|
\item \verb|“ORIGIN” を発見したら，全塩基配列を変数$seqに追加していく（'//'まで繰り返す）．|
\item \verb|各CDSの塩基配列を，その開始位置と終了位置の情報に基づき，$seqに格納されている全塩基配列から切り出し，@cds_seqに格納する．|
\item 結果の出力．
\end{enumerate}
以下の変数が必要になるでしょう．
\begin{description}
\item{\verb|$ncds|} CDSの数をカウントする（CDSに番号をつける）
\item{\verb|@cds_start_set|} 各CDSの開始位置を記憶する
\item{\verb|@cds_end_set|} 各CDSの終了位置を記憶する
\item{\verb|$seq|} 全塩基配列を格納する
\item{\verb|@cds_seq|} 各CDSの塩基配列を格納する
\end{description}

1〜4のステップについて，具体的にどのようにプログラムを書けばいいのか説明します．\\\\
1. \verb|まず，'CDS'を発見したら，@cds_start_setと@cds_end_setに位置を格納し，$ncdsの値を１つ増やします．|\\
\begin{waku}
\begin{verbatim}
if($_ =~ /^     CDS\D+(\d+)\.\.(\d+)/){
    $cds_start_set[$ncds] = $1; # @cds_start_setに開始位置を格納
    #ここは考えましょう; # @cds_end_setに終了位置を格納
    $ncds ++; # $ncdsをインクリメント
}
\end{verbatim}
\end{waku}\\

2. \verb|次に，'ORIGIN' を発見したら，全塩基配列を変数$seqに追加していきます（'//'まで繰り返す）．|\\
\begin{waku}
\begin{verbatim}
if($_ =~ /^ORIGIN/){
    while(<FILE>){
        #ここは考えましょう; # '//'にマッチしたら，while文を抜ける
        $_ =~ s/[^a-z]//g; # アルファベット以外の文字は削除（''に置換）
        $seq = $seq . $_; # $seqと$_を連結したものを$seqに代入
    }
}
\end{verbatim}
\end{waku}\\

3. \verb|そして，各CDSの塩基配列を，$seqから切り出し，@cds_seqに格納します．文字列から一部分を切り出すには，substr関数を使います．|\\
\begin{waku}
\begin{verbatim}
for($i = 0; $i < $ncds; $i ++){
    $cds_seq[$i] = substr($seq, $cds_start_set[$i] - 1, 
    $cds_end_set[$i] - $cds_start_set[$i] + 1);
}
\end{verbatim}
\end{waku}\\

4. \verb|最後に，CDS番号(1番目のCDS〜)と塩基配列を出力しましょう．for文を使えば簡単ですね．|
\item{問題\stepcounter{question}\thequestion } 相補的な塩基配列を求める機能を先ほどのプログラムに組み込みましょう．
\verb|先ほど説明した通り，'complement'というキーワードは，タンパク質をコードするDNA塩基配列情報が相補鎖の方にあることを意味します．そこで，@complementという配列変数を用意し，'complement'があったら1（真）を，なかったら0（偽）を記憶しておきます．こうしておくと，後の処理で@complementを参照すれば，相補鎖に変換するCDSとそうでないCDSを識別できます．|\\
\begin{waku}
\begin{verbatim}
if($_ =~ /^     CDS/){
    if($_ =~ / +complement\((\d+)\.\.(\d+)/){ 
        #ここは考えましょう; 
        # @complementに1を追加
    }
    elsif($_ =~ / +(\d+)\.\.(\d+)/){
        #ここは考えましょう; 
        # @complementに0を追加
    }
    $cds_start_set[$ncds] = $1;
    #ここは考えましょう; 
    # CDS終了位置の記録
    $ncds ++;
}
\end{verbatim}
\end{waku}\\
さらに，各CDSの塩基配列を引数で渡すと，その相補鎖を返してくれる関数を作ると便利です．\\
\begin{waku}
\begin{verbatim}
sub complemental(){ 
    my $seq = $_[0]; 
    my $complement; 
    #ここは考えましょう; # 配列を逆順にする処理
    #ここは考えましょう; # A→T，G→Cといったように相補塩基を当てはめる処理
    return $complement; 
}
\end{verbatim}
\end{waku}\\
\verb|reverseは，文字列を逆順にしたものを返す関数です．例えば，$a = reverse("top"); としてやると，$aに"pot"が入ります．また，相補塩基を当てはめるには，tr/// を使うと便利です．tr/// は一文字置換の関数ですが，特定の文字がきたら特定の文字に，という複数の条件を一文で書き表すことができます．つまり， |\\
\begin{waku}
\begin{verbatim}
$seq =~ tr/atgc/tacg/; 
\end{verbatim}
\end{waku}\\
と書くだけで，aをtに，gをcに置換してくれます．\\\\
\verb|あとは2問題20の4を改良し，@cds_seqの中身を出力します．このとき@complementの値が0のときはそのままで，1のときはcomplemental関数にかけてから，出力します．|
\end{description}

\subsection{塩基の計数}
\begin{description} 
\item{解説} ここでは，{\it E. coli}のゲノムにおける塩基組成\index{えんきそせい@塩基組成}を調べましょう．（GenBankファイルは，ecoli.gbk）
\item{問題\stepcounter{question}\thequestion } 各CDSにおける各塩基の度数を求めましょう．
\item{問題\stepcounter{question}\thequestion } 全CDSにおける各塩基の度数（全CDSの集計値）を求めましょう．
\item{問題\stepcounter{question}\thequestion } 全CDSにおける各塩基の相対度数（総塩基数に対する各塩基の度数の比率）を求めましょう．
\\\\
問題22では，a,c,g,tのそれぞれについて各CDSの数をカウントします．\\
文字列操作関数であるtr///は，s///とは違い，置き換えた文字数を返します．例えば，\\
\begin{waku}
\begin{verbatim}
$i = $str =~ tr/a-z/A-Z/;
\end{verbatim}
\end{waku}\\
\verb|とすると，$str中の文字列を検索し，a-z中に含まれる文字を見つけると，A-Z中の対応する位置の文字に置換し（つまりアルファベットの小文字を大文字に置換し），置換した文字数を$iに代入します．これを利用して|\\
\begin{waku}
\begin{verbatim}
$a = $seq =~ tr/a/a/; 
\end{verbatim}
\end{waku}\\
と同じ文字を代入することにより，その文字の数をカウントすることができます． \\
生物種によっては，CDS内にa,c,g,t以外の文字が含まれるケースがあります．このようなケースでは，CDSの総文字数とa,c,g,tの総数とは一致しません．これは，\\
\begin{waku}
\begin{verbatim}
$others = length($seq) - ($a + $c + $g + $t); 
\end{verbatim}
\end{waku}\\
\verb|とすることにより確認できます．length($seq)は，$seqの中の文字数を返します．|\\
\\
問題23では，a,c,g,tのそれぞれについて，全CDSの数を集計します．\\
例えば，aの数を集計するには，for文の中で以下の処理を行います．\\
\begin{waku}
\begin{verbatim}
$a += $seq =~ tr/a/a/; 
\end{verbatim}
\end{waku}\\
\\
問題24では，a,c,g,tのそれぞれについて，度数を比率に変換します．\\
小数の出力は，printの場合，小数点以下8桁くらいまで表示されて見にくいので，printfを使って整形しましょう．\\
\begin{waku}
\begin{verbatim}
printf("%.3f %.3f %.3f %.3f", $pr_a, $pr_c, $pr_g, $pr_t); 
\end{verbatim}
\end{waku}\\
%とfの間に.3を入れると，小数点以下第三位まで表示という意味になります．同様に，.4を入れると小数点以下第四位までとなります．なお，一つ下の桁は四捨五入されます．
\end{description}

\subsection{コドンの計数}\index{こどん@コドン}
\begin{description}
\item{解説} コード領域（CDS）の塩基配列は遺伝子発現時にコドンと呼ばれる３塩基の単位でアミノ酸配列に翻訳されます．ここでは，{\it E. coli}のゲノムにおけるコドン組成を調べましょう．
\item{問題\stepcounter{question}\thequestion } 各CDSにおける各コドンの度数を求めましょう．
\item{問題\stepcounter{question}\thequestion } 全CDSにおける各コドンの度数（全CDSの集計値）を求めましょう．
\item{問題\stepcounter{question}\thequestion } 全CDSにおける各コドンの相対度数（総コドン数に対する各コドンの度数の比率）を求めましょう．
\\\\
問題25では，各CDSで使用されるコドンをそれぞれ計数します．\\
\verb|コドンは3連続塩基ですので1文字置換をするtr///を使って数えることはできません．複数置換のs///では置換された数を返さないのでこれを使うこともできません．しかたがないので，ここではfor文を使って3文字づつ読んでいきましょう．ここでは塩基配列の最初から3文字の単位で読むのですから，例えば"atgcggctg"という塩基配列なら1つ目のコドンが"atg"，2つ目のコドンが"cgg"，3つ目のコドンが"ctg"というようになります．つまり，これは [1文字目] から [配列の長さ-2文字目] までfor文で繰り返すことになります．ここで注意しなければいけないことは，Perlでは先頭の番号は1ではなく0から始まる点です．つまり，for文で繰り返す場合は[0文字目]から[配列の長さ-3文字目]までとなります．|\\
\begin{waku}
\begin{verbatim}
for($p = 0; $p <= length($seq) - 3; $p += 3){
	# 処理
}
\end{verbatim}
\end{waku}\\
コドンを切り出すには，substr()関数を使います． \\
\begin{waku}
\begin{verbatim}
$codon = substr($seq, $p, 3);
\end{verbatim}
\end{waku}\\
各コドンの計数にはハッシュをうまく利用してください．ハッシュの引数は文字列（この場合，１コドン）でいいので， \\
\begin{waku}
\begin{verbatim}
$count{$codon}++;
\end{verbatim}
\end{waku}\\
\verb|としてやることで，$codonの中身が何であるかを気にせずにカウントすることができます．|\\
\\
問題26では，各コドンについて，全CDSの数を集計します．\\
全CDSの数を集計するには，for文の中で問題25の処理を行えばいいですね．\\
\begin{waku}
\begin{verbatim}
for($i = 1; $i <= $ncds; $i ++){
	# 問題25の処理
}
\end{verbatim}
\end{waku}\\
\\
問題27では，各コドンについて，度数を比率に変換します．\\
\verb|$totalに全コドンの総度数を記憶しておけば，以下の処理で求めることができます．|\\
\begin{waku}
\begin{verbatim}
foreach (keys %count){
    $proportion{$_} = $count{$_} / $total;
}
\end{verbatim}
\end{waku}
\end{description}

\subsection{アミノ酸配列の処理}\index{あみのさん@アミノ酸}
\begin{description}
\item{解説} CDS領域の塩基配列が実際にどのようなアミノ酸配列になるかという情報はCDSのセクションのtranslationというところに書かれています．ここでは，{\it E. coli}のゲノムにおけるアミノ酸組成を調べましょう．\\
\begin{waku}
\begin{verbatim}
CDS             72..371  ←コード領域
                /codon_start=1
                /product="pre-apolipoprotein CIII" ←コードされているタンパク質名
                /db_xref="PID:g28728"        ↓コードされているアミノ酸配列
                /translation="MQPRVLLVVALLALLASARASEAEDASLLSFMQGYMKHATKTAK
                DALSSVQESQVAQQARGWVTDGFSSLKDYWSTVKDKFSEFWDLDPEVRPTSAVAA"
\end{verbatim}
\end{waku}

\item{問題\stepcounter{question}\thequestion } 各CDSのアミノ酸配列を切り出し，その長さを出力しましょう．
\\\\
まず/translation=""の中身を切り出すことを考えましょう．プログラムの骨組みは以下のようになります．\\
\begin{waku}
\begin{verbatim}
my $ncds;		# CDSの数
my @translation;	# 各CDSのアミノ酸配列
my $tmp;
my $i;
my $GBKfile = 'mgen.gbk';

open(FILE, $GBKfile)|| die"cannot open GBKFile : $! \n";

while(<FILE>){
    chomp;
    $ncds ++ if(/^     CDS/);
    if($_ =~ /\/translation=\"([^\"]+)\"/){ # 一行で終わるケース
	#ここは考えましょう;
    }
    elsif($_ =~ /\/translation=\"([^\"]+)/){ # 複数行にわたるケース
	#ここは考えましょう;
    }
}
close FILE;
\end{verbatim}
\end{waku}

条件分岐と正規表現\\
以下のような/translation=""の中身が一行に収まるケースと，それが複数行にわたるケースの両方に対応するために，ifとelsifを使って条件分岐を行います．\\
a) /translation=""の中身が一行に収まるケース\\
\begin{waku}
\begin{verbatim}
/translation="MENILDLWNQALAQIEKKLSKPSFETWMKSTKAHSLQ"
\end{verbatim}
\end{waku}\\

b) /translation=""の中身が複数行にわたるケース\\
\begin{waku}
\begin{verbatim}
/translation="MAPARTMARARLAPAGIPAVALWLLCTLGLQGTQAGPPPAPPGL
    PAGADCLNSFTAGVPGFVLDTNASVSNGATFLESPTVRRGWDCVRACCTTQNCNLALV
    ELQPDRGEDAIAACFLINCLYEQNFVCKFAPREGFINYLTREVYRSYRQLRTQGFGGS
    GIPKAWAGIDLKVQPQEPLVLKDVENTDWRLLRGDTDVRVERKDPNQVELWGLKEGTY
    SFVYGGCLGNKNNYLREEECILACRGVQGPSMERRHPVCSGTCQPTQFRCSNGCCIDS
    AVAVFLVICIVVVVAILGYCFFKNQRKDFHGHHHHPPPTPASSTVSTTEDTEHLVYNH
    TTRPL"
\end{verbatim}
\end{waku}\\
つまり，以下の構文を考えればいいわけです．\\
\begin{waku}
\begin{verbatim}
if($_ =~ /正規表現1/){ 
    #ここは考えましょう;
 }
elsif($_ =~ /正規表現2/){ 
    #ここは考えましょう;
}
\end{verbatim}
\end{waku}\\
まず一行に収まるケースですが，正規表現を使って\\
/translation="(ダブルクォーテーションを除く文字列の１文字以上の連続)"\\
にマッチするものを検索するには，以下のようにすればいいでしょう．\\
\begin{waku}
\begin{verbatim}
if($_ =~ /\/translation=\"([^\"]+)\"/)
\end{verbatim}
\end{waku}\\
\verb|/や"を正規表現文字ではなく，単なる文字として使いたいときには，その文字の前にエスケープ文字\を付ける必要があります．また，[^c]は，c以外の1文字にマッチします．|\\
\\
\verb|そして，(  )で囲んだ部分を，$1で取り出して，@translationに格納します．if文においては，以下の処理を行います．|\\
\begin{waku}
\begin{verbatim}
$translation[$ncds] = $1;
\end{verbatim}
\end{waku}\\
\\
\verb|複数行にわたるケースでは(elsif文の処理)，文字列を連結する処理が必要になります．まず，$1をとりあえず$tmpに格納します．そして，1行読み込むたびに，それを$tmpに連結します．|\\
\begin{waku}
\begin{verbatim}
	$tmp = $1;
	while(<FILE>){
	    $tmp = $tmp . $_; # $tmpと$_を連結したものを$tmpに代入する
	    if(/\"/){ last; } # "にマッチしたら，while文を抜ける
	}
\end{verbatim}
\end{waku}\\
\verb|次に，スペースや"を取り除いた後，$tmpを@translationに代入します．|\\
\begin{waku}
\begin{verbatim}
	$tmp=~ s/\"|\s+//g;	# 1文字以上続くスペースや"を削除（''に置換）
	$translation[$ncds] = $tmp;
\end{verbatim}
\end{waku}\\

\item 最後に結果を出力します．アミノ酸配列の長さは，lengthを使えば調べられますね．

\item{問題\stepcounter{question}\thequestion } CDS毎に各アミノ酸の度数を求めましょう．\\
\verb|まず，@translationの各要素に文字列として格納されているアミノ酸配列を，1文字づつに分割し，配列変数に代入します．文字列を分割するには，split関数を使います．|\\
\\
\begin{waku}
\begin{verbatim}
split(/正規表現/, $variable);
\end{verbatim}
\end{waku}\\
\verb|split関数は，指定した正規表現にマッチした文字列をセパレータとして，分割した文字列のリストを返します．以下のように，セパレータをヌル文字列（空文字列）にすれば，1文字ずつに分割されます．例えば$translation[$i]が”SLQ”の場合，@amino_seqは(“S”, “L”, “Q”)になります．|\\
\begin{waku}
\begin{verbatim}
@amino_seq = split(//,$translation[$i]);
\end{verbatim}
\end{waku}\\
ここで，$translation[$i]は，$i番目のCDSのアミノ酸配列を意味します．\\
\\
次に，foreach文において各アミノ酸の使用回数をカウントします．\\
\begin{waku}
\begin{verbatim}
foreach $amino (@amino_seq){
    $count{$amino} ++;
}
\end{verbatim}
\end{waku}\\
ここではハッシュをうまく利用しています．ハッシュの引数は文字列（この場合，１アミノ酸）でいいので，\\
\begin{waku}
\begin{verbatim}
$count{$amino} ++;
\end{verbatim}
\end{waku}\\
とすることで，アミノ酸$aminoの数をカウントすることができます
\end{description}

\subsection{機能注釈情報の利用}\index{きのうちゅうしゃくじょうほう@機能注釈情報}\index{あのてーしょん@アノテーション}
\begin{description}
\item{解説} CDSの/geneには遺伝子名，/productには遺伝子産物（コードされているタンパク質）に関する情報が書かれています．これを利用することによって例えば特定のタンパク質をコードする配列のみを抽出することなどが可能です．\\
\item{問題\stepcounter{question}\thequestion } {\it E. coli}のゲノムにおける各コード領域（CDS）のgene名とproduct名を表示しましょう．\\
/gene=""および/product=""の中身を切り出します．問題28が参考になるでしょう．プログラムの骨組みを以下に示します．\\
\begin{waku}
\begin{verbatim}
while(<FILE>){
    chomp;
    if(/^     CDS/){ $ncds ++; }
    if($translation[$ncds] eq ''){
if($_ =~ /\/gene=\"([^\"]+)\"/){
	    #ここは考えましょう; # /gene=""の中身を配列変数に格納
	}
	if($_ =~ /\/product=\"([^\"]+)\"/){
	    $product[$ncds] = $1;
	}
	elsif($_ =~ /\/product=\"([^\"]+)/){
	    #ここは考えましょう; # /product=""の中身を配列変数に格納
	}
	if($_ =~ /\/translation=\"([^\"]+)\"/){
	    $translation[$ncds] = $1;
	}
	elsif($_ =~ /\/translation=\"([^\"]+)/){
	    #ここは考えましょう; # /translation=""の中身を配列変数に格納
	}
    }
}
#ここは考えましょう; # 結果の出力
\end{verbatim}
\end{waku}\\
なお，下の例では，gene名はrpmF，product名は50S ribosomal protein L32です．\\
\begin{waku}
\begin{verbatim}
     CDS             1146590..1146763 
                     /gene="rpmF" 
                    (中略) 
                     /product="50S ribosomal protein L32" 
\end{verbatim}
\end{waku}\\
\verb|while文の前で$ncds = -1としておくと，@translationや@geneには0番目から文字列が入ります．|\\

\item{問題\stepcounter{question}\thequestion } リボソームタンパクをコードする遺伝子のみ表示されるように問題30のプログラムを改良しましょう．\\
\\
product名がリボソームタンパクを意味するものを正規表現で検索します．\\
まず，gbkファイルにおいて，リボソームタンパクがどのように記載されているのかを調べましょう．以下のフォルダに移動してください．\\
\begin{waku}
\begin{verbatim}
cd bacteria/
\end{verbatim}
\end{waku}\\
grepコマンドを利用し，ribosomalの文字列を含んでいる行を検索します．ワイルドカードを用いれば，複数のgbkファイルを指定できます．\\
\begin{waku}
\begin{verbatim}
% grep ribosomal */*.gbk | less
\end{verbatim}
\end{waku}\\
/product="の行を見てください．\\
"ribosomal protein"，"ribosomal subunit protein"，"RIBOSOMAL PROTEIN"\\
など生物種によってリボソームタンパクの記述の仕方が異なります．これらにマッチするようにするためには例えば，以下のような正規表現を使うといいでしょう．\\
\begin{waku}
\begin{verbatim}
/ribosomal.*protein/i
\end{verbatim}
\end{waku}\\
\verb|.*は，どのような文字列にもマッチします．オプションiを付けると，パターンマッチのときにアルファベットの大文字と小文字を区別しません．|

\item{問題\stepcounter{question}\thequestion } リボソームタンパク遺伝子群における各アミノ酸の度数（集計値）を求めましょう．\\
\verb|@rpという配列変数を用意し，/product=""の中身がリボソームタンパクであれば1（真）を，そうでなければ0（偽）を記憶しておけば，リボソームタンパクをコードするCDSとそうでないCDSを識別できるので，後ほど@rpを参照することにより前者だけを対象として処理を行うことができます．|
\end{description}

\subsection{応用課題}
\begin{description}
\item{解説} ＤＮＡの転写される部分で捨てられる（スプライスアウト）部分をintronといい，残る部分をexonといいます．GenBankではintronの場所の記述は\\
\begin{waku}
\begin{verbatim}
     exon            3066..3157
                     /gene="gamma-globin"
     intron          3158..3280
     exon            3281..3503
                     /gene="gamma-globin"
     intron          3504..4392
     exon            4393..4521
                     /gene="gamma-globin"
\end{verbatim}
\end{waku}\\
となっています．\\
\item{問題\stepcounter{question}\thequestion } exon/intronの境界領域の配列を出力するプログラムを書きましょう．intron開始部位にはどのような配列が多く見られますか？酵母のComplete Genomeのデータを取得し，調べてみましょう．
\item{問題\stepcounter{question}\thequestion } 同様にintron/exonの境界領域の配列を出力するプログラムを書きましょう．intron終了部位にはどのような配列が多く見られますか？
\end{description}

\chapter{Appendix}
\section{解答}
\subsection*{第2章 Perl入門}
\begin{description}
\item{問題\stepcounter{question}\thequestion }  printは文字列だけでなく，式の結果も出力することができます．なので解答としては以下で十分です．\\
\begin{waku}
\begin{verbatim}
 print "123x456=";
 print 123*456;
 print "\n";
\end{verbatim}
\end{waku}\\
カンマ(,)を利用してまとめても良いでしょう．\\
\begin{waku}
\begin{verbatim}
 print "123x456=", 123*456, "\n";
\end{verbatim}
\end{waku}\\
もちろん変数を使ってもOKです．\\
\begin{waku}
\begin{verbatim}
 $hoge = 123*456;
 print "123x456=$hoge\n";
\end{verbatim}
\end{waku}

\item{問題\stepcounter{question}\thequestion } \verb|イコール(=)がPerlでは代入を意味することに気をつけましょう．後で出てきますが，等しいことを意味する記号はイコールx2(==)です|\\
\begin{waku}
\begin{verbatim}
 $x = 86400;
 $y = 365;
 $z = $x * $y;
 
 print "$z\n";
\end{verbatim}
\end{waku}

\item{問題\stepcounter{question}\thequestion } \verb|三行目で$xに$x+$yの結果を"改めて"代入しています．|\\
\begin{waku}
\begin{verbatim}
 $x = 10;
 $y = 5;
 $x = $x + $y;
 
 print "$x\n"
\end{verbatim}
\end{waku}\\
この場合以下でも良いでしょう．\\
\begin{waku}
\begin{verbatim}
 $x  = 10;
 $y  = 5;
 $x += $y;
 print "$x\n"
\end{verbatim}
\end{waku}

\item{問題\stepcounter{question}\thequestion } \verb|3番目の要素は$array[2]でとってくることに注意．最後の要素にはカンマはつけません.|\\
\begin{waku}
\begin{verbatim}
 @array = (
 	"Sunday",
 	"Monday",	
 	"Tuesday",	
 	"Wednesday",
 	"Thursday",
 	"Friday",
 	"Saturday"
 	);
 
 print "$array[2]\n";
\end{verbatim}
\end{waku}

\item{問題\stepcounter{question}\thequestion } \verb|区切り文字が"-"であることに注意すればOKです．|\\
\verb|ちなみにsplit("pattern", sequence)のところでパターン指定の部分(つまり第一引数)の囲いは""(ダブルクォーテーション)と//(スラッシュ)の二通りがあります．前者がパターンマッチで後者が正規表現です．|\\
\begin{waku}
\begin{verbatim}
 $seq = "Sun-Mon-Tue-Wed-Thr-Fri-Sat";
 @week_array = split "-", $seq;
 
 print "$week_array[2]\n"
\end{verbatim}
\end{waku}

\item{問題\stepcounter{question}\thequestion } \verb|$i = $i+2のところがミソです．|\\
\verb|($i <= 11)のところは($i < 12)等でもかまいません．|\\
\begin{waku}
\begin{verbatim}
 my $i = 1;
 while($i <= 11){
    print "There are $i sheep\n"
    $i = $i+2;
 }
\end{verbatim}
\end{waku}\\
文法が気になる人はこうやっても良いでしょう．\\
\begin{waku}
\begin{verbatim}
 print "There is a sheep\n"
 my $i = 3;
 while($i <= 11){
    print "There are $i sheep\n"
    $i = $i+2;
 }
\end{verbatim}
\end{waku}

\item{問題\stepcounter{question}\thequestion } \verb|"超えるまで出力"がポイントです．|\\
\begin{waku}
\begin{verbatim}
 my $i = 1/2;
 while($i < 100000){
     $i = $i * 2;
     print "$i\n";
 }
\end{verbatim}
\end{waku}\\
あるいは\\
\begin{waku}
\begin{verbatim}
 my $i = 1;
 while($i < 100000){
     print "$i\n";
     $i = $i * 2;
 }
 print "$i\n";
\end{verbatim}
\end{waku}

\item{問題\stepcounter{question}\thequestion } \verb|変数を二つ使います．|\\
\begin{waku}
\begin{verbatim}
 my $i   = 1;
 my $ans = 1;
 while($i <= 15){
     $ans = $ans * $i;
     $i = $i + 2;
 }
 print "$ans\n";
\end{verbatim}
\end{waku}

\item{問題\stepcounter{question}\thequestion } \verb|色々な方法がありますが--を使うとシンプルな解答になります．|\\
\begin{waku}
\begin{verbatim}
 for(my $i = 100; $i > 0; $i --){
     print "$i\n";
 }
\end{verbatim}
\end{waku}\\
もちろんこれでも問題ありません．\\
\begin{waku}
\begin{verbatim}
 for(my $i = 0; $i < 100; $i ++){
     print 100-$i, "\n";
 }
\end{verbatim}
\end{waku}\\
foreachを使ってもできます．\\
\begin{waku}
\begin{verbatim}
 print "$_\n" for reverse 1..100;
\end{verbatim}
\end{waku}

\item{問題\stepcounter{question}\thequestion } \verb|[ ]の中に式が書けることを知っておくと後々役立ちます．|\\
\begin{waku}
\begin{verbatim}
 my @array = (
 	"Sunday",
 	"Monday",	
 	"Tuesday",	
 	"Wednesday",
  	"Thursday",
 	"Friday",
 	"Saturday"
 	);
 
 foreach(1..30){
     print "$_\t$array[$_%7]\n";
 }
\end{verbatim}
\end{waku}\\
あるいは\\
\begin{waku}
\begin{verbatim}
 my @array = (
 	"Sunday",
 	"Monday",	
 	"Tuesday",	
  	"Wednesday",
 	"Thursday",
 	"Friday",
 	"Saturday"
 	);
 
 for(@array){
     print "$_\t";
 }
 print "\n";
 
 for(1..30){
     print "$_\t";
     print "\n" if $_%7 == 0;
 }
\end{verbatim}
\end{waku}\\
以下はPerlらしいコードの例．解読してみてください．\\
\begin{waku}
\begin{verbatim}
 my @array = (
 	"Monday",	
 	"Tuesday",	
  	"Wednesday",
 	"Thursday",
 	"Friday",
 	"Saturday",
 	"Sunday"
 	);
 
 print "$_\t" for @array;
 print "\n";
 print  $_    for map{$_%7?"$_\t":"$_\n"}1..30;
\end{verbatim}
\end{waku}

\item{問題\stepcounter{question}\thequestion } \verb|いわゆる静的なハッシュ作成．|\\
\begin{waku}
\begin{verbatim}
 %login = (
 	matsui => "t03908mm",
 	okada  => "t02176yo"
 	); 
 
 print "matsui\t$login{matsui}\n";
 print "okada\t$login{okada}\n";
\end{verbatim}
\end{waku}

\item{問題\stepcounter{question}\thequestion } \verb|動的なハッシュ作成．エントリーをつけ足していくことができることから"動的"．|\\
\begin{waku}
\begin{verbatim}
 $login{ando} = "t03053fa";
\end{verbatim}
\end{waku}

\item{問題\stepcounter{question}\thequestion } \verb|基本的なハッシュエントリーの出力方法その1．|\\
\begin{waku}
\begin{verbatim}
 foreach my $key (keys %login){
     print "$key\t$login{$key}\n";
 }
\end{verbatim}
\end{waku}\\
\verb|$keyの代わりに$_を使うと略すことができます．つまり|\\
\begin{waku}
\begin{verbatim}
 foreach $_ (keys %login){
     print "$_\t$login{$_}\n";
 }
\end{verbatim}
\end{waku}\\
と\\
\begin{waku}
\begin{verbatim}
 foreach(keys %login){
     print "$_\t$login{$_}\n";
 }
\end{verbatim}
\end{waku}\\
は等価です．

\item{問題\stepcounter{question}\thequestion } \verb|基本的なハッシュエントリー出力方法その2．|\\
\begin{waku}
\begin{verbatim}
 while(my($key, $value) = each %login){
     print "$key\t$value\n";
 }
\end{verbatim}
\end{waku}\\
keysを使う方法はまず全てのkeyを含む配列を作っていました．しかしkeyの数が膨大なときは効率が悪くなります．そのような時はエントリーを一つずつ取り出していくこちらの方法をとるべきでしょう．

\item{問題\stepcounter{question}\thequestion } \verb|例文は以下のスクリプトと同じです．|\\
\begin{waku}
\begin{verbatim}
 #(1)塩基配列を一文字ずつ分解し，@arrayという配列に入れる．
 @array = split '', $seq
 
 #(2)カウント
 foreach my $elm(@array){
     $count{$elm} = $count{$elm} + 1;
 }
 
 #(3)出力
 foreach my $nuc(keys %count){
     print "$nuc\t$count{$nuc}\n";
 }
\end{verbatim}
\end{waku}
\begin{verbatim}
(1)ではまず文字列をより処理しやすい配列に変換しています．
 split '', $seq
とすることで文字列をヌルで切る，つまり一文字ずつ切り分けています．
次に(2)でカウントをしています．$count{}は%countの要素であることに注意．%countのエントリーにないkeyが来たときはvalueと共に新規に登録します．%countのエントリーの内容を１ループごとにたどってみるとよりはっきりするかもしれません．
(3)は出力です．keyとvalueを順に出力しています．
\end{verbatim}

\item{問題\stepcounter{question}\thequestion } \verb|$lineは毎回更新されていることに注意．ループを抜けたとき$lineには最終行の文字列が入っています．|\\
\begin{waku}
\begin{verbatim}
 open FILE, "testfile";
 
 while(<FILE>){
     $line = $_;
 }
 
 print $line;
\end{verbatim}
\end{waku}

\item{問題\stepcounter{question}\thequestion } \verb|改行を除いた後，単にカンマを添えてプリントすればOKです．|\\
\begin{waku}
\begin{verbatim}
 open FILE, "testfile";
 
 while(<FILE>){
     chomp;
     print "$_,";
 }
\end{verbatim}
\end{waku}\\
最後のカンマが気になる場合，.(ドット演算子)をうまく使うとよいでしょう．\\
\begin{waku}
\begin{verbatim}
 open FILE, "testfile";
 
 while(<FILE>){
     chomp;
     $seq .= "$_,";
 }
 
 chop $seq;
 print "$seq\n";
\end{verbatim}
\end{waku}\\
\verb|chompは文字列の最後の文字が改行(\n)か否かを判定して改行なら切り取る演算子でした．それに対してchopは最後の文字を無条件に切り取る演算子です．printの前にこの関数を置いておくことで余計なカンマ(,)を除外しています．以下に示すのはchompのイメージです．|\\
\begin{waku}
\begin{verbatim}
 sub chomp{
     $seq = shift;
     chop   $seq if substr($seq, -1, 1) eq "\n";
     return $seq;
 }
\end{verbatim}
\end{waku}

\item{問題\stepcounter{question}\thequestion } \verb|splitを使って一行ずつ配列に分割し，配列の1番目→0番目と表示すればOKです．|\\
\begin{waku}
\begin{verbatim}
 open FILE, "fruit.txt";
 
 while(<FILE>){
     chomp;
     @line = split;
     print "$line[1]\t$line[0]\n";
 }
printfを使うと簡単になります．
 open FILE, "fruit.txt";
 printf "%s\t%s\n", (split)[0,1] while <FILE>;
\end{verbatim}
\end{waku}

\item{問題\stepcounter{question}\thequestion } \verb|"ディレクトリの中にあるファイルを全て処理対象にする"，といった作業はよくでてきますのでマスターしておいてください．openの代わりにopendirとreaddirを使っていることに注意．opendirとreaddirはセットで使います．|\\
\begin{waku}
\begin{verbatim}
 $dir = "./";
 opendir DIR, $dir;
 @dir = readdir DIR;
 
 foreach(@dir){
     $file = $dir.$_;
     open FILE, $file or next;
     while(<FILE>){
         print;
     }
 }
\end{verbatim}
\end{waku}

\item{問題\stepcounter{question}\thequestion } \verb+||を使うと問題の意図を達成できます．+\\
\begin{waku}
\begin{verbatim}
 for(1..100){
     $rand   = int(rand(10)) || "ZERO";
     print "$rand\n";
 }
\end{verbatim}
\end{waku}\\
ただし以下の式自体は0〜9の整数を返すことに注意してください(10は返さない).\\
\begin{waku}
\begin{verbatim}
$rand = int(rand(10));
\end{verbatim}
\end{waku}\\
また\\
\begin{waku}
\begin{verbatim}
 $hoge ||= "hoge";
\end{verbatim}
\end{waku}\\
で0や未定義値のチェックを行うことができます．割り算を含むプログラムなどではこのようなケアは必須です．

\item{問題\stepcounter{question}\thequestion } \verb|a..zでaからｚまで26文字のリストを表します．|\\
\begin{waku}
\begin{verbatim}
 foreach my $chr(a..z){
     $alphabet = $alphabet . $chr;
 }
 $alphabet = $alphabet x 10;
 print "$alphabet\n";
\end{verbatim}
\end{waku}\\
短く書くとこんな感じ．\\
\begin{waku}
\begin{verbatim}
 $alphabet .= $_ for a..z;
 $alphabet x= 10;
 print "$alphabet\n";
\end{verbatim}
\end{waku}\\

\item{問題\stepcounter{question}\thequestion } \verb|大きさを比較すればよいので何らかの比較演算子を使うことになります．普通の演算子を使うと以下のようになります．|\\
\begin{waku}
\begin{verbatim}
 $first  = int(rand 10);
 $second = int(rand 10);
 
 if( $first < $second ){
     print "$first\t<\t$second\n";
 }
 elsif($first > $second){
     print "$first\t>\t$second\n";
 }
 else{
     print "$first\t=\t$second\n";
 }
\end{verbatim}
\end{waku}\\
\verb|<=>は左辺が大きければ1を右辺が大きければ-1を等しければ0を返します．これを利用しても良いでしょう．表示を上を揃えたければあらかじめハッシュを用意しておけば良いでしょう．|\\
\begin{waku}
\begin{verbatim}
 %kigou = (
     -1 => '<',
      0 => '=',
      1 => '>'
 );
 $first  = int(rand 10);
 $second = int(rand 10);
 
 $judge  = ($first <=> $second);
 print "$first\t$kigou{$judge}\t$second\n";
\end{verbatim}
\end{waku}

\item{問題\stepcounter{question}\thequestion } \verb|閏年のルール(グレゴリオ暦)|\\
\begin{waku}
\begin{verbatim}
 1．4で割り切れる年は閏年
 2. しかし100で割り切れた場合閏年ではない
 3. ただし400で割り切れたら閏年
\end{verbatim}
\end{waku}\\
 例えば2000年は閏年でした．\\
素直にコーディングすればこうなるでしょう．\\
\begin{waku}
\begin{verbatim}
 $year = 2004;
 
 if($year % 4 == 0){
 　　if($year%400 == 0){
         print "leapyear\n";    
     }
     elsif($year%100){
         print "not leapyear\n";
     }
     else{
         print "leapyear\n";
     }
 }
 else{
     print "not leapyear\n";
 }
\end{verbatim}
\end{waku}\\
フラッグを使うという手もあります．\\
\begin{waku}
\begin{verbatim}
 $year = 2004;
 
 $flag = 0;
 if($year % 4 == 0){
     $flag = 1;
 　　if($year%400 != 0 && $year%100 == 0){
         $flag = 0;
     }
 }
 
 if($flag){
     print "leapyear\n";    
 }
 else{
     print "not leapyear\n";    
 }
\end{verbatim}
\end{waku}\\
条件をまとめるとこんな感じです．\\
\begin{waku}
\begin{verbatim}
 if($year%400 == 0 || $year%4 == 0 && $year%100 != 0){
         print "leapyear\n";    
 }
 else{
     print "not leapyear\n";    
 }
\end{verbatim}
\end{waku}

\item{問題\stepcounter{question}\thequestion } \verb|まず|\\
\begin{waku}
\begin{verbatim}
 while(<FILE>){
     処理；
 }
\end{verbatim}
\end{waku}\\
の原型は\\
\begin{waku}
\begin{verbatim}
 while($_ = <FILE>){
     処理；
 }
\end{verbatim}
\end{waku}\\
であることを確認しましょう．\\
\verb|<>は次の行を読み込む演算子です．例えば|\\
\begin{waku}
\begin{verbatim}
 hoge\
 piyo
 foo\
 bar
\end{verbatim}
\end{waku}\\
という文があったときループごとに仕事を追ってくと\\
\begin{waku}
\begin{verbatim}
1.ifに入る．次を読み込み今の行と結合．
 	hogepiyo
 	foo\
 	bar
 	となってredoによって改めて一行目の処理に向かう
2.ifに入らずprint
3.二行目を読み込みifに入る．次を読み込み今の行と結合．
 	hogepiyo
 	foobar
 	となる
4.ifに入らずprint
5.次の行が無いのでループを抜ける
\end{verbatim}
\end{waku}\\
これはnext等では実装できません．\\
redoは以下のようなパターンのデータをパースするときに良く使います．\\
\begin{waku}
\begin{verbatim}
 A-	ab
 B-	c
  	d
  	e
 C-	f
 ↓
 %data = (
 	A => "ab",
 	B => "cde",
 	C => "f"
 	);
\end{verbatim}
\end{waku}\\
そのパーサ例\\
\begin{waku}
\begin{verbatim}
 #!/usr/bin/perl
 
 open FILE, $ARGV[0];
 while(<FILE>){
     if(/-/){
         $next = <FILE>;
         if($next =~ /-/ || !$next ){
             @line    = split '- ';
             $line[1] =~ s/[^a-zA-Z]//g;
             $data{$line[0]} = $line[1];
             $_   = $next;
             redo;
         }
         else{
             $_  .= $next;
             redo;
         }
     }
 }
 
 printf "%s\t%s\n", $_, $data{$_} for keys %data;
\end{verbatim}
\end{waku}

\item{問題\stepcounter{question}\thequestion } \verb|先ほどの解答を単に構文に落とせば完成です．|\\
\begin{waku}
\begin{verbatim}
 ($year%400 == 0 || $year%4 == 0 && $year%100 != 0)?
 print "leapyear\n":
 print "not leapyear\n";    
\end{verbatim}
\end{waku}\\
三項演算子を重ねても良いでしょう．\\
\begin{waku}
\begin{verbatim}
 ($year%400 == 0)?print "leapyear\n":
 ($year%100 != 0)?print "not leapyear\n":
 ($year%4   == 0)?print "leapyear\n":
                  print "not leapyear\n";
\end{verbatim}
\end{waku}\\
if文を使えばあらゆる条件分岐は表現できるので三項演算子は必須のものではないのですが，コードを見やすく短く済ませたいときに有効です．

\item{問題\stepcounter{question}\thequestion } \verb|正規表現の典型的な問題です．まずatgがあるかどうかを調べるときは|\\
\begin{waku}
\begin{verbatim}
 $seq = "agtgctagtcgtgtagctactacgtacgt";
 if($seq =~ /atg/){
     print "ATG codon exists in \$seq";
 }
 else{
     print "ATG codon don't exists in \$seq";
 }
\end{verbatim}
\end{waku}\\
です．同様に終止コドン(tag/tga/taa)があるかどうかを調べるときは\\
\begin{waku}
\begin{verbatim}
 $seq = "agtgctagtcgtgtagctactacgtacgt";
 if($seq =~ /tag/ || $seq =~ /tga/ || $seq =~ /taa/){
     print "ATG codon exists in \$seq";
 }
 else{
     print "ATG codon don't exists in \$seq";
 }
\end{verbatim}
\end{waku}\\
もう少し効率よくやるならば\\
\begin{waku}
\begin{verbatim}
 $seq = "agtgctagtcgtgtagctactacgtacgt";
 if($seq =~ /t(ga|a[ga])/){
     print "It matches.";
 }
 else{
     print "It doesn't match";
 }
\end{verbatim}
\end{waku}\\
これらをあわせれば解答は完成です．\\
\begin{waku}
\begin{verbatim}
 $seq = "agtgctagtcgtgtagctactacgtacgt";
 if($seq =~ /atg/ && $seq =~ /t(ga|a[ga])/){
     print "It matches.";
 }
 else{
     print "It doesn't match";
 }
\end{verbatim}
\end{waku}\\
ちなみに拡張正規表現を用いればこの解答は\\
\begin{waku}
\begin{verbatim}
 $seq = "agtgctagtcgtgtagctactacgtacgt";
 if($seq =~ /^(?=.*atg)(?=.*t(ga|a[ga]))/){
     print "It matches.";
 }
 else{
     print "It doesn't match";
 }
\end{verbatim}
\end{waku}\\
\verb|となります．(?=...)は先読み条件です．|\\
\begin{waku}
\begin{verbatim}
 /foo(?=bar)/
\end{verbatim}
\end{waku}\\
で後ろにbarを伴うfooにだけマッチします．先の解答はつまり行頭の後ろに何文字かおいてatgがあるし，同様に終止コドンもある，という条件を満たすことになります．

\item{問題\stepcounter{question}\thequestion } \verb|後方参照の練習です．|\\
\begin{waku}
\begin{verbatim}
 @nuc = ('a', 't', 'c', 'g');
 for(1..300){
     $seq .= $nuc[int(rand 4)];
 }
 
 while($seq =~ /([atgc]{6})atg([atgc]{6})/g){
     print "$1\t$2\n";
 }
\end{verbatim}
\end{waku}

\item{問題\stepcounter{question}\thequestion } \verb|略．リファレンスを見てください．|\\

\item{問題\stepcounter{question}\thequestion } \verb|コード例は色々とあります．|\\
\begin{waku}
\begin{verbatim}
 sub my_reverse{
     my $seq = shift;
     my @seq = split //, $seq;
     my $reverse_seq;
     for(@seq){
         $reverse_seq = $_ . $seq;
     }
     return $reverse_seq;
 }
\end{verbatim}
\end{waku}\\
とか\\
\begin{waku}
\begin{verbatim}
 sub my_reverse{
     my $seq = shift;
     my @seq = split //, $seq;
     my $i = length $seq;
     my $reverse_seq;
     while(--$i >= 0){
         $reverse_seq .= $seq[$i];
     }
     return $reverse_seq;
 }
\end{verbatim}
\end{waku}\\
あるいは\\
\begin{waku}
\begin{verbatim}
 sub my_reverse{
     my $seq    = shift;
     my $length = length $seq;
     my $reverse_seq;
     for(1..$length){
         $reverse_seq .= substr $seq, $length-$_, 1;
     }
     return $reverse_seq;
 }
\end{verbatim}
\end{waku}

\item{問題\stepcounter{question}\thequestion } \verb|定義式をそのまま実装すればOKです．|\\
一本の配列のエントロピーを算出する関数\\
\begin{waku}
\begin{verbatim}
 sub entropy{
     my $seq    = lc shift;
     my $length = length($seq)||1;
     my(%count, $H);
     $count{$_}++ for split //, $seq;
     for('a', 't', 'c', 'g'){
         $count{$_}  /= $length;
         $count{$_} ||= 1;
         $H -= $count{$_}*log($count{$_})/log(2);
     }
     return $H;
 }
 
 my $seq = 'aaaaggactt';
 my $entropy = &entropy($seq);
 print "entropy = $entropy\n";
\end{verbatim}
\end{waku}\\
複数の配列のエントロピーを算出する関数\\
\begin{waku}
\begin{verbatim}
 sub entropy{
     my $seq_ref = shift;
     my $number  = scalar @{$seq_ref}||1;
     my(%count, @H, $i);
     for(@{$seq_ref}){
         $i = 0;
         ++$count[$i++]{$_} for split //;
     }
     for my $pos(0..$#count){
         for my $nuc('a', 't', 'c', 'g'){
             $count[$pos]{$nuc}  /= $number;
             $count[$pos]{$nuc} ||= 1;
             $H[$pos] -= $count[$pos]{$nuc} *log($count[$pos]{$nuc}) /log(2);
         }
     }
     return @H;
 } 
 my @seq = (
               'ataatgaatt',
               'ccacgcacta',
               'gcaacgacat',
               'ctattcacct'
           );
 my @entropy = &entropy(\@seq);
 print "$_\t$entropy[$_]\n" for 0..$#entropy;
\end{verbatim}
\end{waku}

\item{問題\stepcounter{question}\thequestion } \verb|リファレンスにして関数に引渡し，関数の中でデリファレンスできれば正解です．|\\
\begin{waku}
\begin{verbatim}
 sub my_reverse{
     my $seq = shift;
     my @seq = split //, $$seq;
     my $reverse_seq;
     for(@seq){
         $reverse_seq = $_ . $reverse_seq;
     }
     return $reverse_seq;
 }
 
 my $reverse_seq = &my_reverse(\$seq);
\end{verbatim}
\end{waku}

\item{問題\stepcounter{question}\thequestion } \verb|リファレンスの動作を確かめる問題です．|\\
\begin{waku}
\begin{verbatim}
 @array      = (1, 2, 3, 4, 5);
 $array_ref1 = \@array;
 $array_ref2 = [@array];
 
 print "$array_ref1->[2]\n";
 print "$array_ref2->[2]\n";
 
 $array[2] = 'x';
 
 print "$array_ref1->[2]\n";
 print "$array_ref2->[2]\n";
\end{verbatim}
\end{waku}

\item{問題\stepcounter{question}\thequestion } \verb|ハッシュに格納してしまうのが手っ取りばやく，また効率の良い方法です．|\\
\begin{waku}
\begin{verbatim}
 for(@row){
     $uniq{$_} = 1;
 }
 for(keys %uniq){
     push @uniq, $_;
 }
\end{verbatim}
\end{waku}\\
あるいは重複する要素を記録して言ってもよいでしょう．\\
\begin{waku}
\begin{verbatim}
 for(@row){
     next if $uniq{$_}++;
     push @uniq, $_;
 }
\end{verbatim}
\end{waku}\\
これらを短くすると\\
\begin{waku}
\begin{verbatim}
 @uniq = keys %{{map{$_, 1}@row}};
\end{verbatim}
\end{waku}\\
または\\
\begin{waku}
\begin{verbatim}
 @uniq = grep{!$exist{$_}}@row;
\end{verbatim}
\end{waku}\\
となります

\item{問題\stepcounter{question}\thequestion } \verb|Cの構造体likeなデータ構造を構築できます．|\\
\begin{waku}
\begin{verbatim}
 $seq   = 'atgacgtggtac';
 @array = ('a', 'r', 'r', 'a', 'y');
 %hash  = ('h' => 'a', 's' => 'h');
 sub hello{
     print "Hello! $_[0]!\n";
 }
 
 $struct = {
     scalar => \$seq,
     array  => \@array,
     hash   => \%hash,
     sub    => \&hello
 };
\end{verbatim}
\end{waku}\\
もちろん直接作ってもかまいせん．\\
\begin{waku}
\begin{verbatim}
 $struct = {
     scalar => \'atgacgtggtac',
     array  => ['a', 'r', 'r', 'a', 'y'],
     hash   => {'h' => 'a', 's' => 'h'},
     sub    => sub{"Hello! $_[0]!\n"}
 };
\end{verbatim}
\end{waku}

\item{問題\stepcounter{question}\thequestion } \verb|ランダム配列の作り方としては以下の二つを覚えればよいでしょう．|\\
\begin{waku}
\begin{verbatim}
 i)
 @nuc = ('a', 't', 'c', 'g');
 $seq .= $nuc[int(rand 4)] for 1..300;
 
 ii)
 $seq .= int(rand 4) for 1..300;
 $seq =~ tr/0123/atgc/;
\end{verbatim}
\end{waku}\\
あとはループとsubstrを使って順にコドンを抜き出せばよいでしょう．\\
\begin{waku}
\begin{verbatim}
 for(0..299){
     $codon = substr $seq, $_, 3;
     $count[$_%3]{$codon}++;
 }
 
 for my $frame(0..2){
     print "### $frame ###\n";
     for(sort{$count[$frame]{$b}<=>$count[$frame]{$a}}keys %{$count[$frame]}){
         print "$_\t$count[$frame]{$_}\n"
     }
 }
\end{verbatim}
\end{waku}

\item{問題\stepcounter{question}\thequestion } \verb|index関数の特徴をうまく利用してやると以下のようにwindexが実装できます．|\\
\begin{waku}
\begin{verbatim}
 sub windex{
     my($seq, $pat) = @_;
     my $pos = -1;
     my @all_position;
     while( ($pos=index($seq, $pat, $pos)) >-1){
         push @all_position, $pos;
         $pos++;
     }
     return @all_position;
 }
\end{verbatim}
\end{waku}\\
あるいは正規表現//gを使ってもできます．\\
\begin{waku}
\begin{verbatim}
 sub windex{
     my($seq, $pat) = @_;
     my @all_position;
     while($seq =~ /$pat/g){
         push @all_position, length $`;
     }
     return @all_position;
 }
\end{verbatim}
\end{waku}

\item{問題\stepcounter{question}\thequestion } \verb|trをカウントに使います．|\\
\begin{waku}
\begin{verbatim}
 $seq   = 'atgtgctgtagctgatgctgatcggggcgcgatc';
 $count = $seq =~ tr/gcGC/gcGC/;
\end{verbatim}
\end{waku}\\
あるいは\\
\begin{waku}
\begin{verbatim}
 $seq   = 'atgtgctgtagctgatgctgatcggggcgcgatc';
 $count = tr/gcGC/gcGC/ for $seq;
\end{verbatim}
\end{waku}

\item{問題\stepcounter{question}\thequestion } \verb|各関数とも重要ですので，書式，動作を確かめておきましょう．|\\
\begin{waku}
\begin{verbatim}
 @array = ('a', 'b', 'c', 'd', 'e');
 $first = shift @array;
 $last  = pop   @array;
 unshift @array, $last;
 push    @array, $first;
\end{verbatim}
\end{waku}

\item{問題\stepcounter{question}\thequestion } \verb|これらの関数のうち，popとshiftは与えられた配列を変更する機能の他，削られた要素を戻り値として返します．それらを実装するにはリファレンス演算子を用いたリファレンス渡し，及びreturnを用いた戻り値の設定が必要です．|\\
\begin{waku}
\begin{verbatim}
 sub my_unshift{
     my($array, $elm) = @_;
     splice @{$array}, 0, 0, $elm;
 }
 
 sub my_shift{
     my $array = shift;
     my $elm   = splice @{$array}, 0, 1;
     return $elm;
 }
 
 sub my_pop{
     my $array = shift;
     my $elm   = splice @{$array}, $#array, 1;
     return $elm;
 }
 
 sub my_push{
     my($array, $elm) = @_;
     splice @{$array}, $#{$array}+1, 0, $elm;
 }
\end{verbatim}
\end{waku}

\item{問題\stepcounter{question}\thequestion } \verb|(A, B) = (B, A)とすることで一時変数を使うことなく安全に値の交換ができます．|\\
\begin{waku}
\begin{verbatim}
 @foo = (1, 2, 3, 4, 5);
 @foo[2, 4] = @foo[4, 2];
\end{verbatim}
\end{waku}

\item{問題\stepcounter{question}\thequestion } \verb|上の問題で交換するペアを0, -1にかえれば完成です．|\\
\begin{waku}
\begin{verbatim}
 @foo = (1, 2, 3, 4, 5);
 @foo[0, -1] = @foo[-1, 0];
\end{verbatim}
\end{waku}

\setcounter{question}{44}
\item{問題\stepcounter{question}\thequestion } \verb|引数は@ARGVに入っています．個別に値をとりたいときは$ARGV[0]などとすればよいでしょう．また@ARGV自体は変更しないようにしましょう|\\
\begin{waku}
\begin{verbatim}
 my @arg = @ARGV;
 my $mean;
 $mean += $_ for @arg;
 $mean /=($#arg+1)||1;
 print "$mean\n";
\end{verbatim}
\end{waku}

\item{問題\stepcounter{question}\thequestion } \verb|lastを使って最近のログインランキングを調べるプログラムは以下の通りになるでしょう．|\\
\begin{waku}
\begin{verbatim}
 my @last = `last`;
 my %count;
 chomp @last;
 for(@last){
     my($name) = (split)[0];
     $count{$name}++;
 }
 for(sort{$count{$b} <=> $count{$a}}keys %count){
     printf "%s\t%d\n", $_, $count{$_};
 }
\end{verbatim}
\end{waku}

\end{description}

\subsection*{第3章 実践 Bioinformatics}
\begin{description}

\item{問題\stepcounter{question}\thequestion } \verb|二元配列がどのように行列を表しているかもう一度確認しましょう．|\\
\begin{waku}
\begin{verbatim}
 sub addition{ #足し算
     my($A, $B) = @_;
     my @A = @$A;
     my @B = @$B;
     my @C;
     for my $i(0..$#A){
         for my $j(0..$#{$A[0]}){
             $C[$i][$j] = $A[$i][$j]+$B[$i][$j];
         }
     }
     return @C;
  }
 sub multiplication{ #かけ算
     my($A, $B) = @_;
     my @A = @$A;
     my @B = @$B;
     my @C;
     for my $i(0..$#A){
         for my $j(0..$#{$B[0]}){
             for my $elm(0..$#B){
                 $C[$i][$j] += $A[$i][$elm]*$B[$elm][$j];
             }
         }
     }
     return @C;
 }
 my @A = ([1, 2],
          [3, 4]);
 my @B = ([5, 6],
          [7, 8]);
 my @ADD  = &addition(\@A, \@B);
 my @MULTI = &multiplication(\@A, \@B); 
 for my $i(0..$#ADD){
     for my $j(0..$#{$ADD[$i]}){
         print "$ADD[$i][$j]\t";
     }
     print "\n";
 }
 for my $i(0..$#MULTI){
     for my $j(0..$#{$MULTI[$i]}){
         print "$MULTI[$i][$j]\t";
     }
     print "\n";
 }
\end{verbatim}
\end{waku}
\end{description}

\newpage

\section{リファレンス}
\subsection*{スカラー変数操作法}
\begin{table}[h]
\begin{center}

\caption{スカラー変数操作法}

\begin{tabular}{cll}\hline
関数&説明&使用例\\ \hline
length&文字列の長さを返す&length 文字列\\ %\hline
reverse&文字列を逆にする&reverse 文字列\\ %\hline
index&文字列中のパターンの位置を返す&index 文字列, パターン, 捜査開始位置\\ %\hline
substr&文字列から指定した位置の部分文字列を返す&substr 文字列, 開始位置, 長さ\\ %\hline
s&置換&s/パターン/変換後の文字列/g\\ %\hline
tr&変換&tr/abc/pqr/\\ %\hline
lc&全て小文字に変換&lc 文字列\\ %\hline
sprintf&文字列の整形&\verb|sprintf フラッグ, 変数, …|\\ %\hline
chop&最後の文字を削る&chop 文字列\\ %\hline
chomp&改行を削る&chomp 文字列\\ %\hline
join&リストを結合して文字列を返す&\verb|join /区切り文字/, @array|\\ %\hline
split&文字列を区切り文字を目印に分割&split /区切り文字/, 文字列\\ %\hline
abs&絶対値を返す&abs 数値\\ %\hline
int&小数点以下を切り捨て&int 数値\\ %\hline
rand&乱数を返す&rand 数値\\ \hline
\end{tabular}
\end{center}
\end{table}

\subsection*{配列変数操作法}
\begin{table}[h]
\begin{center}

\caption{配列変数操作法}

\begin{tabular}{cll}\hline
関数&説明&書式\\ \hline
shift&先頭の要素を削除&\verb|shift @array|\\ %\hline
unshift&先頭に要素を追加&\verb|unshift @array, $scalar|\\ %\hline
pop&末尾の要素を削除&\verb|pop @array|\\ %\hline
push&末尾に追加&\verb|push @array, $scalar|\\ %\hline
sort&リストの要素をソート& \verb|@sorted = sort @mess|\\ %\hline
reverse&リストを逆順にならべる&\verb|reverse @array|\\ %\hline
map&配列を新たに作成&\verb|map{式}@array|\\ %\hline
grep&配列の要素を選別&\verb|grep{式}＠array|\\ %\hline
splice&要素を置換&\verb|splice @array, 位置, 要素数, 置換後のスカラーor配列|\\ \hline
\end{tabular}
\end{center}
\end{table}

\newpage

\subsection*{ハッシュ変数操作法}
\begin{table}[h]
\begin{center}

\caption{ハッシュ変数操作法}

\begin{tabular}{cll}\hline
関数&説明&使用例\\ \hline
keys&キーをリストにして返す& \verb|@keys = keys %hash|\\ %\hline
values&値をリストにして返す& \verb|@values = values %hash|\\ %\hline
each&キーと値のペアを一つずつ返す& \verb|while(($key, $value) = each %hash){式}|\\ %\hline
exists&キーが存在するか判定& \verb|exists $hash{$key}|\\ %\hline
delete&キーを削除& \verb|delete $hash{$key}|\\ %\hline
defined&値が真か判定& \verb|defined $hash{$key}|\\ %\hline
undef&値を初期化& \verb|undef $hash{$key}|\\ %\hline
reverse&キーと値を入れかえる& \verb|reverse %hash|\\ \hline
\end{tabular}
\end{center}
\end{table}

\subsection*{正規表現}
\begin{table}[h]
\begin{center}

\caption{正規表現}

\begin{tabular}{cl}\hline
正規表現&書式\\ \hline
\verb|.(ドット)|&\verb|ワイルドカード, 全てにマッチ(スペース, ヌルを含む)|\\ %\hline
\verb|\d, \D|&\verb|\dは整数にマッチ|\\ %\hline
\verb|\w, \W|&\verb|\wは[a-zA-Z0-9_]にマッチ|\\ %\hline
\verb|\s, \S|&\verb|\sはスペースorタブor改行にマッチ|\\ %\hline
\verb-a|b-&\verb|aまたbにマッチ|\\ %\hline
\verb|[abc]|&\verb|a, b, cのどれかにマッチ|\\ %\hline
\verb|[^a]|&\verb|a以外にマッチ|\\ %\hline
\verb|[a-z]|&\verb|a,b,…,zのどれかにマッチ|\\ %\hline
\verb|( )|&\verb|正規表現のグループ化, 同時に$1などに格納|\\ %\hline
\verb|$1, \1|&\verb|( )にマッチした文字列を格納|\\ %\hline
\verb|^|&\verb|行頭を意味する|\\ %\hline
\verb|$|&\verb|行末を意味する|\\ %\hline
\verb|a?|&\verb|aもしくはヌルにマッチ|\\ %\hline
\verb|a*|&\verb|aの0回以上の繰り返し|\\ %\hline
\verb|a+|&\verb|aの1回以上の繰り返し|\\ %\hline
\verb|a{m, n}|&\verb|aのm回以上, n回以下の繰り返し|\\ %\hline
\verb|??, *?, +?|&\verb|最短マッチ|\\ %\hline
\verb|\b|&\verb|単語の境にマッチ|\\ %\hline
\verb|\記号|&\verb|特別な意味のあるワードをエスケープする|\\ \hline
\end{tabular}
\end{center}
\end{table}

\newpage

\subsection*{printfの使い方}
\begin{description}
\item{構文} \\
\begin{waku}
\begin{verbatim}
printf "フラッグ", 第一項, 第二項,...;
\end{verbatim}
\end{waku}

\item{主なフラッグ}
\begin{description} 
\item{\verb|%s|} 文字列
\item{\verb|%d|} 整数
\item{\verb|%f|} 浮動小数点表示 (\verb|%.3fで小数第三位まで表示|)
\item{\verb|%e|} 科学表記 (\verb|%.3eで仮数を三桁まで表示|)
\item{\verb|\n|} 改行
\item{\verb|\t|} タブ
\end{description}

\item{例文} \\
\begin{waku}
\begin{verbatim}
printf "%\ts%.2f\n", 'pi ~ ', '3.14159';
\end{verbatim}
\end{waku}\\
→pi \verb|~| 3.14\\

\end{description}

\newpage

\section{参考文献}
このテキストを作成するにあたって参考にした文献，資料を以下にあげます．Perlに関する書籍，webページは膨大な数にのぼります．入門書は個々人にあったものを選べばよいでしょう．以下にあげた本は入門レベルをマスターし，実践的なプログラムを書いていく上で必須のものです．まずざっと目を通しておくことをお勧めします．そして手元におき，いつでも引けるようにしておけば効率の良いプログラミングが可能になるに違いありません．

\begin{description}
\item{[1]}Larry Wall {\it et al.}, 『Programing Perl第三版』, O’REILLY, 2002
\item{[2]}Hall, JN, Schwarrtz, RL, 『Effective Perl』, アスキー出版局, 1999
\item{[3]}藤田郁, 三島俊司, 『Perl/CGIプチリファレンス』, 技術評論社, 2004
\item{[4]}Christiansen, T {\it et al.}, 『Perlクックブック第二版』，O’REILLY, 2004

\item{[5]}斎藤靖, 『新Perlの国へようこそ』, サイエンス社, 1996
\item{[6]}武藤健志, 『独習Perl』, 翔泳社, 2004
\item{[7]}Schwarrtz, RL, 『初めてのPerl』, O'REILLY, 2003
\item{[8]}Quigley, E, 『Perl入門』, Pearson Education, 2000

\item{[9]}屋比久友秀, 『実践バイオインフォマティクスプログラミング』, 秀和システム, 2005
\item{[10]}坊農秀雅,	『初心者でもわかる!バイオインフォマティクス入門』, 羊土社, 2002
\item{[11]}藤宮仁, 『バイオインフォマティクスプログラミングのためのプログラミング入門』, オーム社, 2003
\item{[12]}Tisdall, J, 『BioinformaticsのためのPerl入門』, O’REILLY, 2002
\item{[13]}Gibas, C, 『実践バイオインフォマティクス』, O’REILLY, 2002
\item{[14]}斎藤輪太郎, 『バイオインフォマティクスの基礎』, サイエンス社, 2005
\end{description}

\printindex

\end{document}