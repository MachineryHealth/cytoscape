\documentclass[a4j,twoside]{jbook}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%package
\usepackage{fancyhdr}
\usepackage{fancybox}
\usepackage{ascmac}
\usepackage{makeidx}
\usepackage[dvips]{graphicx}

\makeindex
\def\seename{$\Longrightarrow$}

%\setcounter{chapter}{0}
%\setcounter{section}{0}
%\setcounter{figure}{0}
%\setcounter{table}{0}
%\setcounter{footnote}{0}
%\setcounter{equation}{0}

\newcounter{question}[chapter]
\setcounter{question}{1}

%renewcommand
\renewcommand{\cleardoublepage}{\clearpage}
\renewcommand{\headrulewidth}{1.0pt}
\renewcommand{\footrulewidth}{0.0pt}
\renewcommand{\thechapter}{\arabic{chapter}}
\renewcommand{\thesection}{\arabic{section}}

%header, footer
\pagestyle{fancy}
\lhead[\thepage]{}
\rhead[]{\thepage}
\chead[第\thechapter 章]{\rightmark}
\cfoot{}

%page space
\setlength{\textwidth}{\paperwidth}
\setlength{\headwidth}{\paperwidth}
\addtolength{\headwidth}{-2in}
\addtolength{\textwidth}{-2in}
\setlength{\evensidemargin}{1pt}
\setlength{\oddsidemargin}{1pt}
\setlength{\textheight}{\paperheight}
\addtolength{\textheight}{-2in}
\setlength{\topmargin}{0pt}
\setlength{\headheight}{1em}
\setlength{\headsep}{1em}
\addtolength{\textheight}{-2em}

\newenvironment{waku} 
{\begin{Sbox}\begin{minipage}{0.9\textwidth}} 
{\end{minipage}\end{Sbox}\shadowbox{\TheSbox}} 

%title
\title{初学者のためのPerlによる\\バイオプログラミング入門}
\author{
松井 求・斎藤 輪太郎 著 \\
冨田 勝 監修
}
\date{}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}

\maketitle

\chapter*{はじめに}
\paragraph{
ポストゲノムの時代を迎え分子生物学の実験データが大変な勢いで蓄積されている．これら膨大な量の公共データと自分が出した実験データを比較，解析し，有用な情報を抽出するためにはコンピュータを用いることが必要不可欠である．すでに現在までに様々な目的に応じた有用なソフトウェアが開発され，多くは無料で配布されている．既存のプロトコルにそった解析で間に合うのであればこれらのソフトウェアを用いる事で十分な結果が見込まれるであろう．しかし独自の仮説に基づいた解析を行う場合，あるいは大量のデータを相手にする，複数のソフトウェアを組み合わせて用いるといった場合はそれだけでは不十分であろう．柔軟にソフトウェアを組み合わせてフローを自動化したり，自前で計算をこなすような独自のプログラムが必要となってくる．このような用途に関してプログラミング言語に求められるのは外部のソフトウェアを自由に操作する事ができること，そして自前で計算やテキスト処理をこなせる能力をもつことである．さらには初心者でも簡単に習得でき，他の広い分野にも応用できる汎用的な言語であればさらによい．
}
\paragraph{
このような要望にもっとも適している言語はPerlであろう．Perlはテキスト処理やCGIなど，現在ある大量のWebコンテンツを維持する為に無くてはならない言語であるが，そのまま"テキストデータ"であるゲノム情報，あるいは生化学データなどを解析することが非常に得意な言語である．しかしながら，他言語の経験のあるプログラマや情報学者を対象にしたプログラミングの解説書は多数出版されているものの，プログラミングの経験のない分子生物学者にとってはかなり高度な内容となってしまっている．忙しい研究の合間に，あるいは実習の合間にプログラミングを習得していくのには必要最小限の練習問題を順に解いていき，身につけていくのがよい方法であると思われる．
}
\paragraph{
本書は慶應義塾大学湘南藤沢キャンパス(SFC)で行なわれている実習形式の講義，"ゲノム解析プログラミング実習"で用いられている講義資料を元として加筆，修正したものである．講義の対象は主にプログラミング経験のない学部1,2年生であり，従って本書の対象はプログラミングの知識を前提としない分子生物学者および分子生物学を専攻とする学生となる．第1,2部でPerlプログラミングの基礎をひととおり網羅した．各確認事項ごとに練習問題，及び解答をつけたので一通ずつ解いていくことで効率よく必要事項を学ぶ事ができると考える．3部でゲノム配列解析，遺伝子発現データの解析，生化学データの解析の実習問題をあげた．この問題を通して実用的なプログラミング能力を習得していただきい．また本書に掲載したプログラム，およびサンプルデータはすべて以下のWebページに載せた．参考にしていただければと思う．
http://www.../
}
\paragraph{
最後に本書を執筆するにあたってお世話になった方々にお礼申し上げたい．まず鈴木治夫氏，永安悟史氏にはお忙しい中本書執筆にご協力いただいた．そして慶應義塾大学先端生命研究室の皆さん，特に岡田祐輝氏には多くの貴重なご指摘，ご意見をいただいた．この場を借りて感謝申し上げる．また本書の出版にあたってピアソン・エデュケーションの藤村行俊氏には大変お世話になった．深く感謝を申し上げる．
}
\begin{flushright}
2006年12月24日 松井求
\end{flushright}
\tableofcontents

\chapter{Perlプログラミングを始めるまえに}
\section{準備するもの} 必要なものはPCだけです．Perl\index{Perl}プログラミングはLinux, Mac, WindowsといったほとんどすべてのOS\footnote{Perlはプラットフォームに非依存，かつフリーな言語です．以下にPerlの環境を用意する上で有用な文献，Webページをあげます．}で可能です．本書ではLinuxでの作業を想定して述べていきますが，他のOSでもほとんど同様にできるはずです．例えばLinuxは始めからPerlが含まれており，それはプロンプトを開いてすぐに確認することができます．Mac OSXにも同様にはじめからPerlが含まれていてやはりTerminal上で全く同様に行うことができます．Windowsでプログラミングを行う場合には若干のツールのインストールが必要かもしれません．ActivePerlあるいはCygwin\index{Cygwin}等を使うと便利でしょう．詳しくはマシン管理者に問い合わせてみてください．\\
　本書を学習するにあたっては即実用に役立つようにとの目的からあえて詳しい説明を省いた箇所があります．より深く学習されたい方はぜひリファレンスを手元に用意するとよいと思います．あるいはそういった資料はネット上に充実しています．参考にしてみてください．

\section{login, logout\index{login, logout}}
\begin{description}
\item{解説} Linuxではコマンドによってコンピュータに命令を与えます．以下に最低限知っておくべきコマンドをあげます．どれも重要なコマンドですのでひとつづつ動作を確認してみましょう．
\begin{table}[h]
\begin{center}

\caption{代表的なコマンド}

\begin{tabular}{lll}\hline
コマンド&意味&例文\\ \hline
ls\index{ls}&ディレクトリの中身を表示&ls ディレクトリ\\ %\hline
cd\index{cd}&カレントディレクトリの移動&cd ディレクトリ\\ %\hline
cp\index{cp}&ファイルのコピー&cp 元ファイル 新規ファイル\\ %\hline
mkdir\index{mkdir}&ディレクトリの新規作成&mkdir 新規ディレクトリ\\ %\hline
less\index{less}&ファイルの中身を表示&less ファイル\\ %\hline
mv\index{mv}&ファイル，ディレクトリの移動&mv 元ファイル 新規ファイル\\ %\hline
rm\index{rm}&ファイルの削除&rm ファイル\\ %\hline
emacs\index{emacs}&emacs(エディタ)の起動&emacs -nw ファイル\\ %\hline
exit\index{exit}&ログアウト&exit\\ %\hline
chmod\index{chmod}&パーミッション変更&chmod 755 ファイル\\ %\hline
perl\index{perl}&Perlインタプリタの起動&perl HelloWolrd.pl\\ \hline
\end{tabular}
\end{center}
\end{table}
\item{問題\stepcounter{question}\thequestion (★☆☆☆☆)} ホームディレクトリの下にperl$\_ $exerというディレクトリを作成してください．以後の作業はこのディレクトリで行いましょう．
\end{description}

\section{Perlとは}
\begin{description}
\item{解説} コンピュータは指令に従って計算を行う機械です．使用者はなんらかの方法でコンピュータに指令を出さなくてはいけません．そのひとつの方法としてコンピュータに対する指令を順番にファイルに書き込みコンピュータに手渡すという方法があります．この場合コンピュータはそのファイルを読み込み，書いてある指令を順にこなしていくわけですが，指令の書き方/文法は様々なものがあります．その文法のひとつがPerl言語です．
\item{問題\stepcounter{question}\thequestion (★☆☆☆☆)} perlというコマンドを打ってみましょう．すると入力待ち状態になります．そこで以下のように記述し，計算結果を表示させてみてください(\%はプロンプト)．8と出力されれば正解です．\\
\begin{waku}
\begin{verbatim}
% perl 
print 5+3;
_ _END_ _
\end{verbatim}
\end{waku}
\end{description}

\section{Perlの書き方}
\begin{description}
\item{解説} 今見たようにPerlは適宜起動して作業を行わせることができますが，スクリプトとして保存して繰り返し使用することも可能です．このようなPerlスクリプトを書く上で必要なのがエディタです．Linuxで代表的なエディタ\index{えでぃた@エディタ}にはEmacs\index{Emacs}とviがありますが，ここではEmacsを使います\footnote{Windowsではメモ帳，xyzzy，秀丸等があります．使いやすいものを用いてください}．以下に基本的なコマンドをあげます．特にC+z⇔fgは効率のいいプログラミングに必須でしょう．\\
\begin{table}[h]
\begin{center}

\caption{Emacsの主なコマンド}

\begin{tabular}{ll}\hline
\multicolumn{2}{c}{シェル内での移動}\\ \hline
emacs -nw&同ウィンドウ内で起動\\ %\hline
emacs $\& $&別のウィンドウで起動\\ %\hline
C-z&Emacsの中断，シェルに戻る\\ %\hline
fg&シェルから中断したEmacsに戻る\\ \hline
\multicolumn{2}{c}{保存}\\ \hline
C-x C-s&ファイルへの保存\\ %\hline
C-x C-w&別ファイル名で保存\\ \hline
\multicolumn{2}{c}{編集}\\ \hline
C-k&カーソル上の文字から行末までの削除\\ %\hline
C-w&リージョンの削除\\ %\hline
M-w&リージョンのコピー\\ %\hline
C-y&キルバッファの内容の取り出し\\ %\hline
C-x u&操作の取り消し\\ %\hline
C-x z&操作の繰り返し\\ %\hline
C-s&カーソル以降の文字列検索\\ %\hline
C-r&カーソル以前の文字列検索\\ \hline
\end{tabular}
\end{center}
\end{table}

\item{問題\stepcounter{question}\thequestion (★☆☆☆☆)} まず以下のようにしてEmacsを起動してください．\\
\begin{waku}
\begin{verbatim}
% emacs -nw nucleotide.txt
\end{verbatim}
\end{waku}\\
そして以下の内容を書き込み，保存しましょう．するとnucleotide.txtというファイルができているはずです．lessコマンドで観覧してみてください．\\
\begin{waku}
\begin{verbatim}
adenine
thymine
cytosine
guanine
\end{verbatim}
\end{waku}
\end{description}

\section{Perlの動かし方}
\begin{description}
\item{解説} Perlプログラムを実行するにはperlインタプリタにファイル(perlスクリプト)を渡し，実行してもらう必要があります．まずEmacsを起動して以下の内容を書き込みましょう．\\
\begin{waku}
\begin{verbatim}
% emacs -nw test.pl 	#emacsの起動，perlスクリプトの編集
\end{verbatim}
\end{waku}\\
書き込む内容\\
\begin{waku}
\begin{verbatim}
print "Hello, World!\n";
\end{verbatim}
\end{waku}\\
保存してシェルに戻ったら以下のコマンドを打ち込む．\\
\begin{waku}
\begin{verbatim}
% perl test.pl
\end{verbatim}
\end{waku}\\
これでtest.plというperlスクリプトが実行されます．結果を確認してみてください．ところでtest.plの中身は以降勉強していくとして，一般のperlスクリプトの先頭には次のように書いてある場合があります．\\
\begin{waku}
\begin{verbatim}
#!/usr/bin/perl

プログラム．．．
\end{verbatim}
\end{waku}\\
これはこのスクリプトを読み込んで実行するものとしてperlインタプリタを指定している，という文です．ためしに\\
\begin{waku}
\begin{verbatim}
% which perl
\end{verbatim}
\end{waku}\\
というコマンドを打ってみましょう．/usr/bin/perlなどという応答が帰ってくるはずです．これは/usr/binというディレクトリの下にperlインタプリタが置いてあることを意味しています．つまり\verb|#!/usr/bin/perl|と書いてあるスクリプトはそれに続く命令文を/usr/bin/perlに読み込んでもらうということになるのです．
\\
さて，この機構を利用して実行するには先ほどとは違い以下のようにします．\\
\begin{waku}
\begin{verbatim}
% emacs test.pl -nw	#編集
(% chmod 755 test.pl	#実行権を与える)
% ./test.pl		#実行
\end{verbatim}
\end{waku}\\
perlというコマンドがいらなくなったのは分かりましたか？実際にはどちらの方法でスクリプトを実行させてもかまいません．例えばインタプリタが置いてある場所はシステムごとに異なるので\verb|#!|の行を省略するという考え方もありますし，それとの中間的な方法として\\
\verb|#!/usr/bin/env perl|\\
と書く人もいます\footnote{chmodはパーミッションを変更するコマンドです．}．
\end{description}

\chapter{Perl入門}
\section{標準出力\index{ひょうじゅんしゅつりょく@標準出力}}
\begin{description}
\item{解説} print文で文字列または数値を表示することができます．\verb|\n|は改行を表します\footnote{セミコロンに注意！}．先ほど取り上げた以下の例は"Hello, World!"と画面上に出力させる命令文です．\\
\begin{waku}
\begin{verbatim}
print “Hello, world!", "\n”;
\end{verbatim}
\end{waku}
\item{問題\stepcounter{question}\thequestion (★☆☆☆☆)} 
123 x 456の答えを，”123 x 456 =”という文字列の後に表示しましょう．
\item{ヒント} $2*3$で2$\times$3が計算できます．また,(カンマ)で区切られた文字列は連続して出力されます．
\end{description}

\section{スカラー変数\index{すからーへんすう@スカラー変数}}
\begin{description}
\item{解説} \verb|"$名前”でスカラー変数になります．文字列と数値のどちらも同様にスカラー変数に代入することができます．変数に値を代入する演算子は"="で，これは右側の値を左側の変数に代入するという意味になります．|\\
\begin{waku}
\begin{verbatim}
$nucleotide = "uracil";
print $nucleotide, “\n”;
\end{verbatim}
\end{waku}
\item{問題\stepcounter{question}\thequestion (★☆☆☆☆)} 
\verb|変数$xに86400, $yに365を代入し，$z = $x * $yとして，$zの値を表示しましょう．|

\item{解説} \verb|変数の中の値を増やす方法がいくつかあります．$x = $x + 10で$xの値が10増えます．また$x ++は$x = $x + 1と等価です．|\\
\begin{waku}
\begin{verbatim}
$x = 3;
$x = $x + 5;
print $x, “\n”;
\end{verbatim}
\end{waku}
\item{問題\stepcounter{question}\thequestion (★☆☆☆☆)} 
\verb|$xに10を，$yに5を代入しましょう．そして$xに$x+$yを代入して$xの中身を出力しましょう．|
\end{description}

\section{配列変数\index{はいれつへんすう@配列変数}}
\begin{description}
\item{解説} \verb|”@名前”で配列を扱うことができます．@arrayでarrayという名前の配列を扱うことができます．$array[3]で@arrayの中の4番目の要素を取り出すことができます．以下の例ではcytosineが出力されるはずです|\footnote{Perlの中では1番目のものは0番目と認識されます．同様に2,3,...番目のものは1,2,...となります．}．\\
\begin{waku}
\begin{verbatim}
@nucleotide = (“adenine”, “thymine”, "cytosine”, “guanine”);
print $nucleotide[2], “\n”;
\end{verbatim}
\end{waku}
\item{問題\stepcounter{question}\thequestion (★☆☆☆☆)} \verb|”Sunday”, “Monday”, “Tuesday”, …, “Saturday”を@weekの中に入れましょう．そして，配列の中の３番目の要素を出力しましょう．|
\end{description}

\section{split\index{split}関数}
\begin{description}
\item{解説} splitを使うと，文字列を区切り文字で区切って，配列に格納することができます．\\
\begin{waku}
\begin{verbatim}
$str = “a,b,c,d,e”;
@array = split(/,/, $str);
print $array[2];
\end{verbatim}
\end{waku}
\item{問題\stepcounter{question}\thequestion (★★☆☆☆)} \verb|文字列”Sun-Mon-Tue-Wed-Thr-Fri-Sat”を$week_strに格納し，それをsplitで曜日ごとに区切って@week_arrayに格納し3番目の要素を表示しましょう．|
\end{description}

\section{ループ\index{るーぷ@ループ}}
\subsection{while\index{while}文}
\begin{description}
\item{解説} \verb|while文を使うと，( )で囲まれた条件が満たされている間，{ }で囲まれた箇所が何度も実行されます．|\\
\begin{waku}
\begin{verbatim}
$x = 1;
while($x < 5){
   print “Hello!\n”;
   print “Variable is now $x\n”;
   $x ++;
}
\end{verbatim}
\end{waku}
\item{問題\stepcounter{question}\thequestion (★★☆☆☆)} while文を使って以下のような出力をしてみましょう．\\
\begin{waku}
\begin{verbatim}
There are 2 sheep.
There are 4 sheep.
There are 6 sheep.
There are 8 sheep.
There are 10 sheep.
There are 12 sheep.
\end{verbatim}
\end{waku}
\item{問題\stepcounter{question}\thequestion (★★☆☆☆)} 1, 2, 4, 8, 16, …と2のべき乗を100000を超えるまで出力してみましょう．
\item{問題\stepcounter{question}\thequestion (★★☆☆☆)} while文を使って$3\times 5\times 7\times 9\times 11\times 13\times 15$を計算しましょう．
\end{description}

\subsection{for\index{for}文}
\begin{description}
\item{解説} \verb|for文を使うと，( )で囲まれた条件が満たされている間，{ }で囲まれた箇所が繰り返し実行されます．ただし( )の中身は以下の書式に従う必要があります．|\\
\item{書式} \verb|for( 初期化式; 条件式; 増分式){ 処理 }|\\
式は空白でもかまわないが小カッコの中にはセミコロンが必ず2つ含まれなければならない．また初期化式などを複数書きたい場合はカンマで区切る．\\
\begin{waku}
\begin{verbatim}
for( my($i, $j)=(0,0); $i<=10; $i++, $j = $i*$i ){
   print “$i\t$j\n”;
}
\end{verbatim}
\end{waku}\\
またこれは以下のループと同等です．\\
\begin{waku}
\begin{verbatim}
my($i, $j) = (0,0);
while($i<=10){
    my $j = $i*$i;
    print “$i\t$j\n”;
    $i++;
}
\end{verbatim}
\end{waku}
\item{問題\stepcounter{question}\thequestion (★☆☆☆☆)} $1,2,3,\ldots,99,100$の数字を降べきの順(100, 99, \ldots , 1)に出力しましょう．
\end{description}

\subsection{foreach\index{foreach}文}
\begin{description}
\item{解説} \verb|foreach文を使うと配列の要素を順番に取り出し処理することができます．|\\
\item{書式} \verb|foreach $変数( @配列){ 処理 }|\\
\verb|$変数は省略することが可能です．省略した場合，配列の要素は$_に代入されます．また@配列の代わりにリストを使用することも可能です．以下はリストを応用した例です．例文中の0..100は(0,1,2,...,99,100)というリストを表します．|\\
\begin{waku}
\begin{verbatim}
foreach my $i(0..100){
    my $j = $i*$i;
    print “$i\t$j\n”;
}
\end{verbatim}
\end{waku}
\item{問題\stepcounter{question}\thequestion (★★★☆☆)}1日が月曜日の4月のカレンダーを出力しましょう．\\
\begin{waku}
\begin{verbatim}
1	月
2	火
.	.
.	.
.	.	
\end{verbatim}
\end{waku}\\
もしくは\\
\begin{waku}
\begin{verbatim}
月 火 水 木 金 土 日
1 2 3 4 5 6 7 8 
9 ...
}
\end{verbatim}
\end{waku}\\
\verb|のどちらでもかまいません．最初の例の場合はあらかじめ月曜から日曜までの曜日のリスト(配列)を用意し，%演算子を使うと余りが計算できることを利用すると解決できます．例えば$R = 10%7 で$Rに3が代入されます．つまり4月10日は水曜日ということが分かります|\footnote{演算子については後ほど詳しく解説します．}．
\end{description}

\newpage

\section{ハッシュ\index{はっしゅ@ハッシュ}\index{hash}}
\subsection{静的なハッシュ作成\index{せいてきなはっしゅさくせい@静的なハッシュ作成}}
\begin{description}
\item{解説} \verb|”%名前”でハッシュを扱うことができます．%hashでhashという名前のハッシュを扱うことができます．ハッシュは”辞書”のようなものです．以下のようにして”辞書”を作成し利用することが出来ます．”辞書”でいう見出しをキー(key)，説明を値(value)と呼びます．|\\
\begin{waku}
\begin{verbatim}
%nucleotide = (
    "a"   =>	"adenine",
    "t"   =>	"thymine",
    "c" =>	"cytosine",
    "g" =>	"guanine"
);
print "$nucleotide{c}\n";
\end{verbatim}
\end{waku}
\item{問題\stepcounter{question}\thequestion (★☆☆☆☆)} いくつかのアミノ酸の略称と正式名称を対応させたハッシュ\%aminoを作成しましょう．いくつかのアミノ酸について略称と正式名称を並べて出力しましょう．
\end{description}

\subsection{動的なハッシュ作成\index{どうてきなはっしゅさくせい@動的なハッシュ作成}}
\begin{description}
\item{解説} \verb|上の例文では静的に%nucleotideを作りましたが，さらに以下のような操作によってエントリーを追加することが出来ます．|\\
\begin{waku}
\begin{verbatim}
%nucleotide = (
    "a"   =>	"adenine",
    "t"   =>	"thymine",
    "c" =>	"cytosine",
    "g" =>	"guanine"
);
$nucleotide{u} = "uracil";
print “$nucleotide{u}\n”;
print “$nucleotide{a}\n”;
\end{verbatim}
\end{waku}
\item{問題\stepcounter{question}\thequestion (★☆☆☆☆)} \verb|上の問題で作った%aminoに後からエントリーを追加しましょう．|
\end{description}

\subsection{ハッシュのキーの取り出し(keys\index{keys}関数，values\index{values}関数)}
\begin{description}
\item{解説} \verb|keys関数を使うとハッシュのキーをリスト化することが出来ます．foreach文と組み合わせることでハッシュの中身を順番に処理することが出来ます．また似た関数にvaluesがあります．これはハッシュのvalueをリスト化します． |\\
\begin{waku}
\begin{verbatim}
%nucleotide = (
    "a"   =>	"adenine",
    "t"   =>	"thymine",
    "c" =>	"cytosine",
    "g" =>	"guanine"
);
foreach my $key(keys %nucleotide){
    print “$key\t$nucleotide{$key}\n”;
}
\end{verbatim}
\end{waku}
\item{問題\stepcounter{question}\thequestion (★☆☆☆☆)} \verb|%aminoに含まれるエントリーを全て出力しましょう．|
\end{description}

\subsection{ハッシュのキーの取り出し(each\index{each}関数)}
\begin{description}
\item{解説} \verb|each関数を使うとキーと値を一組ずつ取り出すことが出来ます．each関数はwhile文と組み合わせて使うことに注意．|\\
\begin{waku}
\begin{verbatim}
%nucleotide = (
    "a"   =>	"adenine",
    "t"   =>	"thymine",
    "c" =>	"cytosine",
    "g" =>	"guanine"
);
while(($key, $value) = each %nucleotide){
    print “$key\t$value\n”;
}
\end{verbatim}
\end{waku}
\item{問題\stepcounter{question}\thequestion (★☆☆☆☆)} \verb|さきのkeys関数を使ったプログラムをeach関数を使ったプログラムに書き換えましょう|
\end{description}

\subsection{ハッシュを用いたカウント\index{かうんと@カウント}}
\begin{description}
\item{解説} \verb|ハッシュを用いると各要素の数を効率的にカウントすることが出来ます．対象とする要素数が多い場合，あるいは未知の場合有効です． |\\
\begin{waku}
\begin{verbatim}
my $seq = ‘aacgtgatgtcgtagtacgatgc’;
my %count;
$count{$_}++ for split ‘’, $seq;
for(keys %count){
    print “$_\t$count{$_}\n”;
}
\end{verbatim}
\end{waku}
\item{問題\stepcounter{question}\thequestion (★★☆☆☆)} \verb|上の例文を実行し，アルゴリズムを理解しましょう|
\end{description}

\section{ファイルの読み込み\index{ふぁいるのよみこみ@ファイルの読み込み}}
\begin{description}
\item{解説} \verb|openでファイルをオープンした後，while(<FILE>)でファイルを一行ずつ全部読み込むことができます．読み込んだ行は$_に格納されます．|\\
\begin{waku}
\begin{verbatim}
open(FILE, “nucleotide.txt”);
while(<FILE>){
   print $_;
}
close FILE;
\end{verbatim}
\end{waku}
\item{問題\stepcounter{question}\thequestion (★☆☆☆☆)} nucleotide.txtの最後の一行を表示するプログラムを書きましょう．

\item{解説} chompを使用すると，行末の改行を取り除くことができます．\\
\begin{waku}
\begin{verbatim}
open(FILE, “nucleotide.txt”);
while(<FILE>){
   chomp;
   print $_;
   print “\n”; # 行末の改行が取り除かれているので，ここで改行を行わなければ 
   # ならない．
}
close FILE;
\end{verbatim}
\end{waku}
\item{問題\stepcounter{question}\thequestion (★☆☆☆☆)} nucleotide.txtの各行をコンマでつなげて表示するプログラムを書きましょう．
\item{出力結果}\\
\begin{waku}
\begin{verbatim}
adenine,thymine,cytosine,guanine
\end{verbatim}
\end{waku}
\item{問題\stepcounter{question}\thequestion (★☆☆☆☆)} 以下の文章をnucleotide2.txtとして作成し，一行目と二行目を入れ替えるプログラムを書きましょう．各行の区切り文字はタブとします．
\item{fruit.txt} \\
\begin{waku}
\begin{verbatim}
a    adenine
t    thymine
c    cytosine
g    guanine
\end{verbatim}
\end{waku}
\item{出力結果}\\
\begin{waku}
\begin{verbatim}
adenine    a
thymine    t
cytosine   c
guanine    g
\end{verbatim}
\end{waku}

\item{問題\stepcounter{question}\thequestion (★★★☆☆)} さらにopendir\index{opendir}とreaddir\index{readdir}を使うことでディレクトリに含まれるファイルをすべて処理することができます．今いるディレクトリを開き，含まれるファイルをすべて表示するようなプログラムを作成しましょう．
\end{description}

\section{演算子\index{えんざんし@演算子}}
\subsection{算術演算子\index{さんじゅつえんざんし@算術演算子}}
\begin{description}
\item{解説} \verb|perlには加減乗除等の算術演算子がいくつか用意されています．基本的な演算子は一通り理解しておきましょう．同時に”+＝”といった短縮表現及び++の意味も確認しましょう．|\footnote{++はオートインクリメントという演算子で変数の値を一つ増やす作用をします．同様に--はオートディクリメントといわれ，変数の値を一つ減らします．}

\begin{table}[h]
\begin{center}
\caption{算術・論理演算子\index{ろんりえんざんし@論理演算子}}
\begin{tabular}{lll}\hline
演算子&意味&書式\\ \hline
$a+b$&足し算&$a+b$\\ %\hline
$a-b$&引き算&$a-b$\\ %\hline
$a\times b$&かけ算&$a*b$\\ %\hline
$a / b$&割り算&$a/b$\\ %\hline
$a \div b$の余&剰余&$a\% b$\\ %\hline
$a^b$&累乗&$a**b$\\ %\hline
$a\cap b$&論理積(かつ)&$a\&\&b$\\ %\hline
$a\cup b$&論理和(または)&$a||b$\\ %\hline
$\neg a$&否定&$! a$ \\ \hline
\end{tabular}
\end{center}
\end{table}

\item{書式} 演算と代入：\verb|$hoge = $foo + $bar;|\\
短絡表現：\verb|$hoge += $foo; #($hoge = $hoge+$foo と同じ)|\\
オートインクリメント：\verb|$hoge ++;|\index{おーといんくりめんと@オートインクリメント}\\
\begin{waku}
\begin{verbatim}
$add    = 5+3;	print $add,	“\n”;
$take   = 5-3;	print $take,	“\n”;
$time   = 5*3;	print $time,	“\n”;
$divid  = 5/3;	print $divid,	“\n”;
$add   += 2;		print $add,	“\n”;
$take  -= 2;		print $take,	“\n”;
$times *= 2;		print $times,	“\n”;
$divid /= 2;		print $divid,	“\n”;
\end{verbatim}
\end{waku}
\item{問題\stepcounter{question}\thequestion (★☆☆☆☆)} 0,1,2,\ldots,10の整数をランダムに100回出力しましょう．ただし以下の条件を満たしたプログラムにしてください．\\
 a) 0の場合，ZEROという文字列に置き換えて出力してください\\
 b) 条件分岐は使わずに演算子を用いましょう
\item{ヒント1} \verb|0~10の間のランダムな整数を得たい場合，$number = int(rand(10));\index{rand}とすると良いでしょう．|
\item{ヒント2} \verb+$hoge = $foo || $bar; とすると，$fooの値が0だった場合，$barが$hogeに代入されます．一方$fooの値が0以外であった場合は$fooが$hogeに代入されます．+
\end{description}

\subsection{文字列演算子\index{もじれつえんざんし@文字列演算子}}
\begin{description}
\item{解説} \verb|数値演算子と同様に文字列を操作する演算子もいくつか用意されています．特に文字列結合演算子(．ドット)はマスターしておきましょう．|\\

\begin{table}[h]
\begin{center}
\caption{文字列演算子}
\begin{tabular}{ll}\hline
意味&書式\\ \hline
文字列をつなげる&a . b\\ %\hline
文字列を繰り返す&a x 3\\ \hline
\end{tabular}
\end{center}
\end{table}

\begin{waku}
\begin{verbatim}
$seq	 = ‘hoge’.”\n”;	print $seq;
$seq	 = ‘hoge’ x 3;	print $seq;
$seq	.= ”\n”;		print $seq;
$seq	x= 3;			print $seq;
\end{verbatim}
\end{waku}
\item{問題\stepcounter{question}\thequestion (★☆☆☆☆)} aからzまで順につなげた26文字の文字列を作りましょう．そしてそれを10回繰り返した260文字の文字列を出力しましょう．
\end{description}

\subsection{比較演算子\index{ひかくえんざんし@比較演算子}}
\begin{description}
\item{解説} \verb|数学における等号/不等号と同様に数値を比較し，その結果を返す比較演算子が用意されています．以下の例文を実行し演算子の働きを確かめましょう．|

\begin{table}[h]
\begin{center}
\caption{比較演算子}
\begin{tabular}{lll}\hline
数式&意味&書式\\ \hline
\multicolumn{3}{c}{数値比較}\\ \hline
$a = b$&等しい&a==b\\ %\hline
$a\neq b$&等しくない&a!=b\\ %\hline
$a<b$&小さい&$a<b$\\ %\hline
$a>b$&大きい&$a>b$\\ %\hline
$a\leq b$&以下&$a<=b$\\ %\hline
$a\geq b$&以上&$a>=b$\\ %\hline
&比較&$a <=> b$\\ \hline
\multicolumn{3}{c}{文字列比較}\\ \hline
&同一文字列&a eq b\\ %\hline
&同一文字列ではない&a ne b\\ %\hline
&文字列の比較&a cmp b\\ \hline
\end{tabular}
\end{center}
\end{table}

\item{注意} ・ $==$と$=$の違いに気をつける\\
 \ ・ $=>$と$->$は比較演算子ではない．$>=$との書き間違えに注意\\
 \ ・ 数値比較演算子と文字列比較演算子の違いに注意．eqと==を混合しないように\\
\begin{waku}
\begin{verbatim}
$judge	 = (5==3);		print $judge;
$judge	 = (‘b’ eq ‘b’);	print $judge;
$judge	 = (15<=>5);		print $judge;
$judge	 = (‘aa’ cmp ‘bb’);	print $judge;
\end{verbatim}
\end{waku}
\item{問題\stepcounter{question}\thequestion (★☆☆☆☆)} \verb|$firstと$secondにランダムに数を代入しましょう．そして二つの数字を比較した結果と共に出力してください．|
\end{description}

\section{条件分岐\index{じょうけんぶんき@条件分岐}}
\subsection{if\index{if}/elsif\index{elsif}/else\index{else}}
\begin{description}
\item{解説} \verb|”アルゴリズム”とはある問題を解決する手順のことですが，以下の三つの要素でほぼどのようなアルゴリズムも実装可能です\footnote{興味のある人はダイクストラの構造化定理についてしらべみましょう}．if/elsif/elseという三段階の条件分岐を正確に使いこなすことがうまいPerl使いへの近道となります．|
\begin{description}
\item{1)} 手続きA→B→Cと順番に式を実行していく
\item{2)} ループA→B→C→A→B→C→\ldots とある条件のもと式の塊をくりかえす
\item{3)} 条件分岐Aの結果が真なら次にB，偽ならCを行う
\end{description}
\begin{waku}
\begin{verbatim}
my $seq = ‘acgtagtcgtgtga’;
my $length = length $seq;
my $ans;
if($length >= 20){
    $ans = ‘long’;
}
elsif($length <= 5){
    $ans = ‘short’;
}
else{
    $ans = ‘middle’;
}
print “The sequence is $ans\n”;
\end{verbatim}
\end{waku}
\item{問題\stepcounter{question}\thequestion (★☆☆☆☆)} 閏年を判定するプログラムを作りましょう
\end{description}

\newpage

\subsection{last\index{last}, next\index{next}, redo\index{redo}}
\begin{description}
\item{解説} \verb|ループを途中で強制的にスキップする，もしくは抜け出したいときがあります．これを実現する関数が三つほど用意されています．違いをよく確認しておきましょう|
\begin{description}
\item{last} 直ちにループを抜け出す
\item{next} 直ちに次のループに入り，next以降のブロック要素は無視され
る．
\item{redo} nextと同じく次のループに入る．ただし条件式はスルーされる．
\end{description}
次の例はredoを使った有名な文例です．あるファイルの文中，\verb|\(バックスラッシュ)|で終わる行を次の行と連結して表示します．\\
\begin{waku}
\begin{verbatim}
while(<FILE>){
    if(/\\\n/){
            chomp;
            s/\\//g;
            $next = <FILE>;
            $_   .=  $next;
            redo;
        }
        print;
}
\end{verbatim}
\end{waku}
\item{問題\stepcounter{question}\thequestion (★☆☆☆☆)} 上の例を実際に実行しredoの代わりにnextやlastを使えない理由を考えましょう．
\end{description}

\subsection{三項演算子\index{さんこうえんざんし@三項演算子}}
\begin{description}
\item{解説} \verb|Aが真ならばB，偽ならばCという文を簡潔に表現することが出来ます．|\\
\begin{waku}
\begin{verbatim}
my($foo, $bar) = (20, 30);
$foo = ($foo >= $bar)? $foo: $bar;
print $foo;
\end{verbatim}
\end{waku}
\item{問題\stepcounter{question}\thequestion (★☆☆☆☆)} 先ほど作った閏年判定プログラムを三項演算子を用いて書き換えましょう．
\end{description}

\section{正規表現\index{せいきひょうげん@正規表現}}
\subsection{マッチ演算子\index{まっちえんざんし@マッチ演算子}}
\begin{description}
\item{解説} \verb|ある文字列があり，あるキーワードでマッチさせたいとき正規表現を用います．|
\item{書式} \verb|$sequence =~ /pattern/;|\\
\verb|=~は二文字でひとつの演算子です．=と~の間に空白はあけてはいけません．またpatternは”/”二つで囲みます．さらにpatternは変数を含むことが出来ます．この場合変数は展開された後，patternとして参照されます．|\\
\begin{waku}
\begin{verbatim}
my $seq   = ‘aucugcugccaugguguagc’;
my $kozak = ‘gccaugg’;
if($seq =~ /$kozak/){
    print “Kozak\n”;
}
else{
    print “Non kozak\n”;
}
\end{verbatim}
\end{waku}
\item{問題\stepcounter{question}\thequestion (★☆☆☆☆)} ランダムな塩基配列を作り，その中にatgと(tag/tga/taa)という二つのパターンが同時に存在するか調べ，結果を出力しましょう．
\end{description}

\subsection{メタキャラクタ\index{めたきゃらくた@メタキャラクタ}，ワイルドカード\index{わいるどかーど@ワイルドカード}，後方参照\index{こうほうさんしょう@後方参照}}
\begin{description}
\item{解説} Perlはあいまい検索\index{あいまいけんさく@あいまい検索}を行うことが出来ます．よく用いる正規表現(メタキャラクタ)はリファレンスにまとめましたので参考にしてください．
\begin{verbatim}
．(ドット)などメタキャラクタとなる文字は正規表現内では文字列としては認識されないため，文字列としての．(ドット)とマッチさせたいときは\．のように\(バックスラッシュ)でエスケープさせる必要があります．さらに小カッコで囲うとその内容は$1,$2,$3…と\1,\2,\3…に入ります．正規表現の外では$を，正規表現内では\1を使います．また，複数の小カッコがあるとき，囲われた内容の入る変数は開きカッコの順番で決まります．
\end{verbatim}
\begin{waku}
\begin{verbatim}
my $haiku = ‘Tabiniyande YumehaKarenowo Kakemeguru’;
my $data = ‘Hideki’s uniform number is 55.’;
my $html = ‘<p>hoge <I>hogehoge</I> hoge</p> ’

if($haiku =~ /^(\S+)\s+(\S+)\s+(\S+)$/){
    print “$1\n”;
    print “$2\n”;
    print “$3\n”;
}
if($data =~ /(\d+)/){
    print “$1\n”;
}
if($html =~ /^<([^>]+)>(.*?)<\/\1>/){
    print “$2\n”;
}
if($haiku =~ /\b(\S+[aiu])\b/;){
    print “$1\n”;
}
\end{verbatim}
\end{waku}
\item{問題\stepcounter{question}\thequestion (★☆☆☆☆)}  300塩基長のランダムな塩基配列を作り，atgの前後6塩基ずつを全て表示してください．
\item{ヒント} while(/ pattern /g){ 処理 }でマッチの結果を順に見ることが出来ます．
\end{description}

\subsection{量指定子\index{りょうしていし@量指定子}}
\begin{description}
\item{解説} \verb|文字の連続に関して指定が出来ます．|\\
\begin{waku}
\begin{verbatim}
my $mRNA = ‘atgtgctgatcgtagctgaaaaaaaaa’;
if($mRNA =~ /^([a-z]+)a{5,}$/){
         print “$1\n”;
}
else{
         print “$mRNA\n”;
}
\end{verbatim}
\end{waku}
\item{問題\stepcounter{question}\thequestion (★☆☆☆☆)} 300塩基長のランダムな塩基配列を作り，cかgのみからなる10bp以上の長さの領域があるかどうかを判定しましょう．
\end{description}

\section{関数\index{かんすう@関数}}
\subsection{組み込み関数\index{くみこみかんすう@組み込み関数}}
\begin{description}
\item{解説} \verb|print，split等すでにいくつ使ってきましたが，perlにはたくさんの関数が用意されています．最初は以下にあげたものを知っていれば十分です．このうちいくつかは後のセクションで扱います．|\\
\begin{waku}
\begin{verbatim}
出力：        print, printf
算術計算：    log, sqrt, sin/cos, exp, abs, int, rand
文字列操作：  length, reverse, index/rindex, substr, lc/uc, chomp
             split/join, s///g, tr///, sprintf
配列操作：    shift, unshift, pop, push, sort, reverse, map, grep, splice
ハッシュ操作： keys/values, each, exists/defined, delete
制御：        last, next, redo, exit, die, return
宣言：        my, sub
システム:     open/close, opendir/readdir, select, system, package, use
\end{verbatim}
\end{waku}
\item{問題\stepcounter{question}\thequestion (★☆☆☆☆)} 上にあげた関数の機能を調べましょう．
\end{description}

\subsection{ユーザ関数\index{ゆーざかんすう@ユーザ関数}}
\begin{description}
\item{解説} \verb|組み込み関数と同様な関数をユーザが作ることが出来ます．|\\
\verb|sub 関数名{ 処理 }|\\
\verb|とすることで関数を宣言します．使うときは|\\
\verb|&関数名(引数1，引数2，・・・)|\\
\verb|です．&と小カッコは条件によって省略できます|\\

以下の例は相補鎖を求める関数です\\
\begin{waku}
\begin{verbatim}
sub complement{
    my $seq = shift;
    $seq =~ tr/atcgATCG/tagcTAGC/;
    $seq = reverse $seq;
    return $seq;
}

my $seq = ‘ttaactgatgctgtcgatctagctcat’;
print &complement($seq), “\n”;
\end{verbatim}
\end{waku}
\item{問題\stepcounter{question}\thequestion (★☆☆☆☆)} \\
a) reverse関数を自分で実装しましょう．\\
b) 塩基を含む配列を与えるとエントロピーを計算する関数を実装しましょう
\item{ヒント} reverse関数はループ及び配列の引数をうまく用いて作ると良いでし
ょうエントロピー$H$は$P_{i}$を塩基$i$の出現頻度をしたとき
\[H=-\sum_{n=a,t,c,g}P(n)\log_{2}P(n)\]
で定義されます．ただしここでは$0\log 0 := 0$とします
\end{description}

\section{リファレンス\index{りふぁれんす@リファレンス}}
\subsection{明示的なリファレンス作成}
\begin{description}
\item{解説} \verb|リファレンスは変数の住所のようなものです．値自体ではなく名前のみをやり取りすることでメモリーの節約やプログラムの効率の向上に寄与します．また関数に配列や複数の変数を渡すケース，あるいは多元配列/ハッシュの実装に用いられます．|\\
\begin{waku}
\begin{verbatim}
my $seq = ‘atgctgtagctgtgatgctgatgcg’;
my $seq_ref = \$seq;
my @array = (‘a’, ‘b’, ‘c’, ‘d’, ‘e’, ‘f’);
my $array_ref1 = \@array;
my %hash = (‘a’, 1, ‘b’, 2, ‘c’, 3);
my $hash_ref = \%hash;
sub hello{print “Hello $_[0]\n”}
my sub_ref = \&hello;

print $$seq_ref, “\n”; 
print $array_ref->[1], “\n”;
print $hash_ref->{a}, “\n”;
print $sub_ref->(‘john’), “\n”;
\end{verbatim}
\end{waku}
\item{問題\stepcounter{question}\thequestion (★☆☆☆☆)} 先ほど作ったreverse関数を参照渡しに変更しましょう
\end{description}

\subsection{無名配列\index{むめいはいれつ@無名配列}}
\begin{description}
\item{解説} \verb|上では\を用いてリファレンスを明示的に作成しましたが，[ ]もしくは{ }を用いてより直接的にリファレンスを作成することが出来ます．これらを無名配列/ハッシュ/関数といいます．|\\
\begin{waku}
\begin{verbatim}
@array = (‘a’, ‘b’, ‘c’, ‘d’, ‘e’, ‘f’);
$array_ref1 = [@array];
$array_ref2 = [‘a’, ‘b’, ‘c’, ‘d’, ‘e’, ‘f’];
$hash_ref = {‘a’, 1, ‘b’, 2, ‘c’, 3};
$sub_ref = sub{print “Hello $_[0]”};

print $array[1], “\n”;
print $array_ref1->[1], “\n”;
print $array_ref2->[1], “\n”;
print $hash_ref->{a}, “\n”;
print $sub_ref->(‘john’), “\n”;
\end{verbatim}
\end{waku}
\item{問題\stepcounter{question}\thequestion (★☆☆☆☆)} 各自配列を作り，さらにそのリファレンスを作ってください．ただしリファレンス演算子\index{りふぁれんすえんざんし@リファレンス演算子}を用いた方法，無名配列を用いた方法の二通りを行ってください．そのあと元の配列を変え，リファレンスの中身を見てみましょう．
\end{description}

\subsection{多元配列\index{たげんはいれつ@多元配列}，行列\index{ぎょうれつ@行列}}
\begin{description}
\item{解説} \verb|リファレンスを用いて多元配列を作成することが出来ます．|\\
\begin{waku}
\begin{verbatim}
@array = ([1, 2, 3], [4, 5, 6], [7, 8, 9]);
$array_ref = [[1, 2, 3], [4, 5, 6], [7, 8, 9]];

print $array[1][1], “\n”;
print $array_ref->[1][1], “\n”;
\end{verbatim}
\end{waku}
\end{description}

\subsection{多元ハッシュ\index{たげんはっしゅ@多元ハッシュ}，構造体\index{こうぞうたい@構造体}}
\begin{description}
\item{解説} 多元配列と同様に多元ハッシュも作成することが出来ます．さらにスカラー変数，配列，関数等を要素に含む構造体likeなデータ構造も実現できます．\\
\begin{waku}
\begin{verbatim}
%hash = (
    a => {1, 3, 2, 2},
    t => {1, 5, 2, 5},
    c => {1, 3, 2, 1},
    g => {1, 4}
)
$hash{g}{2} = 1;

print $hash{g}{2}, “\n”;
\end{verbatim}
\end{waku}
\item{問題\stepcounter{question}\thequestion (★☆☆☆☆)} スカラー変数，配列，ハッシュ，関数への各リファレンスを含む多元ハッシュを構築しましょう．そしてそれぞれ出力し動作を確認しましょう．
\end{description}

\section{文字列操作\index{もじれつそうさ@文字列操作}}
\subsection{部分文字列の操作}
\begin{description}
\item{解説} substr\index{substr}を使うと文字列の操作を行うことが出来ます．\\
\begin{waku}
\begin{verbatim}
my $seq = ‘abcdefg’;
my $part1 = substr($seq, 2, 2);
my $part2 = substr($seq, -2, 2);
print $seq, “\n” ;
print $part1, “\n”;
print $part2, “\n”;

substr($seq, 0, 2) = ‘xy’;
substr($seq, 0, 2, ‘pq’);

print $seq;
\end{verbatim}
\end{waku}
\item{問題\stepcounter{question}\thequestion (★☆☆☆☆)} 300文字のランダム塩基配列を作りましょう．そしてコドンごとに頻度をカウントし，数の多い順に表示してください．
\end{description}

\subsection{パターンの検索\index{ぱたーんけんさく@パターン検索}}
\begin{description}
\item{解説} m//\index{m}，index\index{index}，rindexはパターンを検索する関数です．m//は実は正規表現で出てきた\verb|”=~ /pattern/”|のダブルスラッシュのことです．このようにmは省略できますが，あえてつけた場合\verb|”=~ m#pattern#”|のようにパターンをスラッシュ以外の記号で囲うことが出来ます．index/rindexは文字列から最左(右)のパターンマッチの位置を返す関数でパターンマッチに失敗したときは-1を返します．\\
\begin{waku}
\begin{verbatim}
$seq = ‘actgacgatgatgtgcatgc’;
($forward, $behind) = /([atcg]{6})atg([atcg]{6})/ for $seq;
$l_pos = index($seq, ‘atg’, 0);
$r_pos = rindex($seq, ‘atg’);

print “$forward\t$behind\n”;
print “$l_pos\t$r_pos\n”;
\end{verbatim}
\end{waku}
\item{問題\stepcounter{question}\thequestion (★☆☆☆☆)} index/rindexは最左，もしくは最右の要素しか見つけることが出来ませんが，それだと目的にそぐわない場合があります．そこでパターンの見つかった場所全てを返すwindex関数を実装してみましょう．ループとうまく組み合わせるとよいでしょう．
\end{description}

\subsection{置換\index{ちかん@置換}}
\begin{description}
\item{解説} \verb|s//，tr///はそれぞれ文字列の置換を行う関数です．|\\
\begin{waku}
\begin{verbatim}
#$seqから塩基以外の文字をのぞく
$seq =~ s/[^a-z]//g;

#カウント(二つの式は同じ意味)
$count = $seq =~ tr/gcGC/gcGC/;
$count = tr/gcGC/gcGC/ for $seq;
\end{verbatim}
\end{waku}
\item{問題\stepcounter{question}\thequestion (★☆☆☆☆)} 置換演算子を用いて塩基配列中におけるGCの数をカウントしましょう．
\end{description}

\section{配列操作\index{はいれつそうさ@配列操作}}
\subsection{末端要素の操作}
\begin{description}
\item{解説} \verb|配列の末端要素を操作する関数は4つ用意されています．|
\begin{description}
\item{shift}	先頭要素をひとつ削除\index{shift}
\item{pop}	末尾要素をひとつ削除\index{pop}
\item{unshift} 先頭に要素を追加\index{unshift}
\item{push} 末尾に要素を追加\index{push}
\end{description}
\begin{waku}
\begin{verbatim}
my @test1 = (‘a’, ‘b’, ‘c’);
my @test2 = (‘d’, ‘e’, ‘f’);
my $shift = shift @test1;
my $pop = pop @test1;
unshift( @test2, ‘c’ )
push( @test2, ‘g’ );

print “$shift\n”;
print “$pop\n”
print “@test1\n”;
print “@test2\n”;
\end{verbatim}
\end{waku}
\item{問題\stepcounter{question}\thequestion (★☆☆☆☆)} これらの関数を用いて配列の最初と最後の要素を入れ替えましょう．
\end{description}

\subsection{要素の置換\index{はいれつようそのちかん@配列要素の置換}}
\begin{description}
\item{解説} \verb|substrは文字列の操作を行う関数ですが，同様に配列の操作を行う関数にsplice|\index{splice}\verb|があります．書式はほぼsubstrと同じです．|\\
\begin{waku}
\begin{verbatim}
my @test = (‘a’, ‘b’, ‘c’, ‘d’, ‘e’, ‘f’, ‘g’);
my @test2 = splice(@test, 3, 2);
splice(@test, 1, 2, (‘a’, ‘b’));

print “@test\n”;
print “@test2\n”;
\end{verbatim}
\end{waku}
\item{問題\stepcounter{question}\thequestion (★☆☆☆☆)} spliceを使ってshift，unshift，push，popと同じ動作をする関数を作ってみましょう．
\end{description}

\subsection{スライス\index{すらいす@スライス}}
\begin{description}
\item{解説} \verb|配列の要素をひとつとってくるときは$array[0]としますが，スライスを用いると同時に複数の要素を取ることが出来ます．|\\
\item{書式} \verb|($first, $second) = @array[0,1];|\\
\verb|$の代わりに@を使います．ハッシュも同様にスライスを適用可能です|\\
\begin{waku}
\begin{verbatim}
my $seq = ‘abcdef’;
my @array = (‘a’, ‘b’, ‘c’, ‘d’, ‘e’, ‘f’);
my %hash = (‘a’, 1, ‘b’, 2, ‘c’, 3);
my @chr = ( split(‘’, $seq) )[0,1,2];
my @num = @hash{@array[2,1]};

print “@chr\n”;
print “@num\n”;
\end{verbatim}
\end{waku}
\item{問題\stepcounter{question}\thequestion (★☆☆☆☆)} 配列を作成し，スライスを用いて要素の交換を行いましょう．
\end{description}

\subsection{負の引数\index{ふのひきすう@負の引数}}
\begin{description}
\item{解説} \verb|配列の最後の要素へは最後の要素の添え字を表す$#配列名を利用し|
\begin{verbatim}
$hoge[$#hoge]
でアクセスすることが出来ますが，負の引数を用いて
$hoge[-1]
でもアクセスできます．同様に最後からn番目の要素は
$hoge[-n]
です．
\end{verbatim}
\begin{waku}
\begin{verbatim}
@array = (‘a’, ‘b’, ‘c’, ‘d’, ‘e’, ‘f’);
print $#array, “\n”;
print $array[$#array], “\n”;
print $array[-1], “\n”;
\end{verbatim}
\end{waku}
\item{問題\stepcounter{question}\thequestion (★☆☆☆☆)} スライスを用いて最初と最後の要素を入れ替えましょう．
\end{description}

\subsection{ソート\index{そーと@ソート}}
\begin{description}
\item{解説} ソートを行うsort\index{sort}関数はデフォルトでは辞書順に従った並べかえを行いますが，正確に数値の大きさ順にそろえる，複雑な並べ替えを行いたいといった場合，並べ替え方を指定することも出来ます\footnote{デフォルトのままだと例えば12,3,23をソートした場合12, 23, 3と並べてしまいます．}．以下は塩基の長さについてまず綴りの短い順に並べ，同じ長さの名前に関してはアルファベット順に並べています．\\
\begin{waku}
\begin{verbatim}
my @nuc = (‘adenine’, ‘guanine’, ‘thymine’, ‘cytosine’, 'uracil');
my @sorted = sort{
    length $a <=> length $b ||
    $a cmp $b	
}@nuc;
\end{verbatim}
\end{waku}
\item{問題\stepcounter{question}\thequestion (★☆☆☆☆)} \\
\verb|@number = (1, 5, 30, 22, 3, 9);|\\を作成し以下の二つのソートの動作比較をしましょう\\
\verb|sort @number|\\
\verb|sotr{$a <=> $b}@number|
\end{description}

\subsection{配列の編集}
\begin{description}
\item{解説} map\index{map}とgrep\index{grep}は配列の編集に威力を発揮する関数です．以下に基本的な使用例をあげますが，是非sortと共に使いこなせるようにしておきましょう．\\
\begin{waku}
\begin{verbatim}
my @even = map{$_*2}0..50;
my @quadric = map{[$_, $_**2]}0..20;
my @lion_king = grep{/lion king/i}@musical;

#以下は@dataのデータを%other_dataに記述されたデータにしたがってソートする効率の良い方法”Schwartz変換”です．
my data_sorted =
map{$_->[0]}
sort{$a->[1] <=> $b->[1]}
map{[$_, $other_data{$_}]}@data;
\end{verbatim}
\end{waku}
\item{問題\stepcounter{question}\thequestion (★☆☆☆☆)} 要素のダブリを含む配列からダブリを除くようなプログラムを作成しましょう．ただしgrepを用いた方法とハッシュを用いた方法の2通りを考えてください．
\item{問題\stepcounter{question}\thequestion (★☆☆☆☆)} 実際にSchwartz変換\index{シューウォーツへんかん@Schwartz変換}を使ってみましょう
\end{description}

\section{外部入出力，制御\index{がいぶにゅうしゅつりょく@外部入出力}}
\subsection{ファイルへの書き出し\index{ふぁいるへのかきだし@ファイルへの書き出し}}
\begin{description}
\item{解説} \verb|読み込み用にファイルを開く場合は|
\begin{verbatim}open FILE, hoge.txt;
としました．同様に書き出し用のファイルを開くことも出来ます．
open FILE, “>output.txt”;
これでoutput.txtというファイルが新たに生成され，データを書き込むことが出来ます．ただし，>では既存のファイルを上書きしてしまうためそれを避けるために>>を用いることもあります．>は無条件に新規ファイルの生成を行いますが，>>は同名のファイルがなかった場合は新規作成，あった場合は末尾にデータを追加します．
\end{verbatim}
\begin{waku}
\begin{verbatim}
open FILE, “>output.txt” or die;
print “one\n”;
print FILE “two\n”;
select FILE;
print “three\n”;
select STDOUT;
print “four\n”;
\end{verbatim}
\end{waku}
\item{問題\stepcounter{question}\thequestion (★☆☆☆☆)} 上のコードを実行し，動作を確認しましょう．
\end{description}

\subsection{@ARGV\index{"@ ARGV}}
\begin{description}
\item{解説} スクリプトへの引数は@ARGVに収められています．\\
コマンドライン上\\
\begin{waku}
\begin{verbatim}
% view_one_line.pl nucleotide.txt 5
\end{verbatim}
\end{waku}\\
スクリプト\\
\begin{waku}
\begin{verbatim}
#!/usr/bin/perl

open FILE, $ARGV[0] or die”Can’t open $ARGV[0]:$!”;
my @line = <FILE>;
print “$line[$ARGV[1]-1]\n”;
\end{verbatim}
\end{waku}
\item{問題\stepcounter{question}\thequestion (★☆☆☆☆)} 複数の数値を引数として受け取り，平均を出力するスクリプトを作成しましょう．
\end{description}

\subsection{外部コマンドの使用\index{がいぶこまんどのしよう@外部コマンドの使用}}
\begin{description}
\item{解説} 外部コマンドを使用する場合，system\index{system}関数を使う，あるいはバッククォーテオションを使うという二通りの方法があります．\\
\begin{waku}
\begin{verbatim}
system(“ls -l”);
my @who = `who`;
for(@who){
    my @line = split;
    print “$line[0]\t$line[4]\n”;
}
\end{verbatim}
\end{waku}
\item{問題\stepcounter{question}\thequestion (★☆☆☆☆)} lastコマンドの出力を受け取り，PCへのアクセス回数を表示させましょう．
\end{description}

\section{囲い文字\index{かこいもじ@囲い文字}}
\subsection{クォーテーション\index{くぉーてーしょん@クォーテーション}}
\begin{description}
\item{解説} クォーテーションは三種類あります．
\begin{description}
\item{“/qq} （ダブルクォーテーション）\index{だぶるくぉーてーしょん@ダブルクォーテーション}\\
文字列．変数/エスケープ文字が含まれていた場合，解釈される．\\
\verb|“$hoge\n”	← $hogeの中身が展開され，改行が付加される|\\
\verb|qq#$hoge\n#	← 上に同じ．囲い文字は自由．|\\
\item{‘/q} （シングルクォーテーション）\index{しんぐるくぉーてーしょん@シングルクォーテーション}\\
文字列．ただし変数は展開せず”そのまま”に解釈される．\\
\verb|‘$hoge\n’ ← $hoge\nという文字列|\\
\verb|q#$hoge\n# ← 上に同じ|\\
\item{`/qx} （バッククォーテーション）\index{ばっくくぉーてーしょん@バッククォーテーション}\\
中にコマンドを書く．するとコマンドは実行され，結果が返される．\\
\verb|$who =`who`; ← whoというコマンドの実行結果が$whoに入る|\\
\verb|$who =qx#who# ← 上に同じ|\\
\item{qw} 
空白区切りでリストを作る．カンマ・囲いは不要．\\
\verb|@chr = qw(a b c d e f g);|\\
\end{description}
\begin{waku}
\begin{verbatim}
my $foo = ’bar’;
my @continent = qw(Africa Antarctica Australia Eurasia
 North_America South_America);

print ‘$foo\n’;
print “$foo\n”;
print `who`;
print “$continent[1]\n”;
\end{verbatim}
\end{waku}
\item{問題\stepcounter{question}\thequestion (★☆☆☆☆)} コマンドラインからファイル名を受け取り，.txtという拡張子をつけて適当に文字列を書き込みましょう．
\item{問題\stepcounter{question}\thequestion (★☆☆☆☆)} lynxと組み合わせて簡単なweb robotを作成しましょう．例えばGenBankからファイルをダウンロードし，アノテーションを抽出するようなweb robotを作成しましょう．
\end{description}

\subsection{$[\ ]$}
\begin{description}
\item{解説} \verb|[ ]は文脈によって以下のようなことなる意味を持ちます．|
\begin{description}
\item{配列の添え字}	\verb|$array[2]|
\item{スライスの添え字} \verb|@slice[3..5]|
\item{リファレンスの添え字} \verb|$array_ref->[6] or $$array_ref[6]|
\item{無名配列}	\verb|[1, 1, 2, 3, 5, 8, 13, 21]|
\end{description}
\begin{waku}
\begin{verbatim}
my $foo = ’a’;
my $bar = ’b’;

$ref1 = [$foo, $bar];
@ref2 = \($for, $bar);
\end{verbatim}
\end{waku}
\item{問題\stepcounter{question}\thequestion (★☆☆☆☆)} \verb|例文で出来てきた$ref1と@ref2の違いを理解しましょう．|
\end{description}

\subsection{$\{ \}$}
\begin{description}
\item{解説} \verb|{ }も文脈によって異なる意味を持ちます|
\begin{description}
\item{ハッシュの添え字} \verb|$hash{$key}|
\item{スライスの添え字} \verb|@hash{$key1, $key2}|
\item{リファレンスの添え字} \verb|$hash_ref->{$key} or $$hash_ref->{$key}|
\item{無名ハッシュ}	\verb|{1, ‘a’, 2, ‘b’, 3, ‘c’}|
\item{ループ} \verb|foreach(配列){処理}|
\item{ブロック}	\verb|do{処理}while(条件);|
\end{description}
特にdo{}while();文では最後のセミコロンを忘れないようにしてください．\\
\begin{waku}
\begin{verbatim}
my $hoge = ‘foo’;
{
    my $hoge = ‘bar’;
    print “$hoge\n”;
}
print ”$hoge\n”;
\end{verbatim}
\end{waku}
\item{問題\stepcounter{question}\thequestion (★☆☆☆☆)} 引数を保持し，再び与えられた引数が元の引数と合致するか判定するクロージャを実装しましょう．
\end{description}

\subsection{( )}
\begin{description}
\item{解説} \verb|( )に関しては特にリスト・配列・無名配列の違いを理解すること，正規表現に関するグループ化と後方参照を理解することが重要です．|\\
\begin{waku}
\begin{verbatim}
my $chr = ‘5a3b1’;
my @array;
@array = /((\d)a(\d(b))\d)/ for $chr;

printf “%s\n”, $_ for @array;
\end{verbatim}
\end{waku}
\item{問題\stepcounter{question}\thequestion (★☆☆☆☆)} 例文から後方参照のルールを確認しましょう．また配列と無名配列の違いも確認しておきましょう．
\end{description}

\subsection{$< >$}
\begin{description}
\item{解説} \verb|山カッコ演算子はファイルハンドルを受け取ると，それを読み込む演算子です．ハンドルが省略されるとSTDINを対象とします．また山カッコ演算子のデフォルト区切り文字は\n，つまり改行です．そのために文章を一行ずつ読み込めるわけですが，この区切り文字は以下のように変えることが出来ます．|
\begin{verbatim}
local $/ = “\n>”;
while(<FILE>){
	処理
}
\end{verbatim}
\verb|これでカッコの中だけ区切り文字が>(ただし直前に改行有り)に変えることが出来ます．以下はこれを利用して効率よくfst形式のファイルを加工している例です．|\\
\begin{waku}
\begin{verbatim}
open FST, hoge.fst or die;
{
    local $/ = “\n>”;
    while(<FST>){
        my($head, @seq) = split /\n/;
        my($seq = join ‘’, @seq) =~ s/[-a-zA-Z]//g;
        $head =~ s/>//;
        $fst{$head} = $seq;
    }
}
\end{verbatim}
\end{waku}
\item{問題\stepcounter{question}\thequestion (★☆☆☆☆)} ls -Rの結果をファイルに書き出し，それを効率よく読み込み，ハッシュに格納しましょう．
\end{description}

\subsection{/ /}
\begin{description}
\item{解説} \verb|正規表現の囲い文字です．正確にはマッチ演算子m//の省略形です．mが省略されると囲い文字は//でなければいけませんが，mを省略しない場合以下の例文のようなことが出来ます．|\\
\begin{waku}
\begin{verbatim}
my $matsui = ‘GODZILLA’;
my $slash = ‘//////’;

print ”55\n” if $matsui =~ m!GOD!;
print ”6slashes\n” if $slash =~ m#\/\/\/\/\/\/#;
\end{verbatim}
\end{waku}
\item{問題\stepcounter{question}\thequestion (★☆☆☆☆)} 100文字と3文字の文字列をそれぞれ作り，100文字の文字列中に3文字の文字列が含まれるかチェックする．という作業を100回繰り返し，結果を表示しましょう．
\end{description}

\section{デバグ\index{でばぐ@デバグ}の定石，コメントアウト\index{こめんとあうと@コメントアウト}}
\subsection{デバグしやすいコード}
\begin{description}
\item{解説} \verb|プログラムを作成する際には入力ミス，アルゴリズムの不備，想定外のエラーはつきものです．そういったエラーをバグといい，直すことをデバグといいます．デバグはプログラミングの重要な一行程であり，以下に効率よくデバグできるかは効率のいいプログラミングには必須のスキルとなります．|
\begin{itemize}
\item 中身を書く前にカッコを閉じる
\item コメントをつける
\item スペース・改行・インデントの幅を統一する\footnote{emacsを使用している場合はPerl-modeを使うと便利です．}
\item 抽象度の高いプログラムにする
\end{itemize}
\begin{waku}
\begin{verbatim}
1)
$hoge[ ]
↓
$hoge[5]

2)
substr( );
↓
substr($seq, 0, 3);

3)
while( ){ 

}
↓
while($num > 5){ 

}
↓
while($num > 5){ 
    print $num++;
}
\end{verbatim}
\end{waku}
\item{問題\stepcounter{question}\thequestion (★☆☆☆☆)} ここで使われているプログラミングのコツとはなんでしょうか．
\end{description}

\subsection{コメントアウトの仕方，デバグの手順}
\begin{description}
\item{解説} printout，コメントアウト，カット，$\_ \_ $END$\_ \_$，exit，die\\
デバグのときにはこれらを用いるといいでしょう．\\
(a) コメントアウト \verb|#に続く一行はインタプリタに無視されます|\\
\begin{waku}
\begin{verbatim}
#この行は無視されます
#この行は無視されます
print “Hello World\n”;
\end{verbatim}
\end{waku}\\
\\
(b) POD\index{POD}の応用 広い範囲をコメントアウトするときに用います\\
\begin{waku}
\begin{verbatim}
=c
この行は無視されます
この行は無視されます
=cut
print “Hello World\n”;
\end{verbatim}
\end{waku}\\
\\
(c) $\_ \_ $END$\_ \_$ \verb|以降のコードを無効にしたいときに用います．アンダーバーが計4つ使われていることに注意してください|\\
\begin{waku}
\begin{verbatim}
print “Hello World\n”;
__END__
これから後は無視されます
\end{verbatim}
\end{waku}\\
\\
(d) exit プログラムを強制的に終了したいときに用います．\index{exit}\\
\begin{waku}
\begin{verbatim}
print “Hello World\n”;
if($a != 1){
    exit;
    $aが1ではないときプログラムはここで終了します
}
\end{verbatim}
\end{waku}\\
\\
(e) die エラーによる強制終了にはdieを用います\index{die}\\
\begin{waku}
\begin{verbatim}
open FILE, ‘ecoli.fst’ or die”Can’t open ecoli.fst:$!”;
ecoli.fstが開けないとき，その旨出力してからプログラムが終了します
\end{verbatim}
\end{waku}
\item{問題\stepcounter{question}\thequestion (★☆☆☆☆)} 上に挙げた方法の動作をそれぞれ確認しましょう．
\end{description}

\subsection{ありがちなミス，対処法}
\begin{description}
\item{解説} スクリプトを作成中に起こるありがちなバグというものがあります．しかしそれに対する対処法を知っているとデバグが楽になります．以下にエラーメッセージ\index{えらーめっせーじ@エラーメッセージ}の例を示します．\\
\item{事例1} 変数の宣言忘れ or タイプミス or $\$ $等のつけ忘れ\\
\begin{waku}
\begin{verbatim}
・Global symbol "$hoge" requires explicit package name
・Bareword "hoge" not allowed while "strict subs"
・Odd number of elements in hash assignment
・HASH(0x9441c18)
・Type of arg 1 to keys must be hash (not private array)
\end{verbatim}
\end{waku}

\item{事例2} FILEが開けなかった or 外部環境が整っていない or ヘッダーが変\\
\begin{waku}
\begin{verbatim}
・Can't locate hoge.pm in @INC…
・Command not found.
\end{verbatim}
\end{waku}

\item{事例3} カッコの数があっていない\\
\begin{waku}
\begin{verbatim}
・Missing right curly or square bracket
・コードのないところでのエラーメッセージ
\end{verbatim}
\end{waku}

\item{事例4} 無限ループ or 深すぎる再帰\\
\begin{waku}
\begin{verbatim}
・Deep recursion on subroutine "main::hoge"
・プログラムが止まらない．
\end{verbatim}
\end{waku}

\item{事例5} フォーマットの読み間違い\\
\begin{waku}
\begin{verbatim}
・substr outside of string
・Use of uninitialized value
\end{verbatim}
\end{waku}
\item{問題\stepcounter{question}\thequestion (★☆☆☆☆)} 上に挙げたエラーを実際に出力させてみましょう．プログラムが止まらなくなってしまったらCtrl+Cで強制終了させることができます．
\end{description}

\section{モジュール\index{もじゅーる@モジュール}}
\subsection{作り方}
\begin{description}
\item{解説} \verb|プログラムの一部を別のファイルに記述し，後でそれを読み込み利用することが出来ます．この別ファイルのことをモジュールといいます．モジュールを活用することでプログラムの再利用性や可読性を向上させることが出来ます．以下は最低限の要件を満たしたモジュールの書き方です．|
\begin{waku}
\begin{verbatim}
#!/usr/bin/env perl
use strict;
package My_module;
require Exporter;
our @ISA = qw(Exporter AutoLoader);

our @EXPORT = qw(
                 hello_world
);
our $VERSION = '1.0';

sub hello_world{
    print “hello_world\n”;
}

1;
__END__
\end{verbatim}
\end{waku}
\item{問題\stepcounter{question}\thequestion (★☆☆☆☆)} 上の例文をMy$\_$module.pmというファイルに保存しましょう．
\end{description}

\subsection{使い方}
\begin{description}
\item{解説} \verb|use\index{use}関数を用いてモジュールをインポートすることが出来ます．|\\
\begin{waku}
\begin{verbatim}
use My_module;
hello_world;
\end{verbatim}
\end{waku}
\item{問題\stepcounter{question}\thequestion (★☆☆☆☆)} 上のようにして，作ったモジュールを利用してみましょう．
\item{問題\stepcounter{question}\thequestion (★☆☆☆☆)} nstore\index{nstore}を使って変数を保存し，さらに別のプログラムで再利用してみましょう．
\item{問題\stepcounter{question}\thequestion (★☆☆☆☆)} 任意のプログラム(Matinspector, clustalW, G等)を動かすexpectを作成し，それと組み合わせたモジュールを作成してください．そして引数を与えて実行しましょう．
\end{description}

\section{略記法，慣用句，定石}
\subsection{$\$ \_$を使う}
\begin{description}
\item{解説} 基本的に関数，ループ，演算子は引数を与えなくてはいけませんが，与えなかった場合デフォルトの引数を考慮してくれます．これを逆手にとって省略した書き方が可能です．デフォルトの引数には\verb|$_，@_，@ARGV，STDIN|などがあります．\\
\begin{waku}
\begin{verbatim}
printf “%s\t%s\n”, (split)[0, 7] for `w`;
\end{verbatim}
\end{waku}
\item{問題\stepcounter{question}\thequestion (★☆☆☆☆)} 上のコードを省略のない形に戻しましょう．
\end{description}

\subsection{カッコを減らす}
\begin{description}
\item{解説} いままでもでてきましたが，関数のデフォルトや特殊なループ表現を用いると，余計なカッコを減らすことが出来ます．無理に減らすのは逆効果ですが，決まったパターンの省略法を身につけると見やすいプログラムが書けます．例えば下の式は皆同じ意味です．\\
\begin{waku}
\begin{verbatim}
#i
foreach my $i(@array){
    my @elm = split(/ /, $i);
    print “$elm[0]\t$elm[1]\n”;
}

#ii
for(@array){
    my @elm = split(/ /, $i);
    printf “%s\t%s\n”, @elm[0,1];
}

#iii
printf “%s\t%s\n”, (split)[0,1] for @array;
\end{verbatim}
\end{waku}
\item{問題\stepcounter{question}\thequestion (★☆☆☆☆)} 今まで書いてきたコードを見直し，カッコが減らせる箇所がないか探して見ましょう．
\end{description}

\subsection{関数のデフォルト設定を生かす}
\begin{description}
\item{解説} \verb|関数のデフォルト設定を生かすと余分なコードが減り，見やすくなります．ユーザ関数の中でデフォルト設定を行いたいときは以下のように書くと良いでしょう|\\
\begin{waku}
\begin{verbatim}
sub hoge{	
    my($foo, $bar) = @_;
    $foo ||= 10;
    $bar ||= ‘atg’;
}
\end{verbatim}
\end{waku}
\item{問題\stepcounter{question}\thequestion (★☆☆☆☆)} デフォルト設定にはどういうものがあるか調べてみましょう．特に
\begin{itemize}
\item chomp
\item m//
\item s///g
\item shift
\item split
\end{itemize}
はデフォルト設定について把握しておきましょう．

\end{description}

\chapter{実践 Bioinformatics}

この章ではPerlのレファレンスの使い方を徹底的にマスターし，配列の重み行列の作成など配列解析に応用できる技術の取得を目指します．


\section{Perlによるシグナル配列の解析}


\subsection{ハッシュの復習}\index{はっしゅ@ハッシュ}
\begin{description}
\item{解説} Perlでハッシュは非常に頻繁に使われます．ある要素と他の要素を簡単に関係付けることができるので，非常に便利です．例えば，あるタンパク質がどのような機能を持っているかを記録していくときに，\\
\begin{waku}
\begin{verbatim}
my %func;
\end{verbatim}
\end{waku}\\
で，タンパク質名と機能を対応させるハッシュの変数を定義することができます．\\
\begin{waku}
\begin{verbatim}
$func{ "SAM1" } = "Metabolism";
$func{ "CRM1" } = "Transport";
$func{ "TAF25" } = "Transcription";
\end{verbatim}
\end{waku}\\
で実際にタンパク質名と機能とを対応させることができます．タンパク質名は“キー”となり，機能はその“値”となります．\\
\begin{waku}
\begin{verbatim}
my @proteins = keys(%func);
\end{verbatim}
\end{waku}\\
は\verb|%|funcに登録されている全てのキーを抽出し，配列に入れます．キーの順序は決まっていません．\\
\begin{waku}
\begin{verbatim}
foreach my $protein (@proteins){
   print "$protein\t$func{$protein}\n";
}
\end{verbatim}
\end{waku}\\
こうすると，登録されているタンパク質名とその機能の一覧が出力されます．あるキーがハッシュに登録されているかを調べるには，definedを使います．\\
\begin{waku}
\begin{verbatim}
if(defined($func{ "TAF25" })){
   print $func{ "TAF25" }, "\n"; 
}
\end{verbatim}
\end{waku}\\
\item{問題\stepcounter{question}\thequestion } タブ区切りのタンパク質間相互作用\index{たんぱくしつそうごさよう@タンパク質間相互作用}データのファイルと，タンパク質の機能を示したファイルをもとに，相互作用するタンパク質の機能を次のように表示していくプログラムを作成しましょう．

\begin{waku}
\begin{verbatim}
タンパク質A	タンパク質B	タンパク質Aの機能	タンパク質Bの機能
タンパク質C	タンパク質D	タンパク質Cの機能	タンパク質Dの機能
タンパク質E	タンパク質F	タンパク質Eの機能	タンパク質Fの機能
                             :
\end{verbatim}
\end{waku}\\\\
タンパク質間相互作用ファイルの例：\\
\begin{waku}
\begin{verbatim}
ACS2   SNP1
ACT1   ABP1
ACT1   AIP1
BRR2   SNP1
\end{verbatim}
\end{waku}\\
タンパク質の機能ファイルの例：\\
\begin{waku}
\begin{verbatim}
ABP1   Vesicular_transport
ACS2   Carbohydrate_metabolism
ACT1   Vesicular_transport
AIP1   Cell_structure
BRR2   RNA_splicing
SNP1   RNA_splicing
\end{verbatim}
\end{waku}\\
結果の例：\\
\begin{waku}
\begin{verbatim}
ACS2   SNP1   Carbohydrate_metabolism   RNA_splicing
ACT1   ABP1   Vesicular_transport   Vesicular_transport
ACT1   AIP1   Vesicular_transport   Cell_structure
BRR2   SNP1   RNA_splicing   RNA_splicing
\end{verbatim}
\end{waku}\\
\item{問題\stepcounter{question}\thequestion } タンパク質間相互作用データのファイル中で各タンパク質が何回登場するか，ハッシュを用いてカウントして出力しましょう．
\end{description}

\subsection{関数へのリファレンスの受け渡し}\index{りふぁれんす@リファレンス}
\begin{description}
\item{解説} \verb|関数で直接複数の配列や複数のハッシュを受け取ることはできません．例えば次は配列@aと@bの要素を先頭から掛け合わせてその総和を計算する関数i_productを定義していますが，これでは正しく動きません．|\\
\begin{waku}
\begin{small}
\begin{verbatim}
#!/usr/bin/env perl

use strict;    # 全ての変数をmyで宣言するように強制する
use warnings;  # プログラム動作に不合理な点があったときに警告を出す

sub i_product {
   my(@vector1, @vector2) = @_;
   my $total = 0;
   foreach my $i (0..$#vector1){
      $total += $vector1[$i] * $vector2[$i];
   }
   return $total;
}

my @a = (1,2,3);
my @b = (4,5,6);
print i_product(@a, @b);
\end{verbatim}
\end{small}
\end{waku}\\
\verb|なぜなら，i_product(@a, @b)としたときに，@aと@bの中味が展開され(1,2,3,4,5,6)となり，@aと@bの境界がなくなってしまうからです．このケースでは，@vector1に(1,2,3,4,5,6)が入ってしまい，@vector2には何も入りません．|
\verb|そこで配列そのものではなく，配列へのリファレンスを渡すことでこの問題を回避します．リファレンスは数値や文字列と同じ部類であるスカラーに入るので，問題なく複数のリファレンスの受け渡しを行うことができます．|\\
\begin{waku}
\begin{verbatim}
#!/usr/bin/env perl

use strict;    # 全ての変数をmyで宣言するように強制する
use warnings;  # プログラム動作に不合理な点があったときに警告を出す

sub i_product {
   my($vector_ref1, $vector_ref2) = @_;
   my $total = 0;
   foreach my $i (0..$#$vector_ref1){
      $total += $vector_ref1->[$i] * $vector_ref2->[$i];
   }
   return $total;
}

my @a = (1,2,3);
my @b = (4,5,6);
print i_product(\@a, \@b);
\end{verbatim}
\end{waku}
\begin{itemize}
\item \verb|@aは配列(1,2,3)を表します．|
\item \verb|$vector_ref1は配列(1,2,3)へのリファレンスを表します．|
\item \verb|@$vector_ref1は配列(1,2,3)を表します．これは@aと等価です．|
\item \verb|$$vector_ref1[1]および$vector_ref1->[1]は配列@$vector_ref1の1番目の要素，つまり2を表します（0番目から数える）．|
\end{itemize}
配列だけでなく，ハッシュもリファレンスにして関数に渡すことができます．例えば下のプログラム(一部)を考えてみましょう．\\
\begin{waku}
\begin{verbatim}
sub test_hash_ref {
   my($h1_ref, $h2_ref) = @_;
   print $h1_ref->{ "height" }, "\n";
   print $h2_ref->{ "weight" }, "\n";
}

my %c = ("height" =>160, "weight" => 55);
my %d = ("height" =>175, "weight" => 70);
test_hash_ref(\%c, \%d);
\end{verbatim}
\end{waku}
\begin{itemize}
\item \verb|%cはハッシュ(“height” =>160, “weight”=> 55)を表します．|
\item \verb|$h1_refはハッシュ("height" => 160, "weight" => 55)へのリファレンスを表します．|
\item \verb|%$h1_refはハッシュ(“height” =>160, “weight”=> 55)を表します．これは%cと等価です．|
\item \verb|$$h1_ref{“height”}および$h1_ref->{“height”}は160を表します．|
\end{itemize}
\item{問題\stepcounter{question}\thequestion } \verb|配列へのリファレンスとハッシュへのリファレンスを受け取り，配列をハッシュに従って置き換えたものを返す関数hash_transを作成しましょう．例えば，@a = (“a”, “b”, “a”, “c”)，%h = (“a” => “apple”, “b”=> “banana”, “c” => “candy”)としてhash_trans(\@a, \%h)とすると，(“apple”, “banana”, “apple”, “candy”)が返ってくるようにします．|
\end{description}

\subsection{リファレンスを含む配列とハッシュ}
\begin{description}
\item{解説} 今まで配列で扱ってきた要素は数値か，文字列でした．\\
\begin{waku}
\begin{verbatim}
@array = (“a”, “t”, “g”, “c);
\end{verbatim}
\end{waku}\\
しかしそれ以外に，配列へのリファレンスを配列の要素とすることができます(refはリファレンスを表します)．

\begin{verbatim}
     ("a", "t", ref, "g")
                 ↓
                 (0, 1, 2, 3)
\end{verbatim}

上記を実現するためには，\\
\begin{waku}
\begin{verbatim}
@array2 = (“a”, “t”, [0, 1, 2, 3], “g”);
\end{verbatim}
\end{waku}\\
とします．あるいは，\\
\begin{waku}
\begin{verbatim}
@array3 = (0, 1, 2, 3);
\end{verbatim}
\end{waku}\\
という代入をしておき，\\
\begin{waku}
\begin{verbatim}
@array2 = (“a”, “t”, \@array3, “g”);
\end{verbatim}
\end{waku}\\
とすることもできます．この場合は@array3を操作すると，@array2の中味に影響が出ます．ここで，\\
\begin{itemize}
\item \verb|$array2[1]は”t”を表します．|
\item \verb|$array2[2]は(0, 1, 2, 3)へのリファレンスを表します．|
\item \verb|@{$array2[2]}は(0, 1, 2, 3)を表します．|
\item \verb|${$array2[2]}[3]は3を表します．もう少し見やすい表記で，$array[2]->[3]も3を表します．これをうまく使いこなすと，二次元配列の表現が可能になります．|
\end{itemize}
同様にして下の例のように，ハッシュへのリファレンスを含む配列を作ることも可能です．

\begin{verbatim}
     ("a", "t", ref, "g")
                 ↓
                 ("X" => 123, "Y" => 456)
\end{verbatim}

\begin{waku}
\begin{verbatim}
@array4 = (“a”, “t”, {“X”=>123, “Y”=>456}, “g”);
\end{verbatim}
\end{waku}\\
\begin{itemize}
\item \verb|$array4[2]は{“X”=>123, “Y”=>456}へのリファレンスを表します．|
\item \verb|%{$array4[2]}は{“X”=>123, “Y”=>456}を表します．|
\item \verb|${$array4[2]}{“X”}は123を表します．もう少し見やすい表記で，$array4[2]->{“X”}も123を表します．|
\end{itemize}

リファレンスを要素に持つハッシュを作ることも可能です．
\begin{verbatim}
     ("X" => 100, "Y" => ref, "Z" => 200)
                          ↓
                          ("a" => 12, "t" => 45)
\end{verbatim}

これを実現させるためには例えば，次のようにします．\\
\begin{waku}
\begin{verbatim}
%hash1 = (“X”=>100, “Y”=>{“a”=>12, “t”=>45}, “Z”=>200);
\end{verbatim}
\end{waku}\\
\begin{itemize}
\item \verb|$hash{“X”}は100を表します．|
\item \verb|$hash{“Y”}は{“a”=>12, “t”=>45}へのリファレンスを表します．|
\item \verb|%{$hash{“Y”}}は{“a”=>12, “t”=>45}を表します．|
\item \verb|${$hash{“Y”}}{“a”}は12を表します．もう少し見やすい表記で，$hash{“Y”}->{“a”}も12を表します．|
\end{itemize}

\item{問題\stepcounter{question}\thequestion } 配列へのリファレンスからなる配列の中味を表示する関数showarray2dを作成しましょう．\\
\begin{waku}
\begin{verbatim}
@a = ([1,2], [2,3], [1,1]);
print show_array_2d(@a);
\end{verbatim}
\end{waku}\\
とすると\\
\begin{waku}
\begin{verbatim}
1,2
2,3
1,1
\end{verbatim}
\end{waku}\\
のような出力が得られるようにします．\\

\item{問題\stepcounter{question}\thequestion } 行列\index{ぎょうれつ@行列}計算をする関数mproductを作成しましょう．\\
\begin{waku}
\begin{verbatim}
@a = ([1,2],[2,3],[1,1]);
@b = ([2,1],[1,2])
@c = m_product(\@a, \@b);
\end{verbatim}
\end{waku}\\
とすると，下記の計算が行われます．
\begin{displaymath}
\left(
\begin{array}{cc}
1&2\\
2&3\\
1&1
\end{array}
\right)
\left(
\begin{array}{cc}
2&1\\
1&2
\end{array}
\right)
=\left(
\begin{array}{cc}
4&5\\
7&8\\
2&3
\end{array}
\right)
\end{displaymath}
このとき，\@cは([4,5], [7,8], [3,3])となるようにしましょう．
\end{description}

\newpage

\subsection{重み行列の作成}\index{おもみぎょうれつ@重み行列}
\begin{description}
\item{解説} 転写開始部位周辺や，開始コドン周辺は特定の塩基で偏っていることが知られています．どの位置でどの塩基にどれくらいの偏りがあるかを表現する１つの方法が重み行列を使うことです．\\
今，以下の開始コドン周辺の塩基配列を例にとりましょう．囲みが開始コドンです．\\
\begin{waku}
agt\fbox{atg}act\\
cac\fbox{atg}aac\\
tag\fbox{atg}aga\\
tac\fbox{atg}cga\\
agc\fbox{atg}aga
\end{waku}\\
開始コドンのaの位置を0とし，その上流に行くに従って位置を1だけ引いていき，下流に行くに従って1だけ足していきます．すると各位置における各塩基の頻度を表した以下のような表ができます．

\begin{table}[h]
\begin{center}
\caption{度数表}
\begin{tabular}{cccccccccc}\hline
&-3&-2&-1&0&1&2&3&4&5\\\hline
A&2&3&0&5&0&0&4&1&3\\\hline
C&1&0&3&0&0&0&1&1&1\\\hline
G&0&2&1&0&0&5&0&3&0\\\hline
T&2&0&1&0&5&0&0&0&1\\\hline
\end{tabular}
\end{center}
\end{table}

これを割合に直すと，以下のようになります．
\begin{table}[h]
\begin{center}
\caption{重み行列}
\begin{tabular}{cccccccccc}\hline
&-3&-2&-1&0&1&2&3&4&5\\\hline
A&0.4&0.6&0.0&1.0&0.0&0.0&0.8&0.2&0.6\\\hline
C&0.2&0.0&0.6&0.0&0.0&0.0&0.2&0.2&0.2\\\hline
G&0.0&0.4&0.2&0.0&0.0&1.0&0.0&0.6&0.0\\\hline
T&0.4&0.0&0.2&0.0&1.0&0.0&0.0&0.0&0.2\\\hline
\end{tabular}
\end{center}
\end{table}

\verb|これを重み行列(weight matrix)といいます．重み行列はハッシュおよびリファレンスを使うと簡単に表現できます．重み行列を表すハッシュを%matrixとして，例えば$matrix{ -2 }->{ “c” }を-2の位置のcの頻度を表す数値にするのが分かりやすいでしょう．では，ここで与えられた塩基配列群から行列%matrixを返す関数return_matrixを作ってみましょう．|\\
\begin{waku}
\begin{verbatim}
sub return_matrix {
   my($seqs_ref, $start) = @_;
   # $seqs_refは塩基配列群へのリファレンス
   # $startが位置0を塩基配列の何番目にするかという数字
   my %matrix;
   my $j = 0;
   
   my $counted_flag; # 0か1の値を取るフラッグ．
   # 0: 長さ$j+1以上の配列が一本もない
   # 1: 長さ$j+1以上の配列が少なくとも一本はある

    do {
        $counted_flag = 0;
        for my $i (0..$#$seqs_ref){ # 配列の数だけ繰り返す
            if($j < length($seqs_ref->[$i])){ 
               # 配列一本の長さが$j+1以上かどうか確認．
            $counted_flag = 1; # フラッグを立てる
            my $nuc = substr($seqs_ref->[$i], $j, 1);
            # 対象配列の$j番目の塩基を取り出す．
            $matrix{ $j - $start }->{ $nuc } ++;
            # 行列中の値に反映させる
         } 
      }
      $j ++;
   } while ($counted_flag);

   return %matrix;
}
\end{verbatim}
\end{waku}\\
なお\\\index{do while}
\begin{waku}
\begin{verbatim}
do {“処理”} while(“条件”);
\end{verbatim}
\end{waku}\\
で，まず1回“処理”を行い，次からは“条件”が成立するときに“処理”を繰り返します．\\
\verb|上記プログラムを作成した上で下のように関数を呼び出すと，3番目の塩基を位置0としたときの行列%matrixを作成することができます．|\\
\begin{waku}
\begin{verbatim}
my @sequences = (
   "agtatgact",
   "cacatgaac",
   "tagatgaga",
   "tacatgcga",
   "agcatgaga");
my %matrix = return_matrix(\@sequences, 3);
\end{verbatim}
\end{waku}\\

\item{問題\stepcounter{question}\thequestion } 上記プログラムで，行列中の数値は度数そのもので，割合にはなっていません．これを割合にするようにプログラムを改良しましょう．
\verb|下記のdips_w_matrix関数は，重み行列$wm_ref(リファレンス)と表示開始位置$pos_from，表示終了位置$pos_toを受け取ると，その区間の重み行列を表示します．|\\
\begin{waku}
\begin{verbatim}
sub disp_w_matrix($$$){
    my($wm_ref, $pos_from, $pos_to) = @_;

    printf("%3s", " ");
    for my $position ($pos_from..$pos_to){
        printf("\t%4d", $position);
    }
    print "\n";

    printf("%3s", "--");
    for my $position ($pos_from..$pos_to){
        printf("\t%4s", "----");
    }
    print "\n";

    foreach my $nuc ("a", "c", "g", "t"){
        printf("%3s", $nuc);
        for my $position ($pos_from..$pos_to){
            my $val = $wm_ref->{$position}->{$nuc};
            if(!defined($val)){ $val = 0; }
            printf("\t%.2lf", $val);
        }
        print "\n";
    }
    print "\n";
}
\end{verbatim}
\end{waku}\\
\verb|下記の呼び出しで，重み行列%mの位置-1から2までの内容が表示されます．|\\
\begin{waku}
\begin{verbatim}
disp_w_matrix(\%m, -1,2);
\end{verbatim}
\end{waku}\\
\end{description}

\subsection{シグナル配列の探索}
\begin{description}
\item{解説} 今度は1塩基ごとではなく，複数の塩基配列パターンとして特異的なシグナルを検出する方法を学びます．\\
\begin{waku}
ac\fbox{agg}tagtatgact\\
caa\fbox{agg}tcaatgaac\\
ta\fbox{agg}ctcgatgaga\\
ta\fbox{agg}catcatgcga\\
agc\fbox{agg}ctgatgaga
\end{waku}\\

\verb|-7の位置の”agg”の出現度数は3，出現割合は3/5=0.6，-6の位置の”agg”の出現度数は2，出現割合は2/5=0.4になります．このように与えられた配列と位置，パターンに対して，度数やその割合を求める関数を作成しましょう．|\\
\begin{waku}
\begin{verbatim}
sub calc_freq($$$){
   my($seq_set_ref, $pos, $pat) = @_;
   # $seq_set_ref 塩基配列群へのリファレンス
   # $pos 求める位置．但し，塩基配列群の先頭の位置を0とする
   # $pat 出現頻度を求めるパターン

   my $total = 0; # 解析対象となった配列の数
   my $count = 0; # 配列パターン$patが位置$posに検出された配列数

   foreach my $seq (@$seq_set_ref){
      if($pos + length($pat) - 1 < length($seq) &&
         substr($seq, $pos, length($pat)) =~ /^[acgt]+$/){
         # $posが配列の長さを超えないかの確認と，
         # a,c,g,t以外の塩基が含まれないかの確認
            $total ++;
            if(substr($seq, $pos, length($pat)) eq $pat){
               $count ++; # 配列パターンが$patにマッチ
            }
      }
   }

   return($count, $total);

}
\end{verbatim}
\end{waku}\\
上記関数を例えば\\
\begin{waku}
\begin{verbatim}
my @sequences = (
   "acaggtagtatgact",
   "caaaggtcaatgaac",
   "taaggctcgatgaga",
   "taaggcatcatgcga",
   "agcaggctgatgaga");
my($count, $total) = calc_freq(\@sequences, 3, “agg”);
\end{verbatim}
\end{waku}\\
\verb|のように呼び出すと，3番目の位置に”agg”というパターンが出現する回数が数えられ，$countに2, $totalに解析対象となった配列数5が入ります．$count / $totalは出現割合を表します．|\\

\verb|実際にはどのパターンがどの位置で顕著に出現するかは分かりません．そこで決められた範囲内における決められた長さの塩基配列パターンの頻度を全て調べる必要があるでしょう．次はある範囲内(下の例では先頭から0番目〜10番目の位置)の特定のパターン（下の例では”agg”）の頻度をプロットしていくプログラムの一例です．|\\
\begin{waku}
\begin{verbatim}
foreach my $pos (0..10){ # 調べる位置の範囲
   my($count, $total) = calc_freq(\@seq, $pos, "agg");
   print "$pos\t", $count / $total, "\n";
}
\end{verbatim}
\end{waku}\\
\verb|ハッシュを使うと，全パターンを１度に網羅することができます．下記の関数calc_freq_allでは，与えられた配列群$seq_set_refの中の指定された位置$posの決められた長さ$lenの塩基配列の出現回数をハッシュ%countで数えます．|\\
\begin{waku}
\begin{verbatim}
sub calc_freq_all($$$){
  my($seq_set_ref, $pos, $len) = @_;
  # $seq_set_ref 塩基配列群へのリファレンス
  # $pos 求める位置．但し，塩基配列群の先頭の位置を0とする
  # $pat 出現頻度を求めるパターン
  
  my $total = 0; # 解析対象となった配列の数
  my %count; # 配列パターンが位置$posに検出された配列数
  
  foreach my $seq (@$seq_set_ref){
    if($pos + $len - 1 < length($seq) &&
       substr($seq, $pos, $len) =~ /^[acgt]+$/){
      # $posが配列の長さを超えないかの確認と，
      # a,c,g,t以外の塩基が含まれないかの確認
      $total ++;
      $count{ substr($seq, $pos, $len) } ++; # パターンの出現頻度を数える
    }
  }
  return(\%count, $total);
}
\end{verbatim}
\end{waku}\\
上記関数を例えば\\
\begin{waku}
\begin{verbatim}
my @sequences = (
   "acaggtagtatgact",
   "caaaggtcaatgaac",
   "taaggctcgatgaga",
   "taaggcatcatgcga",
   "agcaggctgatgaga");
my($count, $total) = calc_freq_all(\@sequences, 2, 3);
\end{verbatim}
\end{waku}\\
\verb|で，$count(この場合はリファレンスになります)に塩基配列の全パターンの出現回数を記録し，|\\
\begin{waku}
\begin{verbatim}
print $count->{"agg"}, “\n";
\end{verbatim}
\end{waku}\\
で例えば”agg”の出現回数を出力することができます．
\item{問題\stepcounter{question}\thequestion } \verb|決められた範囲($pos1から$pos2)において，特定位置に最も出現する4塩基パターンと，その位置を求める関数を作成しましょう．|
\end{description}

\newpage

\section{Perlによる遺伝子発現データ\index{いでんしはつげんでーた@遺伝子発現データ}の解析}
\subsection{遺伝子発現データとは}

遺伝子発現データは，各遺伝子がどのような時期または組織，条件で発現してい
るかを表した数値データです．そして同時期に発現している遺伝子のグループは，同一
の機能を持っている可能性が高いことが知られています．同時期に発現している
かを測る指標が相関係数です．

今遺伝子1の発現データ
$x_{11},x_{12},x_{13},\ldots ,x_{1n} $と，遺伝子２の発現データ
$x_{21},x_{22},x_{23},\ldots  x_{2n}$が与えられたとき，相関係数$r_{12}$
の計算式は以下の通りです．

\begin{displaymath}
\left\{
\begin{array}{l}
r_{12}=\frac{1}{n}\sum_{j=1}^{n}z_{1j}z_{2j} \\
z_{ij}=\frac{x_{ij}-\overline{x}_{i}}{\sigma_{i}}
\end{array}
\right.
\end{displaymath}

ここで，$\overline{x}_{1}$は遺伝子１の発現量の平均，$\overline{x}_{2}$は
遺伝子2の発現量の平均を表します．また，$\sigma_{1}$は遺伝子1の発現量の標
準偏差，$\sigma_{2}$は遺伝子2の発現量の標準偏差を表します．つまり平均と
標準偏差を求めることができれば，相関係数を求めることができるのです．

\subsection{平均\index{へいきん@平均}の計算}
\begin{description}
\item{解説} まず与えられた配列の平均値を計算する関数を実装してみましょう．\\
\begin{waku}
\begin{verbatim}
sub average {
   my @data = @_;
   my $ndata = $#data + 1;
   my $total = 0;

   # @dataの合計を$totalに入れる処理

   return $total / $ndata;
}
\end{verbatim}
\end{waku}\\
以下の文で関数の動作確認ができます．2.5と表示されれば成功です．\\
\begin{waku}
\begin{verbatim}
my @x1 = (1.0, 2.0, 3.0, 4.0);
print average(@x1);
\end{verbatim}
\end{waku}\\
\item{問題\stepcounter{question}\thequestion } 平均を求める関数averageを実装しましょう．
\end{description}

\subsection{標準偏差\index{ひょうじゅんへんさ@標準偏差}の計算}
\begin{description}
\item{解説} 標準偏差の計算には次のような関数を作ります．\\
\begin{waku}
\begin{verbatim}
sub sdev {
  my @data = @_;
  my $ndata = $#data + 1;
  my $average = average(@data);
  my $dev_total2 = 0;

  # (@dataの各要素 - @dataの平均)2の合計を$totalに入れる処理
   return sqrt($dev_total2 / $ndata);
}
\end{verbatim}
\end{waku}\\
以下の動作確認で2という答えが返ってくれば成功です．\\
\begin{waku}
\begin{verbatim}
my @x1 = (-1.0, -1.0, 3.0, 3.0);
print sdev(@x1);
\end{verbatim}
\end{waku}
\item{問題\stepcounter{question}\thequestion } 標準偏差を求める関数sdevを実装しましょう．
\end{description}

\subsection{相関係数\index{そうかんけいすう@相関係数}の計算}
\begin{description}
\item{二つの配列の読み込み}\\
相関係数を計算するには，２つの配列を読み込む必要があります．配列が２つもあるので，リファレンスを使って配列を関数に渡してあげなければなりません．\\\\
リファレンスの受け取りと，配列の中味の確認は次のように行うことができます．\\
\begin{waku}
\begin{verbatim}
sub correlation {
   my $data1 = $_[0];
   my $data2 = $_[1];
　 print join(“,”, @$data1), “\n”;
   print join(“,”, @$data2), “\n”;
}
\end{verbatim}
\end{waku}\\
またリファレンスを関数に渡すには，\\
\begin{waku}
\begin{verbatim}
my @x1 = (1,3,5,7,9);
my @x2 = (0,2,4,6,8);
correlation(\@x1, \@x2);
\end{verbatim}
\end{waku}\\
のようにします．
\item{問題\stepcounter{question}\thequestion } 配列のリファレンスの受け渡しがちゃんとなされているか，上記プログラムは打ち込んで確認しましょう．

\item{欠損部分を排除}\\
各遺伝子に関して常に発現データを取得することができるとは限りません．そこで欠損部部を取り除く必要があります．\\
\begin{center}
\fbox{
\begin{tabular}{l}
$@\$ $data1 = (1, 2,0,””,5);\\
$@\$ $data2 = (0,””,3, 6,7);
\end{tabular}
}
→
\fbox{
\begin{tabular}{l}
$@$data1m = (1,0,5);\\
$@$data2m = (0,3,7);
\end{tabular}
}
\end{center}
この操作は次のように書くことができます．実際に打ち込んで動作を確認しましょう．\\
\begin{waku}
\begin{verbatim}
sub correlation {
  my $data1 = $_[0];
  my $data2 = $_[1];
  my @data1m;
  my @data2m;
  for my $i (0..$#$data1){
    if(defined($data1->[$i]) && $data1->[$i] =~ /\d/ &&
       defined($data2->[$i]) && $data2->[$i] =~ /\d/){
      push(@data1m, $data1->[$i]);
      push(@data2m, $data2->[$i]);
    }
  }
  print join(",", @data1m), "\n";
  print join(",", @data2m), "\n";
}
\end{verbatim}
\end{waku}

\item{相関係数を求める}\index{そうかんけいすう@相関係数}\\
最後に相関係数を求める関数を完成させましょう．次のようになるはずです．\\
\begin{waku}
\begin{verbatim}
sub correlation {
  my $data1 = $_[0];
  my $data2 = $_[1];
  my @data1m;
  my @data2m;
  for my $i (0..$#$data1){
    if(defined($data1->[$i]) && $data1->[$i] =~ /\d/ &&
       defined($data2->[$i]) && $data2->[$i] =~ /\d/){
      push(@data1m, $data1->[$i]);
      push(@data2m, $data2->[$i]);
    }
  }
  
  my $corr = 0;
  my $ndata = $#data1m + 1;  
  my $average1 = average(@data1m);
  my $average2 = average(@data2m);
  my $sdev1 = sdev(@data1m);
  my $sdev2 = sdev(@data2m);
  for my $i (0..$#data1m){
    $corr += 1.0/$ndata *
      ($data1m[$i] - $average1)*($data2m[$i] - $average2)
        / ($sdev1 * $sdev2);
  }   
  return $corr;
}
\end{verbatim}
\end{waku}\\
動作確認は以下のように行います．-1という答えが出れば成功です．\\
\begin{waku}
\begin{verbatim}
my @x1 = (1,"",-3, 7,-7);
my @x2 = (0, 2, 4,"", 8);
print correlation(\@x1, \@x2);
\end{verbatim}
\end{waku}\\
\item{問題\stepcounter{question}\thequestion } 相関係数を求めるプログラムを完成させましょう．
\end{description}

\subsection{遺伝子発現データのファイルからの読み込み}

\begin{figure}
\begin{center}
\includegraphics[scale=0.6]{Figs/geneexp_sample1.eps}
\end{center}
\vspace{-2em}
\caption{遺伝子発現データファイルの構造例(上)とハッシュによる管理(下)}
\label{geneexp_sample1}
\vspace{3em}
\end{figure}

\begin{description}
\item{解説} 
発現データファイルには一般的に図\ref{geneexp_sample1}(上)のように、各時期・組織における発現量が遺伝子ID・シンボル名やその遺伝子の機能情報
とともに表形式で並べられています。そこで図\ref{geneexp_sample1}(下)に示すように，遺伝子IDが与えられたときに，対応する発現パターンを配列へのリファレンスで返すようなハッシュを作成します．以下のプログラムを打ち込んで，ハッシュによる遺伝子IDと遺伝子発現パターンの対応付けができることを確認しましょう．\\
\begin{waku}
\begin{verbatim}
my %exp;
my @exp = (127.0, 487.0, 126.0, 84.0, 385.0, 82.0, 99.0, 274.0);
$exp{ "84694" } = [ @exp ];
print join(",", @{$exp{ "84694" }});
\end{verbatim}
\end{waku}\\
次に，与えられた発現データファイルより，遺伝子IDとその発現パターンを上記のようにハッシュで結びつける関数を書きましょう．
各行を@rに読み込んだら、shiftで先頭の情報を抜き出し、残りを発現情報としてハッシュに登録します．\\
\begin{waku}
\begin{verbatim}
sub read_expression {
  my $filename = $_[0];
  local *FH;
  my %exp;
  open(FH, $filename);
  my $header = <FH>;
  while(<FH>){
    chomp;
    my @r = split(/\t/);
    my $gene_id     = shift @r;  # 遺伝子IDの読み込み
    my $gene_symb   = shift @r;  # 遺伝子シンボルの読み込み
    my $probe_id    = shift @r;  # マイクロアレイのプローブIDの読み込み
    my $description = shift @r;  # 遺伝子に関する情報
    $exp{ $gene_id } = [ @r ];
  }
  close FH;
  return %exp;

}
\end{verbatim}
\end{waku}
\item{問題\stepcounter{question}\thequestion } 図\ref{geneexp_sample1}のデータをタブ区切りのファイルにしてからそれをプログラムで読み込み、"84694(CX62)"と"85439(STN2)"の遺伝子発現パターンの相関係数を求めましょう．
\item{問題\stepcounter{question}\thequestion } 図\ref{geneexp_sample1}で相関係数が0.2以上の遺伝子のペアを列挙しましょう．
\end{description}

\newpage

\section{分子間ネットワークの解析}

\begin{figure}
\begin{center}
\vspace{1em}
\includegraphics[scale=0.6]{Figs/pdi_sample1.eps}
\end{center}
\vspace{-1em}
\caption{転写制御ネットワークの例}
\label{pdi_sample1}
\vspace{3em}
\end{figure}

\subsection{Perlによるグラフ表現}
\label{perl_graph1}

\begin{description}
\item[解説] 細胞内では遺伝子やタンパク質、代謝物質など様々な因子が相互作用して生命現象を起こしています。
分子間のつながりの集合のことを分子間ネットワーク\index{ぶんしかんねっとわーく@分子間ネットワーク}と呼びます。
分子と分子の間のつながりは数学ではグラフ\index{グラフ}を用いて扱うことができます。Perlではグラフをハッシュおよびハッシュへの
リファレンスを用いるとうまく表現できます。例えば図\ref{pdi_sample1}では、Mcm1がSwi4の転写制御\index{てんしゃせいぎょ@転写制御}をしていますが、
このMcm1 → Swi4という関係はハッシュ(以下の例ではハッシュ\%pdiがグラフを表す)とそのリファレンスを用いて

\begin{waku}
\begin{verbatim}
my %pdi = (
  "Mcm1" => { "Swi4" => "" }
);
\end{verbatim}
\end{waku}\\
と表すことができます。つまり\%pdiのキーを\verb|"Mcm1"、値を { "Swi4" => "" }|にしていることになります。直感的に
説明するならば、"Mcm1"を入れるとそのターゲットがハッシュによって検索できるのでこういう表現が適切、という
ところでしょう。実は""にはつながりの
重み(エッジの重み)を記すことができますので、Mcm1 → Swi4の重みが0.8であれば、\\
\begin{waku}
\begin{verbatim}
my %pdi = (
  "Mcm1" => { "Swi4" => 0.8 }
);
\end{verbatim}
\end{waku}\\
と表すことができます。さらに図\ref{pdi_sample1}の重みに従ってMcm1 → Swi4とMcm1 → Clb2、Swi4 → Clb2を
表現したい場合は、\\
\begin{waku}
\begin{verbatim}
my %pdi = (
  "Mcm1" => { "Swi4" => 0.8, "Clb2" => 0.2 },
  "Swi4" => { "Clb2" => 1.0 }
);
\end{verbatim}
\end{waku}\\
とします。そして例えば後からLeu3 → Leu1を\%pdiに追加したい場合は、\\
\begin{waku}
\begin{verbatim}
$pdi{ "Leu3" }->{ "Leu1" } = 0.3;
\end{verbatim}
\end{waku}\\
とします。\verb|->|は省略可能です。
\item{問題\stepcounter{question}\thequestion } 図\ref{pdi_sample1}の重みに従ってハッシュ\%pdiにさらに、Leu3 → Bat1とLeu3 → Ilv2
を追加しましょう。
\item{問題\stepcounter{question}\thequestion } 図\ref{pdi_sample1}を表した以下のファイルの内容からネットワーク構造を\%pdiに読み込む
スクリプトを書きましょう。\\
\begin{waku}
\begin{verbatim}
Mcm1   Swi4   0.8
Mcm1   Clb2   0.2
Swi4   Clb2   1.0
Leu3   Leu1   0.3
Leu3   Bat1   0.3
Leu3   Ilv2   0.4
\end{verbatim}
\end{waku}
\end{description}


\subsection{基本的なネットワーク解析}

\begin{description}
\item{解説}
\ref{perl_graph1}節でハッシュ\%pdiにグラフを実装できました。ここではそれを用いた簡単な解析を
行いましょう。転写制御ネットワーク解析でまず気になるのは、各遺伝子がどの遺伝子を制御しているか
ということでしょう。これはkeysを使うと簡単に知ることができます。例えば、Leu3が制御している遺伝子は、\\
\begin{waku}
\begin{verbatim}
print join(",", keys(%{$pdi{"Leu3"}})), "\n";
\end{verbatim}
\end{waku}\\
で得ることができるのです。これは次のように分解して考えることができます。まず、\verb|$pdi{"Leu3"}|は
\verb|{ "Leu1" => 0.3, "Bat1" => 0.3, "Ilv2" => 0.3 }|へのリファレンスです。従ってそのキーを表す
\verb|keys %$pdi{"Leu3"}|
は、制御対象である\verb|("Leu1", "Bat1", "Ilv2")|になるのです。ネットワーク中の全ての制御関係(重みを含む)
を列挙したい場合は、以下のようにすることができます。\\
\begin{waku}
\begin{verbatim}
for my $m1 (keys %pdi){
  for my $m2 (keys %{$pdi{$m1}}){
    print "$m1\t$m2\t$pdi{$m1}->{$m2}\n";
  }
}
\end{verbatim}
\end{waku}
\item{問題\stepcounter{question}\thequestion } 各遺伝子が制御している他の遺伝子の数を表示するスクリプトを書きましょう。
図\ref{pdi_sample1}を入力とした場合、以下のような出力が期待されます。\\
\begin{waku}
\begin{verbatim}
Mcm1   2
Swi4   1
Leu3   3
\end{verbatim}
\end{waku}

\end{description}

\newpage

\section{PerlによるGenBankファイルの解析}\index{GenBank}

GenBankは米国のNCBI(国立バイオテクノロジー情報センター)が管理している膨
大な量の塩基配列・アミノ酸配列情報を搭載した遺伝子データベースです。GenBankフ
ァイル\footnote{ftp://ftp.ncbi.nih.gov/genbank/よりダウンロード可能。}に
は塩基配列はもちろんのこと、どの部分がタンパク質をコードしているかなど、
それらの配列に付随する有益な情報が載せられており、プログラムを使った網羅
的な解析をする上で大変有用です。そこでこの節ではGenBankファイルの処理
の基本を学びます。


\subsection{GenBankファイルの構造}
\begin{description}
\item{解説} GenBankのファイルは基本的に次のような構造になっています．\\
\begin{waku}
\begin{small}
\begin{verbatim}
LOCUS エントリー名
そのエントリーの塩基配列に関する情報
                    :                   
                    :
ORIGIN
そのエントリーの塩基配列
                    :                   
                    :                   
//
LOCUS エントリー名
そのエントリーの塩基配列に関する情報
                    :
                    : 
ORIGIN
そのエントリーの塩基配列
                    :                   
                    :                   
//
LOCUS エントリー名
                    :
                    :
そのエントリーの塩基配列
                    :                   
                    :
//
\end{verbatim}
\end{small}
\end{waku}\\

各塩基配列はエントリーという単位で格納されています．そして各エントリーは
塩基配列の情報を記述するヘッダ部分(LOCUSからORIGINの間)と実際の塩基配列
の情報が書かれている部分(ORIGINから//の間)に分かれています．またエントリー中の記述の意味の
例を次のページに示しました。霊長類，脊椎
動物などのGenBankファイルには複数のエントリーが含まれています．しかし，
大腸菌の全ゲノム配列などのGenBankファイルには1つのエントリーしか含まれ
ていません．通常配列解析を行う場合は，GenBank中の各エントリー中の塩基配
列と塩基配列に関する情報を照らし合わせながら，解析を行います．

\end{description}

\subsection{初歩的な塩基配列処理}
\begin{description}

\item{問題\refstepcounter{question}\label{ht5}\thequestion} では解析のごく初歩的な例として，各エントリーの配列の先頭と末端5塩基を表示する
プログラムを作成しましょう．次のエントリーをそのプログラムの入力とすると，gaatt, ctatgが出力
されるはずです．\\

\begin{waku}
\begin{small}
\begin{verbatim}
LOCUS       HSAPC3B       558 bp    RNA             PRI       10-NOV-1994
DEFINITION  Human mRNA for pre-apolipoprotein CIII. ←この配列はどういうものか、
ACCESSION   X01388                                    その定義が記述されている
NID         g28727
KEYWORDS    apolipoprotein; lipoprotein; signal peptide.
SOURCE      human.
  ORGANISM  Homo sapiens ← 生物名
            Eukaryotae; mitochondrial eukaryotes; Metazoa/Eumycota group;
            Metazoa; Eumetazoa; Bilateria; Coelomata; Deuterostomia; Chordata;
            Vertebrata; Gnathostomata; Osteichthyes; Sarcopterygii; Choanata;
            Tetrapoda; Amniota; Mammalia; Theria; Eutheria; Archonta; 
            Primates; Catarrhini; Hominidae; Homo.
REFERENCE   1  (bases 1 to 558)
  AUTHORS   Levy-Wilson,B., Appleby,V., Protter,A., Auperin,D. and
            Seilhamer,J.J.
  TITLE     Isolation and DNA sequence of full-length cDNA for human
            preapolipoprotein CIII
  JOURNAL   DNA 3 (5), 359-364 (1984)
  MEDLINE   85076166
FEATURES             Location/Qualifiers
     source          1..558
                     /organism="Homo sapiens"
     CDS             72..371  ←コード領域
                     /codon_start=1             ↓コードされているタンパク質名
                     /product="pre-apolipoprotein CIII" 
                     /db_xref="PID:g28728"      ↓コードされているアミノ酸配列
                     /translation="MQPRVLLVVALLALLASARASEAEDASLLSFMQGYMKHATKTA
                     KDALSSVQESQVAQQARGWVTDGFSSLKDYWSTVKDKFSEFWDLDPEVRPTSAVAA"
     sig_peptide     72..131
     mat_peptide     132..368
                     /product="apolipoprotein CIII"
     misc_feature    532..537
                     /note="polyA signal"
\end{verbatim}

\noindent
\verb|BASE COUNT      107 a    175 c    143 g    133 t|

\verb|ORIGIN  ↓ここから下が実際の塩基配列(下線部分がCDS)|

\verb|        1 gaattctttt tttttttttt tttgttgctc agttcatccc tagaggcagc tgctccagga|

\verb|       61 acagaggtgc c|\underline{\tt atgcagccc cgggtactcc ttgttgttgc cctcctggcg ctcctggcct}

\verb|      121 |\underline{\tt ctgcccgagc ttcagaggcc gaggatgcct cccttctcag cttcatgcag ggttacatga}

\verb|      181 |\underline{\tt agcacgccac caagaccgcc aaggatgcac tgagcagcgt gcaggagtcc caggtggccc}

\verb|      241 |\underline{\tt agcaggccag gggctgggtg accgatggct tcagttccct gaaagactac tggagcaccg}

\verb|      301 |\underline{\tt ttaaggacaa gttctctgag ttctgggatt tggaccctga ggtcagacca acttcagccg}

\verb|      361 |\underline{\tt tggctgcctg a}\verb|gacctcaat accccaagtc cacctgccta tccatcctgc gagctccttg|

\verb|      421 ggtcctgcaa tctccagggc tgcccctgta ggttgcttaa aagggacagt attctcagtg|

\verb|      481 ctctcctacc ccacctcatg cctggccccc ctccaggcat gctggcctcc caataaagct|

\verb|      541 ggacaagaag ctgctatg|

\verb|//|
\end{small}
\end{waku}\\\\
まず$\$ $seqという変数に塩基配列を格納していき，格納し終わった段階で$\$ 
$seqの先頭と末尾の5塩基を表示するという方法を考えましょう．\\
塩基配列が格納されている部分はORIGINから//の間です．実はORIGINから//の間
の文字を取り出すという方法を使った方が正確ですが，これについては後ほど触
れることにして，ここでは塩基配列が書かれている行が，\\
\\
空白 数字 空白 塩基配列
\\\\
という順番で並んでいることを利用しましょう．これは正規表現で表すと，\\
\begin{waku}
\begin{verbatim}
/^ *[0-9]+ [a-z]/
\end{verbatim}
\end{waku}\\
になります．次にこの条件に合致する行から塩基配列を取り出して格納しておく必要があります．まず，塩基配列以外の文字（数値，空白など）を,\\
\begin{waku}
\begin{verbatim}
$_ =~ s/[^a-z]//g;
\end{verbatim}
\end{waku}\\
によって取り除き，次に塩基配列格納変数\verb|$seq|に以下のような文を使って塩基配列を追加していきます
\footnote{これは\$seq = \$seq . \$\_と意味は同じですが、多くの処理系では本文中の記述の方が高速な処理になります。}．\\
\begin{waku}
\begin{verbatim}
$seq .= $_;
\end{verbatim}
\end{waku}\\
\verb|そして//という行を見つけたら，$seqの先頭と末尾の5文字をsubstrやlengthを使って表示します．substr関数は，|\\
\begin{waku}
\begin{verbatim}
$substring = substr($string, 0, 3);
\end{verbatim}
\end{waku}\\
のように（文字列, 切り出す場所, 切り出す文字数）という引数を与えて使います． なお，Perlでは先頭の文字は1番目ではなく0番目から始まることに注意して下さい．
また先頭にLOCUSという文字列が現れたら，新しいエントリーの始まりなので，\\
\begin{waku}
\begin{verbatim}
$seq = “”;
\end{verbatim}
\end{waku}\\
として中味を空にします．\\
\begin{waku}
\begin{small}
\begin{verbatim}
#!/usr/bin/env perl

use strict;    # 全ての変数をmyで宣言するように強制する
use warnings;  # プログラム動作に不合理な点があったときに警告を出す

local(*FILE);
my $seq = "";

open(FILE, $ARGV[0]) || die "Cannot open \"$ARGV[0]\": $!";
while(<FILE>){
    if($_ =~ /^LOCUS/){ $seq = ""; }
    elsif($_ =~ /^ *[0-9]+ [a-z]/){ 
            $_ =~ s/[^a-z]//g;
            $seq .= $_;
    }
    elsif($_ =~ /^\/\//){
            #ここは考えましょう
    }
}
close FILE;
\end{verbatim}
\end{small}
\end{waku}\\
このプログラムのファイル名を\verb|head_tail_seq.pl|、処理の対象となるGenBankファイルをtest.seq\footnote{
GenBankのサンプルファイルはhttp://www.bioinfo.sfc.keio.ac.jp/class/genpro/Seqs/test.seqよりダウンロード可能。
このファイルには複数のエントリーが含まれています。
}とすると、
\verb|chmod +x ./head_tail_seq.pl|で実行権を与えた後、\\
\begin{waku}
\begin{verbatim}
./head_tail_seq.pl test.seq
\end{verbatim}
\end{waku}\\
と打ち込みます。
\end{description}

\subsection{ゲノムのGC含有量の解析}
\label{gc_content}

\begin{description}
\item[解説] GC含有量\footnote{GC含量、GC contentとも呼ばれます。}は核酸配列の性質を調べる上で基本的な指標で、以下のように定義されます。

\begin{displaymath}
\mbox{GC含有量}=\frac{\mbox{対象とする核酸配列に含まれるCとGの数}}{\mbox{対象とする核酸配列の長さ}}
\end{displaymath}

例えば、\tt{ACTCAATGAG}という核酸配列のGC含有量は40\%になります。核酸配列のGC含有量には以下のような生物学的意義や応用があります。

\begin{itemize}
\item 核酸の立体構造上の安定性、二次構造のできやすさ
\item ゲノム全体の塩基組成
\item ゲノム上の遺伝子領域の予測
\item ゲノム上の外来性領域の予測
\end{itemize}

\item[問題\refstepcounter{question}\label{ex_gc}\thequestion] 大腸菌のゲノム配列\footnote{
大腸菌のゲノム配列はhttp://www.bioinfo.sfc.keio.ac.jp/class/genpro/Seqs/ecoli.gbkよりダウンロード可能。}
上のGC含有量の
推移を計算しましょう。また計算結果をMicrosoft Excelなどを用い
て、図\ref{gccont1}のようなグラフにしましょう。

まず与えられた核酸配列のGC含有量を計算する関数\verb+calc_gc+を以下のように作成します。\\
\begin{waku}
\begin{verbatim}
sub calc_gc {
  my $seq_frag = $_[0];
  my $gc_count = $seq_frag =~ tr/cg/cg/;
  return 1.0 * $gc_count / length($seq_frag);
}
\end{verbatim}
\end{waku}\\
ここで、\verb+$gc_count = $seq_frag =~ tr/cg/cg/;+は\verb+$seq_frag+中に含まれ
るcやgの数を数え\footnote{厳密にいうと、cをcにgをgに変換してその変換数を
返します。これについては後で詳しく説明します。}、それを\verb+$gc_count+に代入します。
これを配列の長さ\verb|length($seq_frag)|で割ればGC含有量が計算できます。このとき、
1.0を掛けて小数演算であることを明示します。
この関数を\\
\begin{waku}
\begin{verbatim}
print calc_gc("acgta");
\end{verbatim}
\end{waku}\\
のように呼び出すと、0.4が表示されるでしょう。
さて次に塩基配列の読み込みですが、問題\ref{ht5}では塩基配列が書かれている行の
パターンマッチを行ってした。しかしここではより厳密に、次のように"ORIGIN"以下の行から"//"の部分までの塩基配列を読み込み、それを返す関数\verb+get_sequence+を
作成します。\\
\begin{waku}
\begin{verbatim}
sub get_sequence {

  my $fh = $_[0];         # ファイルハンドルを$fhへ
  my $seq = "";
  my $seq_frag;
  
  while(<$fh>){           # 塩基配列の行を一行読み込む
    if($_ =~ /^\/\//){    # //を見つけたらそこで終了
      last;
    }
    else {
      $_ =~ s/[^a-z]//g;  # 塩基配列の行に含まれる数字、空白などを削除する
      $seq .= $_;         # $seqに配列全体を格納
    }
  }
  return $seq;
}
\end{verbatim}
\end{waku}\\
この関数はORIGINを見つけた後、\\
\begin{waku}
\begin{verbatim}
$seq = &get_sequence(*FILE); #ファイルハンドルを渡す
\end{verbatim}
\end{waku}\\
とファイルハンドルに*を付けて引数にして呼び出すことによって、塩基配列が\verb|$seq|に代入されます。
一般にファイルハンドルを関数の引数として渡すときは，\\
\begin{waku}
\begin{verbatim}
関数名（*ファイルハンドル名）;
\end{verbatim}
\end{waku}\\
で関数を呼び出し，受け取る関数では\\
\begin{waku}
\begin{verbatim}
my $ファイルハンドルを受け取る変数名 = $_[0];
\end{verbatim}
\end{waku}\\
で受け取ります．

さて次にGenBankファイルを読み込んで、"ORIGIN"を見つけた後、\verb+get_sequence+を呼び出す
部分を作成します。\\
\begin{waku}
\begin{verbatim}
local *FH;
open(FH, $ARGV[0]) || die "Cannot open \"$ARGV[0]\": $!";
my $seq = "";
while(<FH>){
  if(/^ORIGIN/){
    $seq = get_sequence(*FH); 
  }
}
close FH;
\end{verbatim}
\end{waku}

%%%%%

\begin{figure}
\begin{itembox}[l]{大容量GenBank塩基配列の処理}
関数\verb|get_sequence|は
塩基配列がそれほど長くない場合に有効です．しかし，ヒトゲノムの
GenBankファイルなど塩基配列が数十億の長さになる場合は，マシンによっては
処理が困難になってしまいます．そこでこのような場合は，塩基配列だ
けが書かれているファイルを次の関数を用いて作成します．\\
\begin{waku}
\begin{verbatim}
sub save_sequence {

    my($filename, $fh) = @_;
    my($seq_frag);
    local(*SEQFILE);

    open(SEQFILE, "> $filename");
    # $filenameという名前のファイルを書きこみ用にオープンする

    while(<$fh>){
        if($_ =~ /^\/\//){
            last;
        }
        else {
            $_ =~ s/[^a-z]//g;
            print SEQFILE $_;
        }
    }

    close SEQFILE;

}
\end{verbatim}
\end{waku}\\
この関数を\\
\begin{waku}
\begin{verbatim}
&save_sequence(“seq.tmp”,*FILE);
\end{verbatim}
\end{waku}\\
のように呼び出します．すると塩基配列だけが書かれた"seq.tmp"というファイルが
作成されます。そして塩基配列を読み込むときは、次のようにSEQFILEをopenし，
seek関数とread関数を使って塩基配列の任意の場所を読み込むといいでしょう。\\
\begin{waku}
\begin{verbatim}
open(SEQFILE, "seq.tmp"); # 塩基配列だけが書かれたファイル"seq.tmp"をオープン
seek(SEQFILE, 100, 0);    # 塩基配列の100番目から読み込みを開始する
read(SEQFILE, $seq, 3);   # 3文字読みとって、それを$seqに格納する
print "$seq\n";
close SEQFILE;
\end{verbatim}
\end{waku}
\end{itembox}
\end{figure}

\begin{figure}
\begin{center}
\includegraphics[scale=0.5]{figs/gccont_win.eps}
\end{center}
\caption{ウィンドウを使用したゲノム上のGC含有量推移の計算}
\label{gcskew_win}
\begin{quotation}
\begin{small}
この例ではウィンドウの大きさを5塩基、移動幅を3塩基に設定した。ウィンドウの中の数値はGC含有量を表す。
\end{small}
\end{quotation}
\vspace{1em}
\end{figure}

そして図\ref{gcskew_win}に示すように、
ゲノム配列上にウィンドウを置き、ウィンドウ中のGC含有量を計算し、ウィンド
ウを移動させるというステップを繰り返します。次のプログラムではウィンドウの大き
さを1000塩基、移動幅を500塩基に設定しています。\\
\begin{waku}
\begin{verbatim}
my $win_size = 1000;
my $step = 500;
for(my $pos = 0;$pos + $win_size <= length($seq); $pos += $step){
  my $seq_frag = substr($seq, $pos, $win_size);
  my $gc_content = calc_gc($seq_frag);
  print "$pos\t$gc_content\n";
}
\end{verbatim}
\end{waku}

\begin{figure}
\begin{center}
\includegraphics[scale=0.5]{Figs/gccont1.eps}
\end{center}
\caption{大腸菌とマイコプラズマ菌のゲノム中のGC含有量}
\label{gccont1}
\end{figure}

\item{問題\stepcounter{question}\thequestion }  
GC skewはゲノム配列の片方の鎖のCの偏りを表す指標で以下の式で定義されます。
\begin{displaymath}
\mbox{GC skew}=\frac{\mbox{対象とする核酸配列に含まれるCの数}-\mbox{対象とする核酸配列に含まれるGの数}}{\mbox{対象とする核酸配列に含まれるCとGの数}}
\end{displaymath}
ゲノム中のGC skewの推移を表すプログラムを作成し、実行結果を図にしてみましょう。
大腸菌など生物によっては複製開始点を基点としてGC skewに興味深い大きな変動が見られるでしょう。
\end{description}

\subsection{塩基配列に関する情報の格納とコード領域の解析}
\label{cds_analysis}

\begin{figure}
\begin{center}
\includegraphics[scale=1.00]{Figs/cds_analysis_flow1.eps}
\end{center}
\caption{CDS配列の処理の骨格}
\label{cds_analysis_flow1}
\vspace{5em}
\end{figure}

\begin{description}
\item{解説} 次にCDS\index{CDS}（protein-CoDing Sequence; タンパク質コード配列）がATG
で始まる割合を求めるPerlプログラムを作成しましょう．基本的な処理を図\ref{cds_analysis_flow1}に示しますが、
基本的な処理はファイルを一行ずつ読みながら，LOCUS, CDS, ORIGINのキーワードに注目することです．すなわち、

\begin{enumerate}
\item LOCUSを見つけたら，エントリーが始まるので，様々な準備（初期化）をします．
\item CDSを見つけたら，CDS開始領域の情報を格納します．
\item ORIGINを見つけたら，塩基配列を変数（文字列）またはファイルに格納し，その後でCDS開始領域の情報をもとに開始領域がATGで始まっているか，判断します．
\end{enumerate}

プログラムは次のような形になるでしょう．\\
\begin{waku}
\begin{verbatim}
#!/usr/bin/env perl

use strict;    # 全ての変数をmyで宣言するように強制する
use warnings;  # プログラム動作に不合理な点があったときに警告を出す

# ここに後ほど説明するget_sequence, save_sequenceなどの関数を置く

my(@cds_start_set, $cds_start); # @cds_start_setに開始位置を記録していく
my($cds_count, $atg_count);     # CDSの数，atgで始まるCDSの数をカウント
open(FILE, $ARGV[0]) || die "Cannot open \"$ARGV[0]\": $!\n";

$cds_count = 0;
$atg_count = 0;

while(<FILE>){ # [[1]]
   chomp; # 行末端の改行記号を消す
   if($_ =~ /^LOCUS/){
      # [[2]]
   }
   elsif($_ =~ /^     CDS             ([0-9]+)\.\.([0-9]+)/){
      # [[3]]
   }
   elsif($_ =~ /^ORIGIN/){
      # [[4,5]]
   }
}

close FILE;

# 上記部分が完成したら、
# print "$atg_count / $cds_count = ", 1.0*$atg_count / $cds_count, "\n";

\end{verbatim}
\end{waku}\\
\verb|[[1]]はもうこれで完成していますから，[[2〜5]]を完成させましょう．まず上記プログラムをそのまま打ち込み（ファイル名は例えばcds_start.plにする），|\\
\begin{waku}
\begin{verbatim}
./cds_start.pl test.seq
\end{verbatim}
\end{waku}\\
と打ちこんで実行してみましょう(ここでtest.seqはGenBankファイル名)．何も出力されないはずです．エラーが出るようならプログラムを修正しましょう．
\item{問題\refstepcounter{question}\label{cds_analysis_e_f}\thequestion } \verb|CDSの開始領域の位置の情報を@cds_start_setに格納しましょう（[[3]]の部分）．|
まず，grep\index{grep}コマンドを利用し，\verb|” CDS” の文字列を含んでいる行を検索しましょう．(ここでは%はShellのプロンプトを意味します)|\\
\begin{waku}
\begin{verbatim}
% grep " CDS" test.seq | less
\end{verbatim}
\end{waku}\\
次のように表示されるはずです．\\
\begin{waku}
\begin{verbatim}
     CDS             join(3066..3157,3281..3503,4393..4521)
     CDS             466..>496
     CDS             1..849
     CDS             135..521
     CDS             9..695
     CDS             200..1444
     CDS             complement(1..297)
     CDS             64..444
     CDS             complement(116..403)
     CDS             1..90
     CDS             <1..>185
      :
\end{verbatim}
\end{waku}\\
\verb|今回は，"<", ">", "join"，"complement"|といった文字列を含むCDSは除外します\footnote{"\(<\)"は位置がより前方にあることを
表し、"\(>\)"は後方を表します。またjoinはCDSがexonに分断されていることを表します。complementについては後述します。}
．つまり，格納すべきCDSの開始位置の情報は，上から順に，1，135，9，200，64，1，になります．\\
さて\\
\begin{waku}
\begin{verbatim}
     CDS             1..849
\end{verbatim}
\end{waku}\\
\verb|のようなCDSの記述がある行を見つけたら，コード領域開始位置の1を取り出す処理が必要になります．問題はCDS  1..849の1の部分をどうやって取り出すかですが，例えば1の部分をとりあえず$cds_startという変数に格納したい場合は，|\\
\begin{waku}
\begin{verbatim}
   elsif($_ =~ /^     CDS             ([0-9]+)\.\.([0-9]+)/){
       $cds_start = $1;
                    :
                    :
   }
\end{verbatim}
\end{waku}\\
のようにするといいでしょう．GenBankファイルの形式ではCDSという文字列の前には5文字の空白、後には13文字の空白が入りますので，
上記プログラムでもそれに従って正規表現に空白を入れます。
図\ref{regexp_CDS1}に示すように，\$1は一番目の括弧内にマッチした正規表現，\$2は二番目の括弧内にマッチした正
規表現という意味になります．したがって，
\$1にはコード領域の開始の位置の情報，\$2にはコード領域の終わりの位置の情報
（1..849なら849）が入ります．

\begin{figure}
\begin{center}
\includegraphics[scale=0.6]{Figs/regexp_CDS1.eps}
\end{center}
\vspace{-2em}
\caption{正規表現によるCDS情報の処理}
\label{regexp_CDS1}
\vspace{3em}
\end{figure}

\verb|そして，CDSの開始領域をどのように記録していくかを考えなければなりません．CDSは１つのエントリーに複数含まれている場合があるので，格納するのは配列変数にするのがいいでしょう．例えば格納する配列変数が@cds_start_setという名前だとすれば，まず1を@cds_start_setに格納します．次に，|\\
\begin{waku}
\begin{verbatim}
     CDS             135..521
\end{verbatim}
\end{waku}\\
\verb|という行を見つけたら，135をまた@cds_start_setに格納します．この時点で$cds_start_set[0]は1，$cds_start_set[1]は135になるはずです．|\\
さて，実際の格納の手順ですが，push関数が有用でしょう．push関数は配列の末尾に新しい要素を加える関数です．例えば，\\
\begin{waku}
\begin{verbatim}
@cds_start_set = (100, 200, 300);
\end{verbatim}
\end{waku}\\
のときに，\\
\begin{waku}
\begin{verbatim}
push(@cds_start_set, 1000);
\end{verbatim}
\end{waku}\\
\verb|とすると，@cds_start_setの要素は，(100, 200, 300, 1000)になります．ちゃんとCDS開始位置の情報が入っているかprint文などを使って確認しながらプログラムを作成しましょう．|
\item{問題\stepcounter{question}\thequestion } ORIGINを見つけたら，まず塩基配列を文字列またはファイルとして格納しましょう（[[4]]の部分）．\\
塩基配列を文字列として格納するには，\ref{gc_content}節で作成した関数\verb|get_sequence|を
use strictの直後などに配置すればいいでしょう。そして[[4]]の適切な箇所で，\\
\begin{waku}
\begin{verbatim}
      $seq = &get_sequence(*FILE); #ファイルハンドルを渡す
\end{verbatim}
\end{waku}\\
のように呼び出すと，\verb|$seq|には塩基配列が格納されます．

\item{問題\stepcounter{question}\thequestion } \verb|塩基配列が入った文字列から@cds_start_setに基づいてCDS開始領域の塩基配列をみていきましょう（[[5]]の部分）．|\\
塩基配列を文字列変数としている場合は，例えばCDSの最初の3文字を表示したい場合は以下のようにするといいでしょう．\\
\begin{waku}
\begin{verbatim}
foreach $cds_start (@cds_start_set){
	  print substr($seq, $cds_start - 1, 3), "\n";
}
\end{verbatim}
\end{waku}\\
あとは，\verb|$cds_countや$atg_count|を使ってCDSの数やatgの数を数えていくだけです．

\item{問題\refstepcounter{question}\label{cds_analysis_e_l2}\thequestion } CDS開始領域情報の初期化を行いましょう（[[2]]の部分）．\\
\verb|CDS開始領域情報は@cds_start_setなので，|\\
\begin{waku}
\begin{verbatim}
@cds_start_set = ();
\end{verbatim}
\end{waku}\\
でいいでしょう．

\item{問題\stepcounter{question}\thequestion } 問題\ref{cds_analysis_e_f}〜\ref{cds_analysis_e_l2}を完成させ，コード領域（CDS）がATGで始まる割合を求めるPerlプログラムを作成しましょう
\footnote{真核生物の場合，CDSの開始はほとんどATGです．ATGで始まらないエントリーは，CDSの一部の領域しか登録されていないか，CDSが偽遺伝子，データベースのエラーというものがほとんどです．原核生物ではCDSがATGから始まらない例が数多く知られています．}．
\end{description}

\subsection{相補鎖の処理}\index{そうほさ@相補鎖}
\begin{description}
\item{解説} DNAは二重らせん構造をしています．そしてAの反対側にはTが，Cの反対側にはGが結合しています．反対側に結合しているDNA鎖を相補鎖と呼びます．\\
\begin{waku}
\begin{verbatim}
……ctagctagctagtgcatgtga……
……gatcgatcgatcacgtacact……  ←相補鎖
\end{verbatim}
\end{waku}\\
遺伝子は相補鎖の方にコードされていることもあります．例えば図\ref{CDS_complement1}の例では，灰色の部分に遺伝子がコードされています．
\begin{figure}
\begin{center}
\vspace{1em}
\includegraphics[scale=0.6]{Figs/CDS_complement1.eps}
\end{center}
\vspace{-1em}
\caption{相補鎖に存在するコード領域(CDS)}
\label{CDS_complement1}
\vspace{2em}
\end{figure}
この場合，GenBankの記述は以下のようになります．\\
\begin{waku}
\begin{verbatim}
     CDS             complement(100..402)
\end{verbatim}
\end{waku}\\
相補鎖を扱うときには，まず塩基配列を逆向きにして，次にA→T，T→A，C→G，
G→Cの変換を行わなければなりません．この相補鎖の扱いを課題を通して学びま
しょう．ここからはエントリー(LOCUS)が1つしかない、大腸菌の全ゲノム配列を扱います。

\item{問題\refstepcounter{question}\label{complem1}\thequestion } 大腸菌のゲノムの
各コード領域（CDS）の塩基配列を切り出し，配列変数に格納してゆき，最後に
通し番号とともにCDS配列を出力しましょう．\ref{cds_analysis}節で作った
プログラムのかなりの部分を流用することが可能でしょう。ただ前述の通り、このGenBankファイルには
エントリー(LOCUS)は1つしかありませんので、全ゲノム配列を読み終わった後の処理は1回で済ます
ことができます。従って、[[5]]の部分をwhile文の外に出してだいたい次のようにします。
\\

\begin{waku}
\begin{verbatim}
sub get_sequence{

   # 関数get_sequenceの中味を書く

}

my @cds_start_set;   # @cds_start_setにCDS開始位置を記録していく
my @cds_end_set;     # @cds_end_setにCDS終了位置を記録していく
my $seq; # 塩基配列

open(FILE, $ARGV[0]) || die "Cannot open \"$ARGV[0]\": $!\n";

while(<FILE>){
  chomp; # 行末端の改行記号を消す
  if($_ =~ /^     CDS             ([0-9]+)\.\.([0-9]+)/){
    # CDS開始および終了位置の記録。ここは考えましょう。
  }
  elsif($_ =~ /^ORIGIN/){
    $seq = &get_sequence(*FILE);
    last; # 塩基配列を全部読み終わったら、ファイルの読み取りを抜ける
  }
}

close FILE;
\end{verbatim}
\end{waku}\\
そして、続く[[5]]の部分では読み込んだCDSの数(\verb|$#cds_start_set|がこれに相当します)だけ、CDSの配列を出力します。\\
\begin{waku}
\begin{verbatim}
for my $ncds (0..$#cds_start_set){　# CDSの通し番号とCDS配列を出力していくループ
  my $cds_seq = substr($seq,
                       $cds_start_set[ $ncds ] - 1,
                       $cds_end_set[ $ncds ] - $cds_start_set[ $ncds ] + 1);
  print "$ncds\t$cds_seq\n";  
}
\end{verbatim}
\end{waku}\\
\item{問題\stepcounter{question}\thequestion } 相補的な塩基配列を求める機能を先ほどのプログラムに組み込みましょう．
先ほど説明した通り，'complement'というキーワードは，タンパク質をコ
ードするDNA塩基配列情報が相補鎖の方にあることを意味します．そこで，
@complementという配列変数を用意し，'complement'があったら1（真）を，なか
ったら0（偽）を記憶しておきます．こうしておくと，後の処理で@complementを
参照すれば，相補鎖に変換すべきCDSとそうでないCDSを識別できます．\\
\begin{waku}
\begin{verbatim}
while(<FILE>){
  chomp; # 行末端の改行記号を消す
  if($_ =~ /^     CDS             ([0-9]+)\.\.([0-9]+)/){
    # ここは考えましょう
    # @complementに0を追加
  }
  elsif($_ =~ /^     CDS             complement\(([0-9]+)\.\.([0-9]+)\)/){
    # ここは考えましょう
    # @complementに1を追加
  }
  elsif($_ =~ /^ORIGIN/){
    $seq = &get_sequence(*FILE);
    last;
  }
}
\end{verbatim}
\end{waku}\\
さらに，各CDSの塩基配列を引数で渡すと，その相補鎖を返してくれる関数を作ると便利です．\\
\begin{waku}
\begin{verbatim}
sub complemental{ 
    my $seq = $_[0]; 
    my $complement; 
    #ここは考えましょう; # 配列を逆順にする処理
    #ここは考えましょう; # A→T，G→Cといったように相補塩基に変換する処理
    return $complement; 
}
\end{verbatim}
\end{waku}\\
\verb|reverseは，文字列を逆順にしたものを返す関数です．例えば，$a = reverse("top"); としてやると，$aに"pot"が入ります．また，相補塩基に変換するには，tr/// を使うと便利です．tr/// は一文字置換の関数ですが，特定の文字がきたら特定の文字に，という複数の条件を一文で書き表すことができます．つまり， |\\
\begin{waku}
\begin{verbatim}
$seq =~ tr/acgt/tgca/; 
\end{verbatim}
\end{waku}\\
と書くだけで，aをtに，cをgに，gをcに，tをaに置換してくれます．
あとは問題\ref{complem1}を改良し，\verb|@cds_seqの中身を出力します．このとき@complementの値が0のときはそのままで，1のときはcomplemental関数にかけてから，出力します．|
\end{description}

\subsection{塩基の計数}
\begin{description} 
\item{解説} ここでは，大腸菌のゲノムにおける塩基組成\index{えんきそせい@塩基組成}を調べましょう．
\item{問題\refstepcounter{question}\label{ncount1}\thequestion } \label{codon1} 各CDSにおける各塩基の度数を求めましょう．
\item{問題\refstepcounter{question}\label{ncount2}\thequestion } 全CDSにおける各塩基の度数（全CDSの集計値）を求めましょう．
\item{問題\refstepcounter{question}\label{ncount3}\thequestion } 全CDSにおける各塩基の相対度数（総塩基数に対する各塩基の度数の比率）を求めましょう．
\\\\
問題\ref{ncount1}では，a,c,g,tのそれぞれについて各CDSの数をカウントします．\\
文字列操作関数であるtr///は，s///とは違い，置き換えた文字数を返します．例えば，\\
\begin{waku}
\begin{verbatim}
$i = $str =~ tr/a-z/A-Z/;
\end{verbatim}
\end{waku}\\
\verb|とすると，$str中の文字列を検索し，a-z中に含まれる文字を見つけると，A-Z中の対応する位置の文字に置換し（つまりアルファベットの小文字を大文字に置換し），置換した文字数を$iに代入します．これを利用して|\\
\begin{waku}
\begin{verbatim}
$a = $seq =~ tr/a/a/; 
\end{verbatim}
\end{waku}\\
と同じ文字を代入することにより，その文字の数をカウントすることができます． \\
生物種によっては，CDS内にa,c,g,t以外の文字が含まれるケースがあります．このようなケースでは，CDSの総文字数とa,c,g,tの総数とは一致しません．これは，\\
\begin{waku}
\begin{verbatim}
$others = length($seq) - ($a + $c + $g + $t); 
\end{verbatim}
\end{waku}\\
\verb|とすることにより確認できます．length($seq)は，$seqの中の文字数を返します．|\\
\\
問題\ref{ncount2}では，a,c,g,tのそれぞれについて，全CDSの数を集計します．\\
例えば，aの数を集計するには，for文の中で以下の処理を行います．\\
\begin{waku}
\begin{verbatim}
$a += $seq =~ tr/a/a/; 
\end{verbatim}
\end{waku}\\
\\
問題\ref{ncount3}では，a,c,g,tのそれぞれについて，度数を比率に変換します．\\
小数の出力は，printの場合，小数点以下8桁くらいまで表示されて見にくいので，printfを使って小数第3位までの出力に整形しましょう．\\
\begin{waku}
\begin{verbatim}
printf("%.3f %.3f %.3f %.3f", $pr_a, $pr_c, $pr_g, $pr_t); 
\end{verbatim}
\end{waku}\\
%とfの間に.3を入れると，小数点以下第三位まで表示という意味になります．同様に，.4を入れると小数点以下第四位までとなります．なお，一つ下の桁は四捨五入されます．
\end{description}

\subsection{コドンの計数}\index{こどん@コドン}
\begin{description}

\item{解説} コード領域（CDS）の塩基配列は遺伝子発現時にコドンと呼ばれる
３塩基の単位でアミノ酸配列に翻訳されます．ここでは，大腸菌ゲノムにおけるコドン組成を調べましょう．

\item{問題\refstepcounter{question}\label{ecodon1}\thequestion } 各CDSにおける各コドンの度数を求めましょう．
\item{問題\refstepcounter{question}\label{ecodon2}\thequestion } 全CDSにおける各コドンの度数（全CDSの集計値）を求めましょう．
\item{問題\refstepcounter{question}\label{ecodon3}\thequestion } 全CDSにおける各コドンの相対度数（総コドン数に対する各コドンの度数の比率）を求めましょう．
\\\\
問題\ref{ecodon1}では，各CDSで使用されるコドンをそれぞれ計数します．\\
コドンは3連続塩基ですので1文字置換をする\verb|tr///|を使って数えることは
できません．複数置換の\verb|s///|では置換された数を返さないのでこれを使うことも
できません．仕方がないので，ここではfor文を使って3文字づつ読んでいきまし
ょう．ここでは塩基配列の最初から3文字の単位で読むのですから，例えば
"atgcggctg"という塩基配列なら1つ目のコドンが"atg"，2つ目のコドンが"cgg"，
3つ目のコドンが"ctg"というようになります．つまり，これは [1文字目] から 
[配列の長さ-2文字目] までfor文で繰り返すことになります．ここで注意しなけ
ればいけないことは，Perlでは先頭の番号は1ではなく0から始まる点です．つま
り，for文で繰り返す場合は[0文字目]から[配列の長さ-3文字目]までとなります．
\\

\begin{waku}
\begin{verbatim}
for($p = 0; $p <= length($seq) - 3; $p += 3){
   # 処理
}
\end{verbatim}
\end{waku}\\
コドンを切り出すには，substr関数を使います． \\
\begin{waku}
\begin{verbatim}
   $codon = substr($seq, $p, 3);
\end{verbatim}
\end{waku}\\
各コドンの計数にはハッシュをうまく利用しましょう．ハッシュの引数は文字列（この場合，１コドン）でいいので， \\
\begin{waku}
\begin{verbatim}
   $count{$codon} ++;
\end{verbatim}
\end{waku}\\
\verb|としてやることで，$codonの中身が何であるかを気にせずにカウントすることができます．|\\
\\
問題\ref{ecodon2}では，全CDS中の各コドンの数を集計します．\\
全CDSの数を集計するには，全CDSに対する処理を行うfor文の中で問題\ref{ecodon1}の処理を行えばいいでしょう．\\
\begin{waku}
\verb|for my $ncds (0..$#cds_start_set){|\\
\verb|   #| 問題\ref{ecodon1}の処理\\
\verb|}|
\end{waku}\\
\\
問題\ref{ecodon3}では，各コドンについて，度数を比率に変換します．\\
\verb|$totalに全コドンの総度数を記憶しておけば，以下の処理で求めることができます．|\\
\begin{waku}
\begin{verbatim}
foreach (keys %count){
    $proportion{$_} = $count{$_} / $total;
}
\end{verbatim}
\end{waku}
\end{description}

\subsection{アミノ酸配列の処理}\index{あみのさん@アミノ酸}
\begin{description}
\item{解説} 
CDS領域の塩基配列が実際にどのようなアミノ酸配列になるかという情報は、CDSの
注釈の中でtranslationというところに書かれています．ここでは，
大腸菌のゲノムにおけるアミノ酸組成を調べましょう．\\
\begin{waku}
\begin{small}
\begin{verbatim}
     CDS             complement(20815..21078)
                     /gene="rpsT"
                     /codon_start=1
                     /transl_table=11
                     /product="30S ribosomal subunit protein S20"
                     /translation="MANIKSAKKRAIQSEKARKHNASRRSMMRTFIKKVYAAIEAGDK
                     AAAQKAFNEMQPIVDRQAAKGLIHKNKAARHKANLTAQINKLA"
\end{verbatim}
\end{small}
\end{waku}
\item{問題\refstepcounter{question}\label{trans_amino1}\thequestion } 各CDSのアミノ酸配列を切り出し，その長さを出力しましょう．
\\\\
まず/translation=""の中味を切り出すことを考えましょう．プログラムの骨組みは次のようになります．\\
\begin{waku}
\begin{verbatim}
while(<FILE>){
  chomp; # 行末端の改行記号を消す
  if($_ =~ /^     CDS             ([0-9]+)\.\.([0-9]+)/){
     # @cds_start, @cds_endおよび@complementに対する処理
  }
  elsif($_ =~ /^     CDS             complement\(([0-9]+)\.\.([0-9]+)\)/){
     # @cds_start, @cds_endおよび@complementに対する処理
  }
  elsif($_ =~/^                     \/translation=\"([^\"]+)/){
    $translation[ $#cds_start_set ] = $1;
    # 終わりまでtranslationのアミノ酸配列を読む
  }
  elsif($_ =~ /^ORIGIN/){
    $seq = &get_sequence(*FILE);
    last;
  }
}
\end{verbatim}
\end{waku}\\
まず/translation="の行を検索し、アミノ酸部分を\verb|$|1に抽出するために以下の正規表現を用います。\\
\begin{waku}
\begin{verbatim}
  elsif($_ =~/^                     \/translation=\"([^\"]+)/){
\end{verbatim}
\end{waku}\\
次に、アミノ酸配列の1行目が\verb|$|1に格納されていますので、これを配列@translationに格納します。
@translationの何番目に入れるかは、対応するCDSを\verb|@cds_start|の何番目に入れたかということと一致
させなければならないので、\verb|$#cds_start_set|番目と指定します。\\
\begin{waku}
\begin{verbatim}
    $translation[ $#cds_start_set ] = $1;
\end{verbatim}
\end{waku}\\
そして/translationの終わりまでアミノ酸配列を読み、@translationに追加していきます。このとき、
行末のダブルクオテーション(")が終わりの判定になります。\\
\begin{waku}
\begin{verbatim}
    while($_ !~ /\"$/){   # translationの終わりまで読む
      $_ = <FILE>;        # ファイルを一行読み込んで$_に入れる
      my $tmp = $_;       # 空白などを含むアミノ酸配列を一時的に$tmpへ代入
      $tmp =~ s/\"|\s//g; # ダブルクオテーションや空白などを消去する
      $translation[ $#cds_start_set ] .= $tmp; # アミノ酸配列を格納
    }
\end{verbatim}
\end{waku}
\item{問題\stepcounter{question}\thequestion } CDS毎に各アミノ酸の度数を求めましょう．\\
\verb|まず，@translationの各要素に文字列として格納されているアミノ酸配列を，1文字づつに分割し，配列変数に代入します．文字列を分割するには，split関数を使います．|\\
\\
\begin{waku}
\begin{verbatim}
split(/正規表現/, $variable);
\end{verbatim}
\end{waku}\\
split関数は，指定した正規表現にマッチした文字列をセパレータとして，
分割した文字列のリストを返します．以下のように，セパレータをヌル文字列
（空文字列）にすれば，1文字ずつに分割されます．例えば以下の例で\verb|$translation[$i]|が”
SLQ”の場合，\verb|@amino_seq|は(“S”, “L”, “Q”)になります．\\
\begin{waku}
\begin{verbatim}
@amino_seq = split(//,$translation[$i]);
\end{verbatim}
\end{waku}\\
ここで，\verb|$translation[$i]|は，i番目のCDSのアミノ酸配列を意味します．\\
次に，foreach文において各アミノ酸の使用回数をカウントします．\\
\begin{waku}
\begin{verbatim}
foreach $amino (@amino_seq){
   $count{$amino} ++;
}
\end{verbatim}
\end{waku}\\
ここではハッシュをうまく利用しています．ハッシュの引数は文字列（この場合，１アミノ酸）でいいので，\\
\begin{waku}
\begin{verbatim}
   $count{$amino} ++;
\end{verbatim}
\end{waku}\\
とすることで，アミノ酸\verb|$|aminoの数をカウントすることができます。
\end{description}

\subsection{機能注釈情報の利用}\index{きのうちゅうしゃくじょうほう@機能注釈情報}\index{あのてーしょん@アノテーション}

\begin{figure}
\begin{center}
\vspace{1em}
\includegraphics[scale=0.6]{Figs/in_CDS1.eps}
\end{center}
\caption{変数\$in\_CDSによるCDSの注釈領域の監視}
\label{in_CDS1}
\vspace{1em}
\end{figure}

\begin{description}
\item{解説} CDSの/geneには遺伝子名，/productには遺伝子産物（コードされているタンパク質）に関する情報が書かれています．
例えば下の例では，gene名はrpmF，product名は50S ribosomal protein L32です．\\
\begin{waku}
\begin{verbatim}
     CDS             1146590..1146763 
                     /gene="rpmF" 
                    (中略) 
                     /product="50S ribosomal protein L32" 
\end{verbatim}
\end{waku}\\
これを利用することによって例えば特定のタンパク質をコードする配列のみを抽出することなどが可能です．\\
\item{問題\refstepcounter{question}\label{cds_gene_prod1}\thequestion } 大腸菌のゲノムにおける各コード領域（CDS）のgene名とproduct名を表示しましょう．\\
/gene=""および/product=""の中味を切り出します．問題\ref{trans_amino1}が参考になるでしょう．注意すべき点は、/geneや/productはCDSだけでなく、
tRNAなど他の遺伝子にも付随する注釈であるということです。従ってCDSに付随する/geneや/productだけを読み取るように注意しなければ
なりません。
そこで図
\ref{in_CDS1}に示すように、\verb|$in_CDS|という変数を定義し、CDSに付随す
る注釈の行を読み取っているときは1、そうでないときは0にしておきます。0 → 1の切換えのタイミングは、CDSという文字列がファイルの6列目
から出現したとき、1 → 0に切換えるときは、CDSの注釈行が終わったときです。これはファイルの6列目にCDSという文字列以外の文字列が
出現したときに相当します。プログラムの骨組みを次に示しましょう．\\
\begin{waku}
\begin{verbatim}
while(<FILE>){ 
  chomp; # 行末端の改行記号を消す
  if($_ =~ /^     CDS             ([0-9]+)\.\.([0-9]+)/){
    # @cds_start, @cds_endおよび@complementに対する処理
    $in_CDS = 1;   # CDSの注釈行の開始
  }
  elsif($_ =~ /^     CDS             complement\(([0-9]+)\.\.([0-9]+)\)/){
    # @cds_start, @cds_endおよび@complementに対する処理
    $in_CDS = 1;   # CDSの注釈行の開始
  }
  elsif($_ =~ /^     \S/){
    $in_CDS = 0;   # CDSの注釈行の終了
  }
  elsif($_ =~/^                     \/gene=\"([^\"]+)\"/ && $in_CDS == 1){
    $gene[ $#cds_start_set ] = $1;
  }
  elsif($_ =~/^                     \/product=\"([^\"]+)/ && $in_CDS == 1){
     # 処理を書きましょう
  }
  elsif($_ =~/^                     \/translation=\"([^\"]+)/){
     # 処理を書きましょう
  }
  elsif($_ =~ /^ORIGIN/){
    $seq = &get_sequence(*FILE);
    last;
  }
}
\end{verbatim}
\end{waku}\\
\item{問題\stepcounter{question}\thequestion } リボソームタンパクをコードする遺伝子のみ表示されるように問題\ref{cds_gene_prod1}のプログラムを改良しましょう．\\
\\
product名がリボソームタンパクを意味するものを正規表現で検索します．\\
まず，大腸菌のGenBankファイルにおいて，リボソームタンパクがどのように記載されているのかを調べましょう．
grepコマンドを利用し，ribosomalの文字列を含んでいる行を検索します．ワイルドカードを用いれば，複数のGenBankファイル\footnote{全ゲノム配列を格納したGenBankファイルの拡張子は通常.gbkである。}を指定できます．\\
\begin{waku}
\begin{verbatim}
% grep ribosomal *.gbk | less
\end{verbatim}
\end{waku}\\
/product="の行を見てください．\\
"ribosomal protein"，"ribosomal subunit protein"，"RIBOSOMAL PROTEIN"\\
など生物種によってリボソームタンパクの記述の仕方が異なります．これらにマッチするようにするためには例えば，以下のような正規表現を使うといいでしょう．\\
\begin{waku}
\begin{verbatim}
/ribosomal.*protein/i
\end{verbatim}
\end{waku}\\
\verb|.*は，どのような文字列にもマッチします．オプションiを付けると，パターンマッチのときにアルファベットの大文字と小文字を区別しません．|

\item{問題\stepcounter{question}\thequestion } リボソームタンパク遺伝子群における各アミノ酸の度数（集計値）を求めましょう．\\
\verb|@rpという配列変数を用意し，/product=""の中身がリボソームタンパクであれば1（真）を，そうでなければ0（偽）を記憶しておけば，リボソームタンパクをコードするCDSとそうでないCDSを識別できるので，後ほど@rpを参照することにより前者だけを対象として処理を行うことができます．|
\end{description}

\subsection{応用課題}

\begin{figure}
\begin{center}
\vspace{1em}
\includegraphics[scale=0.7]{Figs/exon_intron1.eps}
\end{center}
\caption{エクソン/イントロン構造}
\label{exon_intron1}
\vspace{1em}
\end{figure}

\begin{description}
\item{解説} ＤＮＡの転写される部分で捨てられる（スプライスアウト）部分をイントロン(intron)といい，残る部分をエクソン(exon)といいます(図\ref{exon_intron1})．GenBankではイントロンの場所の記述は\\
\begin{waku}
\begin{verbatim}
     exon            3066..3157
                     /gene="gamma-globin"
     intron          3158..3280
     exon            3281..3503
                     /gene="gamma-globin"
     intron          3504..4392
     exon            4393..4521
                     /gene="gamma-globin"
\end{verbatim}
\end{waku}\\
となっています．\\
\item{問題\stepcounter{question}\thequestion } エクソン/イントロンの境界領域の配列を出力するプログラムを書きましょう．イントロン開始部位にはどのような配列が多く見られますか？霊長類のGenBankファイルなどを調べてみましょう．
\item{問題\stepcounter{question}\thequestion } イントロン/エクソンの境界領域の配列を出力するプログラムを書きましょう．イントロン終了部位にはどのような配列が多く見られますか？霊長類のGenBankファイルなどを調べてみましょう．
\end{description}

\chapter{Appendix}
\section{解答}
\subsection*{第1章 Perlプログラミングを始めるまえに}

\subsection*{第2章 Perl入門}
\begin{description}
\item{問題\stepcounter{question}\thequestion }  printは文字列だけでなく，式の結果も出力することができます．なので解答としては以下で十分です．\\
\begin{waku}
\begin{verbatim}
 print "123x456=";
 print 123*456;
 print "\n";
\end{verbatim}
\end{waku}\\
カンマ(,)を利用してまとめても良いでしょう．\\
\begin{waku}
\begin{verbatim}
 print "123x456=", 123*456, "\n";
\end{verbatim}
\end{waku}\\
もちろん変数を使ってもOKです．\\
\begin{waku}
\begin{verbatim}
 $hoge = 123*456;
 print "123x456=$hoge\n";
\end{verbatim}
\end{waku}

\item{問題\stepcounter{question}\thequestion } \verb|イコール(=)がPerlでは代入を意味することに気をつけましょう．後で出てきますが，等しいことを意味する記号はイコールx2(==)です|\\
\begin{waku}
\begin{verbatim}
 $x = 86400;
 $y = 365;
 $z = $x * $y;
 
 print "$z\n";
\end{verbatim}
\end{waku}

\item{問題\stepcounter{question}\thequestion } \verb|三行目で$xに$x+$yの結果を"改めて"代入しています．|\\
\begin{waku}
\begin{verbatim}
 $x = 10;
 $y = 5;
 $x = $x + $y;
 
 print "$x\n"
\end{verbatim}
\end{waku}\\
この場合以下でも良いでしょう．\\
\begin{waku}
\begin{verbatim}
 $x  = 10;
 $y  = 5;
 $x += $y;
 print "$x\n"
\end{verbatim}
\end{waku}

\item{問題\stepcounter{question}\thequestion } \verb|3番目の要素は$array[2]でとってくることに注意．最後の要素にはカンマはつけません.|\\
\begin{waku}
\begin{verbatim}
 @array = (
 	"Sunday",
 	"Monday",	
 	"Tuesday",	
 	"Wednesday",
 	"Thursday",
 	"Friday",
 	"Saturday"
 	);
 
 print "$array[2]\n";
\end{verbatim}
\end{waku}

\item{問題\stepcounter{question}\thequestion } \verb|区切り文字が"-"であることに注意すればOKです．|\\
\verb|ちなみにsplit("pattern", sequence)のところでパターン指定の部分(つまり第一引数)の囲いは""(ダブルクォーテーション)と//(スラッシュ)の二通りがあります．前者がパターンマッチで後者が正規表現です．|\\
\begin{waku}
\begin{verbatim}
 $seq = "Sun-Mon-Tue-Wed-Thr-Fri-Sat";
 @week_array = split "-", $seq;
 
 print "$week_array[2]\n"
\end{verbatim}
\end{waku}

\item{問題\stepcounter{question}\thequestion } \verb|$i = $i+2のところがミソです．|\\
\verb|($i <= 11)のところは($i < 12)等でもかまいません．|\\
\begin{waku}
\begin{verbatim}
 my $i = 1;
 while($i <= 11){
    print "There are $i sheep\n"
    $i = $i+2;
 }
\end{verbatim}
\end{waku}\\
文法が気になる人はこうやっても良いでしょう．\\
\begin{waku}
\begin{verbatim}
 print "There is a sheep\n"
 my $i = 3;
 while($i <= 11){
    print "There are $i sheep\n"
    $i = $i+2;
 }
\end{verbatim}
\end{waku}

\item{問題\stepcounter{question}\thequestion } \verb|"超えるまで出力"がポイントです．|\\
\begin{waku}
\begin{verbatim}
 my $i = 1/2;
 while($i < 100000){
     $i = $i * 2;
     print "$i\n";
 }
\end{verbatim}
\end{waku}\\
あるいは\\
\begin{waku}
\begin{verbatim}
 my $i = 1;
 while($i < 100000){
     print "$i\n";
     $i = $i * 2;
 }
 print "$i\n";
\end{verbatim}
\end{waku}

\item{問題\stepcounter{question}\thequestion } \verb|変数を二つ使います．|\\
\begin{waku}
\begin{verbatim}
 my $i   = 1;
 my $ans = 1;
 while($i <= 15){
     $ans = $ans * $i;
     $i = $i + 2;
 }
 print "$ans\n";
\end{verbatim}
\end{waku}

\item{問題\stepcounter{question}\thequestion } \verb|色々な方法がありますが--を使うとシンプルな解答になります．|\\
\begin{waku}
\begin{verbatim}
 for(my $i = 100; $i > 0; $i --){
     print "$i\n";
 }
\end{verbatim}
\end{waku}\\
もちろんこれでも問題ありません．\\
\begin{waku}
\begin{verbatim}
 for(my $i = 0; $i < 100; $i ++){
     print 100-$i, "\n";
 }
\end{verbatim}
\end{waku}\\
foreachを使ってもできます．\\
\begin{waku}
\begin{verbatim}
 print "$_\n" for reverse 1..100;
\end{verbatim}
\end{waku}

\item{問題\stepcounter{question}\thequestion } \verb|[ ]の中に式が書けることを知っておくと後々役立ちます．|\\
\begin{waku}
\begin{verbatim}
 my @array = (
 	"Sunday",
 	"Monday",	
 	"Tuesday",	
 	"Wednesday",
  	"Thursday",
 	"Friday",
 	"Saturday"
 	);
 
 foreach(1..30){
     print "$_\t$array[$_%7]\n";
 }
\end{verbatim}
\end{waku}\\
あるいは\\
\begin{waku}
\begin{verbatim}
 my @array = (
 	"Sunday",
 	"Monday",	
 	"Tuesday",	
  	"Wednesday",
 	"Thursday",
 	"Friday",
 	"Saturday"
 	);
 
 for(@array){
     print "$_\t";
 }
 print "\n";
 
 for(1..30){
     print "$_\t";
     print "\n" if $_%7 == 0;
 }
\end{verbatim}
\end{waku}\\
以下はPerlらしいコードの例．解読してみてください．\\
\begin{waku}
\begin{verbatim}
 my @array = (
 	"Monday",	
 	"Tuesday",	
  	"Wednesday",
 	"Thursday",
 	"Friday",
 	"Saturday",
 	"Sunday"
 	);
 
 print "$_\t" for @array;
 print "\n";
 print  $_    for map{$_%7?"$_\t":"$_\n"}1..30;
\end{verbatim}
\end{waku}

\item{問題\stepcounter{question}\thequestion } \verb|いわゆる静的なハッシュ作成．|\\
\begin{waku}
\begin{verbatim}
 %login = (
 	matsui => "t03908mm",
 	okada  => "t02176yo"
 	); 
 
 print "matsui\t$login{matsui}\n";
 print "okada\t$login{okada}\n";
\end{verbatim}
\end{waku}

\item{問題\stepcounter{question}\thequestion } \verb|動的なハッシュ作成．エントリーをつけ足していくことができることから"動的"．|\\
\begin{waku}
\begin{verbatim}
 $login{ando} = "t03053fa";
\end{verbatim}
\end{waku}

\item{問題\stepcounter{question}\thequestion } \verb|基本的なハッシュエントリーの出力方法その1．|\\
\begin{waku}
\begin{verbatim}
 foreach my $key (keys %login){
     print "$key\t$login{$key}\n";
 }
\end{verbatim}
\end{waku}\\
\verb|$keyの代わりに$_を使うと略すことができます．つまり|\\
\begin{waku}
\begin{verbatim}
 foreach $_ (keys %login){
     print "$_\t$login{$_}\n";
 }
\end{verbatim}
\end{waku}\\
と\\
\begin{waku}
\begin{verbatim}
 foreach(keys %login){
     print "$_\t$login{$_}\n";
 }
\end{verbatim}
\end{waku}\\
は等価です．

\item{問題\stepcounter{question}\thequestion } \verb|基本的なハッシュエントリー出力方法その2．|\\
\begin{waku}
\begin{verbatim}
 while(my($key, $value) = each %login){
     print "$key\t$value\n";
 }
\end{verbatim}
\end{waku}\\
keysを使う方法はまず全てのkeyを含む配列を作っていました．しかしkeyの数が膨大なときは効率が悪くなります．そのような時はエントリーを一つずつ取り出していくこちらの方法をとるべきでしょう．

\item{問題\stepcounter{question}\thequestion } \verb|例文は以下のスクリプトと同じです．|\\
\begin{waku}
\begin{verbatim}
 #(1)塩基配列を一文字ずつ分解し，@arrayという配列に入れる．
 @array = split '', $seq
 
 #(2)カウント
 foreach my $elm(@array){
     $count{$elm} = $count{$elm} + 1;
 }
 
 #(3)出力
 foreach my $nuc(keys %count){
     print "$nuc\t$count{$nuc}\n";
 }
\end{verbatim}
\end{waku}
\begin{verbatim}
(1)ではまず文字列をより処理しやすい配列に変換しています．
 split '', $seq
とすることで文字列をヌルで切る，つまり一文字ずつ切り分けています．
次に(2)でカウントをしています．$count{}は%countの要素であることに注意．%countのエントリーにないkeyが来たときはvalueと共に新規に登録します．%countのエントリーの内容を１ループごとにたどってみるとよりはっきりするかもしれません．
(3)は出力です．keyとvalueを順に出力しています．
\end{verbatim}

\item{問題\stepcounter{question}\thequestion } \verb|$lineは毎回更新されていることに注意．ループを抜けたとき$lineには最終行の文字列が入っています．|\\
\begin{waku}
\begin{verbatim}
 open FILE, "testfile";
 
 while(<FILE>){
     $line = $_;
 }
 
 print $line;
\end{verbatim}
\end{waku}

\item{問題\stepcounter{question}\thequestion } \verb|改行を除いた後，単にカンマを添えてプリントすればOKです．|\\
\begin{waku}
\begin{verbatim}
 open FILE, "testfile";
 
 while(<FILE>){
     chomp;
     print "$_,";
 }
\end{verbatim}
\end{waku}\\
最後のカンマが気になる場合，.(ドット演算子)をうまく使うとよいでしょう．\\
\begin{waku}
\begin{verbatim}
 open FILE, "testfile";
 
 while(<FILE>){
     chomp;
     $seq .= "$_,";
 }
 
 chop $seq;
 print "$seq\n";
\end{verbatim}
\end{waku}\\
\verb|chompは文字列の最後の文字が改行(\n)か否かを判定して改行なら切り取る演算子でした．それに対してchopは最後の文字を無条件に切り取る演算子です．printの前にこの関数を置いておくことで余計なカンマ(,)を除外しています．以下に示すのはchompのイメージです．|\\
\begin{waku}
\begin{verbatim}
 sub chomp{
     $seq = shift;
     chop   $seq if substr($seq, -1, 1) eq "\n";
     return $seq;
 }
\end{verbatim}
\end{waku}

\item{問題\stepcounter{question}\thequestion } \verb|splitを使って一行ずつ配列に分割し，配列の1番目→0番目と表示すればOKです．|\\
\begin{waku}
\begin{verbatim}
 open FILE, "fruit.txt";
 
 while(<FILE>){
     chomp;
     @line = split;
     print "$line[1]\t$line[0]\n";
 }
printfを使うと簡単になります．
 open FILE, "fruit.txt";
 printf "%s\t%s\n", (split)[0,1] while <FILE>;
\end{verbatim}
\end{waku}

\item{問題\stepcounter{question}\thequestion } \verb|"ディレクトリの中にあるファイルを全て処理対象にする"，といった作業はよくでてきますのでマスターしておいてください．openの代わりにopendirとreaddirを使っていることに注意．opendirとreaddirはセットで使います．|\\
\begin{waku}
\begin{verbatim}
 $dir = "./";
 opendir DIR, $dir;
 @dir = readdir DIR;
 
 foreach(@dir){
     $file = $dir.$_;
     open FILE, $file or next;
     while(<FILE>){
         print;
     }
 }
\end{verbatim}
\end{waku}

\item{問題\stepcounter{question}\thequestion } \verb+||を使うと問題の意図を達成できます．+\\
\begin{waku}
\begin{verbatim}
 for(1..100){
     $rand   = int(rand(10)) || "ZERO";
     print "$rand\n";
 }
\end{verbatim}
\end{waku}\\
ただし以下の式自体は0〜9の整数を返すことに注意してください(10は返さない).\\
\begin{waku}
\begin{verbatim}
$rand = int(rand(10));
\end{verbatim}
\end{waku}\\
また\\
\begin{waku}
\begin{verbatim}
 $hoge ||= "hoge";
\end{verbatim}
\end{waku}\\
で0や未定義値のチェックを行うことができます．割り算を含むプログラムなどではこのようなケアは必須です．

\item{問題\stepcounter{question}\thequestion } \verb|a..zでaからｚまで26文字のリストを表します．|\\
\begin{waku}
\begin{verbatim}
 foreach my $chr(a..z){
     $alphabet = $alphabet . $chr;
 }
 $alphabet = $alphabet x 10;
 print "$alphabet\n";
\end{verbatim}
\end{waku}\\
短く書くとこんな感じ．\\
\begin{waku}
\begin{verbatim}
 $alphabet .= $_ for a..z;
 $alphabet x= 10;
 print "$alphabet\n";
\end{verbatim}
\end{waku}\\

\item{問題\stepcounter{question}\thequestion } \verb|大きさを比較すればよいので何らかの比較演算子を使うことになります．普通の演算子を使うと以下のようになります．|\\
\begin{waku}
\begin{verbatim}
 $first  = int(rand 10);
 $second = int(rand 10);
 
 if( $first < $second ){
     print "$first\t<\t$second\n";
 }
 elsif($first > $second){
     print "$first\t>\t$second\n";
 }
 else{
     print "$first\t=\t$second\n";
 }
\end{verbatim}
\end{waku}\\
\verb|<=>は左辺が大きければ1を右辺が大きければ-1を等しければ0を返します．これを利用しても良いでしょう．表示を上を揃えたければあらかじめハッシュを用意しておけば良いでしょう．|\\
\begin{waku}
\begin{verbatim}
 %kigou = (
     -1 => '<',
      0 => '=',
      1 => '>'
 );
 $first  = int(rand 10);
 $second = int(rand 10);
 
 $judge  = ($first <=> $second);
 print "$first\t$kigou{$judge}\t$second\n";
\end{verbatim}
\end{waku}

\item{問題\stepcounter{question}\thequestion } \verb|閏年のルール(グレゴリオ暦)|\\
\begin{waku}
\begin{verbatim}
 1．4で割り切れる年は閏年
 2. しかし100で割り切れた場合閏年ではない
 3. ただし400で割り切れたら閏年
\end{verbatim}
\end{waku}\\
 例えば2000年は閏年でした．\\
素直にコーディングすればこうなるでしょう．\\
\begin{waku}
\begin{verbatim}
 $year = 2004;
 
 if($year % 4 == 0){
 　　if($year%400 == 0){
         print "leapyear\n";    
     }
     elsif($year%100){
         print "not leapyear\n";
     }
     else{
         print "leapyear\n";
     }
 }
 else{
     print "not leapyear\n";
 }
\end{verbatim}
\end{waku}\\
フラッグを使うという手もあります．\\
\begin{waku}
\begin{verbatim}
 $year = 2004;
 
 $flag = 0;
 if($year % 4 == 0){
     $flag = 1;
 　　if($year%400 != 0 && $year%100 == 0){
         $flag = 0;
     }
 }
 
 if($flag){
     print "leapyear\n";    
 }
 else{
     print "not leapyear\n";    
 }
\end{verbatim}
\end{waku}\\
条件をまとめるとこんな感じです．\\
\begin{waku}
\begin{verbatim}
 if($year%400 == 0 || $year%4 == 0 && $year%100 != 0){
         print "leapyear\n";    
 }
 else{
     print "not leapyear\n";    
 }
\end{verbatim}
\end{waku}

\item{問題\stepcounter{question}\thequestion } \verb|まず|\\
\begin{waku}
\begin{verbatim}
 while(<FILE>){
     処理；
 }
\end{verbatim}
\end{waku}\\
の原型は\\
\begin{waku}
\begin{verbatim}
 while($_ = <FILE>){
     処理；
 }
\end{verbatim}
\end{waku}\\
であることを確認しましょう．\\
\verb|<>は次の行を読み込む演算子です．例えば|\\
\begin{waku}
\begin{verbatim}
 hoge\
 piyo
 foo\
 bar
\end{verbatim}
\end{waku}\\
という文があったときループごとに仕事を追ってくと\\
\begin{waku}
\begin{verbatim}
1.ifに入る．次を読み込み今の行と結合．
 	hogepiyo
 	foo\
 	bar
 	となってredoによって改めて一行目の処理に向かう
2.ifに入らずprint
3.二行目を読み込みifに入る．次を読み込み今の行と結合．
 	hogepiyo
 	foobar
 	となる
4.ifに入らずprint
5.次の行が無いのでループを抜ける
\end{verbatim}
\end{waku}\\
これはnext等では実装できません．\\
redoは以下のようなパターンのデータをパースするときに良く使います．\\
\begin{waku}
\begin{verbatim}
 A-	ab
 B-	c
  	d
  	e
 C-	f
 ↓
 %data = (
 	A => "ab",
 	B => "cde",
 	C => "f"
 	);
\end{verbatim}
\end{waku}\\
そのパーサ例\\
\begin{waku}
\begin{verbatim}
 #!/usr/bin/perl
 
 open FILE, $ARGV[0];
 while(<FILE>){
     if(/-/){
         $next = <FILE>;
         if($next =~ /-/ || !$next ){
             @line    = split '- ';
             $line[1] =~ s/[^a-zA-Z]//g;
             $data{$line[0]} = $line[1];
             $_   = $next;
             redo;
         }
         else{
             $_  .= $next;
             redo;
         }
     }
 }
 
 printf "%s\t%s\n", $_, $data{$_} for keys %data;
\end{verbatim}
\end{waku}

\item{問題\stepcounter{question}\thequestion } \verb|先ほどの解答を単に構文に落とせば完成です．|\\
\begin{waku}
\begin{verbatim}
 ($year%400 == 0 || $year%4 == 0 && $year%100 != 0)?
 print "leapyear\n":
 print "not leapyear\n";    
三項演算子を重ねても良いでしょう．
 ($year%400 == 0)?print "leapyear\n":
 ($year%100 != 0)?print "not leapyear\n":
 ($year%4   == 0)?print "leapyear\n":
                  print "not leapyear\n";
\end{verbatim}
\end{waku}\\
if文を使えばあらゆる条件分岐は表現できるので三項演算子は必須のものではないのですが，コードを見やすく短く済ませたいときに有効です．

\item{問題\stepcounter{question}\thequestion } \verb|正規表現の典型的な問題です．まずatgがあるかどうかを調べるときは|\\
\begin{waku}
\begin{verbatim}
 $seq = "agtgctagtcgtgtagctactacgtacgt";
 if($seq =~ /atg/){
     print "ATG codon exists in \$seq";
 }
 else{
     print "ATG codon don't exists in \$seq";
 }
\end{verbatim}
\end{waku}\\
です．同様に終止コドン(tag/tga/taa)があるかどうかを調べるときは\\
\begin{waku}
\begin{verbatim}
 $seq = "agtgctagtcgtgtagctactacgtacgt";
 if($seq =~ /tag/ || $seq =~ /tga/ || $seq =~ /taa/){
     print "ATG codon exists in \$seq";
 }
 else{
     print "ATG codon don't exists in \$seq";
 }
\end{verbatim}
\end{waku}\\
もう少し効率よくやるならば\\
\begin{waku}
\begin{verbatim}
 $seq = "agtgctagtcgtgtagctactacgtacgt";
 if($seq =~ /t(ga|a[ga])/){
     print "It matches.";
 }
 else{
     print "It doesn't match";
 }
\end{verbatim}
\end{waku}\\
これらをあわせれば解答は完成です．\\
\begin{waku}
\begin{verbatim}
 $seq = "agtgctagtcgtgtagctactacgtacgt";
 if($seq =~ /atg/ && $seq =~ /t(ga|a[ga])/){
     print "It matches.";
 }
 else{
     print "It doesn't match";
 }
\end{verbatim}
\end{waku}\\
ちなみに拡張正規表現を用いればこの解答は\\
\begin{waku}
\begin{verbatim}
 $seq = "agtgctagtcgtgtagctactacgtacgt";
 if($seq =~ /^(?=.*atg)(?=.*t(ga|a[ga]))/){
     print "It matches.";
 }
 else{
     print "It doesn't match";
 }
\end{verbatim}
\end{waku}\\
\verb|となります．(?=...)は先読み条件です．|\\
\begin{waku}
\begin{verbatim}
 /foo(?=bar)/
\end{verbatim}
\end{waku}\\
で後ろにbarを伴うfooにだけマッチします．先の解答はつまり行頭の後ろに何文字かおいてatgがあるし，同様に終止コドンもある，という条件を満たすことになります．

\item{問題\stepcounter{question}\thequestion } \verb|後方参照の練習です．|\\
\begin{waku}
\begin{verbatim}
 @nuc = ('a', 't', 'c', 'g');
 for(1..300){
     $seq .= $nuc[int(rand 4)];
 }
 
 while($seq =~ /([atgc]{6})atg([atgc]{6})/g){
     print "$1\t$2\n";
 }
\end{verbatim}
\end{waku}

\item{問題\stepcounter{question}\thequestion } \verb|略．リファレンス等を見てください．|\\

\item{問題\stepcounter{question}\thequestion } \verb|コード例は色々とあります．|\\
\begin{waku}
\begin{verbatim}
 sub my_reverse{
     my $seq = shift;
     my @seq = split //, $seq;
     my $reverse_seq;
     for(@seq){
         $reverse_seq = $_ . $seq;
     }
     return $reverse_seq;
 }
\end{verbatim}
\end{waku}\\
とか\\
\begin{waku}
\begin{verbatim}
 sub my_reverse{
     my $seq = shift;
     my @seq = split //, $seq;
     my $i = length $seq;
     my $reverse_seq;
     while(--$i >= 0){
         $reverse_seq .= $seq[$i];
     }
     return $reverse_seq;
 }
\end{verbatim}
\end{waku}\\
あるいは\\
\begin{waku}
\begin{verbatim}
 sub my_reverse{
     my $seq    = shift;
     my $length = length $seq;
     my $reverse_seq;
     for(1..$length){
         $reverse_seq .= substr $seq, $length-$_, 1;
     }
     return $reverse_seq;
 }
\end{verbatim}
\end{waku}

\item{問題\stepcounter{question}\thequestion } \verb|定義式をそのまま実装すればOKです．|\\
一本の配列のエントロピーを算出する関数\\
\begin{waku}
\begin{verbatim}
 sub entropy{
     my $seq    = lc shift;
     my $length = length($seq)||1;
     my(%count, $H);
     $count{$_}++ for split //, $seq;
     for('a', 't', 'c', 'g'){
         $count{$_}  /= $length;
         $count{$_} ||= 1;
         $H -= $count{$_}*log($count{$_})/log(2);
     }
     return $H;
 }
 
 my $seq = 'aaaaggactt';
 my $entropy = &entropy($seq);
 print "entropy = $entropy\n";
\end{verbatim}
\end{waku}\\
複数の配列のエントロピーを算出する関数\\
\begin{waku}
\begin{verbatim}
 sub entropy{
     my $seq_ref = shift;
     my $number  = scalar @{$seq_ref}||1;
     my(%count, @H, $i);
     for(@{$seq_ref}){
         $i = 0;
         ++$count[$i++]{$_} for split //;
     }
     for my $pos(0..$#count){
         for my $nuc('a', 't', 'c', 'g'){
             $count[$pos]{$nuc}  /= $number;
             $count[$pos]{$nuc} ||= 1;
             $H[$pos] -= $count[$pos]{$nuc} *log($count[$pos]{$nuc}) /log(2);
         }
     }
     return @H;
 } 
 my @seq = (
               'ataatgaatt',
               'ccacgcacta',
               'gcaacgacat',
               'ctattcacct'
           );
 my @entropy = &entropy(\@seq);
 print "$_\t$entropy[$_]\n" for 0..$#entropy;
\end{verbatim}
\end{waku}

\item{問題\stepcounter{question}\thequestion } \verb|リファレンスにして関数に引渡し，関数の中でデリファレンスできれば正解です．|\\
\begin{waku}
\begin{verbatim}
 sub my_reverse{
     my $seq = shift;
     my @seq = split //, $$seq;
     my $reverse_seq;
     for(@seq){
         $reverse_seq = $_ . $reverse_seq;
     }
     return $reverse_seq;
 }
 
 my $reverse_seq = &my_reverse(\$seq);
\end{verbatim}
\end{waku}

\item{問題\stepcounter{question}\thequestion } \verb|リファレンスの動作を確かめる問題です．|\\
\begin{waku}
\begin{verbatim}
 @array      = (1, 2, 3, 4, 5);
 $array_ref1 = \@array;
 $array_ref2 = [@array];
 
 print "$array_ref1->[2]\n";
 print "$array_ref2->[2]\n";
 
 $array[2] = 'x';
 
 print "$array_ref1->[2]\n";
 print "$array_ref2->[2]\n";
\end{verbatim}
\end{waku}

\item{問題\stepcounter{question}\thequestion } \verb|ハッシュに格納してしまうのが手っ取りばやく，また効率の良い方法です．|\\
\begin{waku}
\begin{verbatim}
 for(@row){
     $uniq{$_} = 1;
 }
 for(keys %uniq){
     push @uniq, $_;
 }
\end{verbatim}
\end{waku}\\
あるいは重複する要素を記録して言ってもよいでしょう．\\
\begin{waku}
\begin{verbatim}
 for(@row){
     next if $uniq{$_}++;
     push @uniq, $_;
 }
\end{verbatim}
\end{waku}\\
これらを短くすると\\
\begin{waku}
\begin{verbatim}
 @uniq = keys %{{map{$_, 1}@row}};
\end{verbatim}
\end{waku}\\
または\\
\begin{waku}
\begin{verbatim}
 @uniq = grep{!$exist{$_}}@row;
\end{verbatim}
\end{waku}\\
となります

\item{問題\stepcounter{question}\thequestion } \verb|Cの構造体likeなデータ構造を構築できます．|\\
\begin{waku}
\begin{verbatim}
 $seq   = 'atgacgtggtac';
 @array = ('a', 'r', 'r', 'a', 'y');
 %hash  = ('h' => 'a', 's' => 'h');
 sub hello{
     print "Hello! $_[0]!\n";
 }
 
 $struct = {
     scalar => \$seq,
     array  => \@array,
     hash   => \%hash,
     sub    => \&hello
 };
\end{verbatim}
\end{waku}\\
もちろん直接作ってもかまいせん．\\
\begin{waku}
\begin{verbatim}
 $struct = {
     scalar => \'atgacgtggtac',
     array  => ['a', 'r', 'r', 'a', 'y'],
     hash   => {'h' => 'a', 's' => 'h'},
     sub    => sub{"Hello! $_[0]!\n"}
 };
\end{verbatim}
\end{waku}

\item{問題\stepcounter{question}\thequestion } \verb|ランダム配列の作り方としては以下の二つを覚えればよいでしょう．|\\
\begin{waku}
\begin{verbatim}
 i)
 @nuc = ('a', 't', 'c', 'g');
 $seq .= $nuc[int(rand 4)] for 1..300;
 
 ii)
 $seq .= int(rand 4) for 1..300;
 $seq =~ tr/0123/atgc/;
\end{verbatim}
\end{waku}\\
あとはループとsubstrを使って順にコドンを抜き出せばよいでしょう．\\
\begin{waku}
\begin{verbatim}
 for(0..299){
     $codon = substr $seq, $_, 3;
     $count[$_%3]{$codon}++;
 }
 
 for my $frame(0..2){
     print "### $frame ###\n";
     for(sort{$count[$frame]{$b} <=> $count[$frame]{$a}}
         keys %{$count[$frame]}){
         print "$_\t$count[$frame]{$_}\n"
     }
 }
\end{verbatim}
\end{waku}

\item{問題\stepcounter{question}\thequestion } \verb|index関数の特徴をうまく利用してやると以下のようにwindexが実装できます．|\\
\begin{waku}
\begin{verbatim}
 sub windex{
     my($seq, $pat) = @_;
     my $pos = -1;
     my @all_position;
     while( ($pos=index($seq, $pat, $pos)) >-1){
         push @all_position, $pos;
         $pos++;
     }
     return @all_position;
 }
\end{verbatim}
\end{waku}\\
あるいは正規表現//gを使ってもできます．\\
\begin{waku}
\begin{verbatim}
 sub windex{
     my($seq, $pat) = @_;
     my @all_position;
     while($seq =~ /$pat/g){
         push @all_position, length $`;
     }
     return @all_position;
 }
\end{verbatim}
\end{waku}

\item{問題\stepcounter{question}\thequestion } \verb|trをカウントに使います．|\\
\begin{waku}
\begin{verbatim}
 $seq   = 'atgtgctgtagctgatgctgatcggggcgcgatc';
 $count = $seq =~ tr/gcGC/gcGC/;
\end{verbatim}
\end{waku}\\
あるいは\\
\begin{waku}
\begin{verbatim}
 $seq   = 'atgtgctgtagctgatgctgatcggggcgcgatc';
 $count = tr/gcGC/gcGC/ for $seq;
\end{verbatim}
\end{waku}

\item{問題\stepcounter{question}\thequestion } \verb|各関数とも重要ですので，書式，動作を確かめておきましょう．|\\
\begin{waku}
\begin{verbatim}
 @array = ('a', 'b', 'c', 'd', 'e');
 $first = shift @array;
 $last  = pop   @array;
 unshift @array, $last;
 push    @array, $first;
\end{verbatim}
\end{waku}

\item{問題\stepcounter{question}\thequestion } \verb|これらの関数のうち，popとshiftは与えられた配列を変更する機能の他，削られた要素を戻り値として返します．それらを実装するにはリファレンス演算子を用いたリファレンス渡し，及びreturnを用いた戻り値の設定が必要です．|\\
\begin{waku}
\begin{verbatim}
 sub my_unshift{
     my($array, $elm) = @_;
     splice @{$array}, 0, 0, $elm;
 }
 
 sub my_shift{
     my $array = shift;
     my $elm   = splice @{$array}, 0, 1;
     return $elm;
 }
 
 sub my_pop{
     my $array = shift;
     my $elm   = splice @{$array}, $#array, 1;
     return $elm;
 }
 
 sub my_push{
     my($array, $elm) = @_;
     splice @{$array}, $#{$array}+1, 0, $elm;
 }
\end{verbatim}
\end{waku}

\item{問題\stepcounter{question}\thequestion } \verb|(A, B) = (B, A)とすることで一時変数を使うことなく安全に値の交換ができます．|\\
\begin{waku}
\begin{verbatim}
 @foo = (1, 2, 3, 4, 5);
 @foo[2, 4] = @foo[4, 2];
\end{verbatim}
\end{waku}

\item{問題\stepcounter{question}\thequestion } \verb|上の問題で交換するペアを0, -1にかえれば完成です．|\\
\begin{waku}
\begin{verbatim}
 @foo = (1, 2, 3, 4, 5);
 @foo[0, -1] = @foo[-1, 0];
\end{verbatim}
\end{waku}

\setcounter{question}{44}
\item{問題\stepcounter{question}\thequestion } \verb|引数は@ARGV (ARGument Vector)に入っています．個別に値をとりたいときは$ARGV[0]などとすればよいでしょう．また@ARGV自体は変更しないようにしましょう|\\
\begin{waku}
\begin{verbatim}
 my @arg = @ARGV;
 my $mean;
 $mean += $_ for @arg;
 $mean /=($#arg+1)||1;
 print "$mean\n";
\end{verbatim}
\end{waku}

\item{問題\stepcounter{question}\thequestion } \verb|lastを使って最近のログインランキングを調べるプログラムは以下の通りになるでしょう．|\\
\begin{waku}
\begin{verbatim}
 my @last = `last`;
 my %count;
 chomp @last;
 for(@last){
     my($name) = (split)[0];
     $count{$name}++;
 }
 for(sort{$count{$b} <=> $count{$a}}keys %count){
     printf "%s\t%d\n", $_, $count{$_};
 }
\end{verbatim}
\end{waku}

\end{description}

\subsection*{第3章 実践 Bioinformatics}
\begin{description}

\item{問題\stepcounter{question}\thequestion } \verb|二元配列がどのように行列を表しているか理解しておきましょう．|\\
\begin{waku}
\begin{verbatim}
 sub addition{ #足し算
     my($A, $B) = @_;
     my @A = @$A;
     my @B = @$B;
     my @C;
     for my $i(0..$#A){
         for my $j(0..$#{$A[0]}){
             $C[$i][$j] = $A[$i][$j]+$B[$i][$j];
         }
     }
     return @C;
  }
 sub multiplication{ #かけ算
     my($A, $B) = @_;
     my @A = @$A;
     my @B = @$B;
     my @C;
     for my $i(0..$#A){
         for my $j(0..$#{$B[0]}){
             for my $elm(0..$#B){
                 $C[$i][$j] += $A[$i][$elm]*$B[$elm][$j];
             }
         }
     }
     return @C;
 }
 my @A = ([1, 2],
          [3, 4]);
 my @B = ([5, 6],
          [7, 8]);
 my @ADD  = &addition(\@A, \@B);
 my @MULTI = &multiplication(\@A, \@B); 
 for my $i(0..$#ADD){
     for my $j(0..$#{$ADD[$i]}){
         print "$ADD[$i][$j]\t";
     }
     print "\n";
 }
 for my $i(0..$#MULTI){
     for my $j(0..$#{$MULTI[$i]}){
         print "$MULTI[$i][$j]\t";
     }
     print "\n";
 }
\end{verbatim}
\end{waku}
\end{description}

\newpage

\section{リファレンス}
\subsection*{Perl編}
\subsubsection*{スカラー変数操作法}
\begin{table}[h]
\begin{center}

\caption{スカラー変数操作法}

\begin{tabular}{cll}\hline
関数&説明&使用例\\ \hline
length&文字列の長さを返す&length 文字列\\ %\hline
reverse&文字列を逆にする&reverse 文字列\\ %\hline
index&文字列中のパターンの位置を返す&index 文字列, パターン, 捜査開始位置\\ %\hline
substr&文字列から指定した位置の部分文字列を返す&substr 文字列, 開始位置, 長さ\\ %\hline
s&置換&s/パターン/変換後の文字列/g\\ %\hline
tr&変換&tr/abc/pqr/\\ %\hline
lc&全て小文字に変換&lc 文字列\\ %\hline
sprintf&文字列の整形&\verb|sprintf フラッグ, 変数, …|\\ %\hline
chop&最後の文字を削る&chop 文字列\\ %\hline
chomp&改行を削る&chomp 文字列\\ %\hline
join&リストを結合して文字列を返す&\verb|join /区切り文字/, @array|\\ %\hline
split&文字列を区切り文字を目印に分割&split /区切り文字/, 文字列\\ %\hline
abs&絶対値を返す&abs 数値\\ %\hline
int&小数点以下を切り捨て&int 数値\\ %\hline
rand&乱数を返す&rand 数値\\ \hline
\end{tabular}
\end{center}
\end{table}

\subsubsection*{配列変数操作法}
\begin{table}[h]
\begin{center}

\caption{配列変数操作法}

\begin{tabular}{cll}\hline
関数&説明&書式\\ \hline
shift&先頭の要素を削除&\verb|shift @array|\\ %\hline
unshift&先頭に要素を追加&\verb|unshift @array, $scalar|\\ %\hline
pop&末尾の要素を削除&\verb|pop @array|\\ %\hline
push&末尾に追加&\verb|push @array, $scalar|\\ %\hline
sort&リストの要素をソート& \verb|@sorted = sort @mess|\\ %\hline
reverse&リストを逆順にならべる&\verb|reverse @array|\\ %\hline
map&配列を新たに作成&\verb|map{式}@array|\\ %\hline
grep&配列の要素を選別&\verb|grep{式}＠array|\\ %\hline
splice&要素を置換&\verb|splice @array, 位置, 要素数, 置換後のスカラーor配列|\\ \hline
\end{tabular}
\end{center}
\end{table}

\newpage

\subsubsection*{ハッシュ変数操作法}
\begin{table}[h]
\begin{center}

\caption{ハッシュ変数操作法}

\begin{tabular}{cll}\hline
関数&説明&使用例\\ \hline
keys&キーをリストにして返す& \verb|@keys = keys %hash|\\ %\hline
values&値をリストにして返す& \verb|@values = values %hash|\\ %\hline
each&キーと値のペアを一つずつ返す& \verb|while(($key, $value) = each %hash){式}|\\ %\hline
exists&キーが存在するか判定& \verb|exists $hash{$key}|\\ %\hline
delete&キーを削除& \verb|delete $hash{$key}|\\ %\hline
defined&値が真か判定& \verb|defined $hash{$key}|\\ %\hline
undef&値を初期化& \verb|undef $hash{$key}|\\ %\hline
reverse&キーと値を入れかえる& \verb|reverse %hash|\\ \hline
\end{tabular}
\end{center}
\end{table}

\subsubsection*{正規表現}
\begin{table}[h]
\begin{center}

\caption{正規表現}

\begin{tabular}{cl}\hline
正規表現&書式\\ \hline
\verb|.(ドット)|&\verb|ワイルドカード, 全てにマッチ(スペース, ヌルを含む)|\\ %\hline
\verb|\d, \D|&\verb|\dは整数にマッチ|\\ %\hline
\verb|\w, \W|&\verb|\wは[a-zA-Z0-9_]にマッチ|\\ %\hline
\verb|\s, \S|&\verb|\sはスペースorタブor改行にマッチ|\\ %\hline
\verb-a|b-&\verb|aまたbにマッチ|\\ %\hline
\verb|[abc]|&\verb|a, b, cのどれかにマッチ|\\ %\hline
\verb|[^a]|&\verb|a以外にマッチ|\\ %\hline
\verb|[a-z]|&\verb|a,b,…,zのどれかにマッチ|\\ %\hline
\verb|( )|&\verb|正規表現のグループ化, 同時に$1などに格納|\\ %\hline
\verb|$1, \1|&\verb|( )にマッチした文字列を格納|\\ %\hline
\verb|^|&\verb|行頭を意味する|\\ %\hline
\verb|$|&\verb|行末を意味する|\\ %\hline
\verb|a?|&\verb|aもしくはヌルにマッチ|\\ %\hline
\verb|a*|&\verb|aの0回以上の繰り返し|\\ %\hline
\verb|a+|&\verb|aの1回以上の繰り返し|\\ %\hline
\verb|a{m, n}|&\verb|aのm回以上, n回以下の繰り返し|\\ %\hline
\verb|??, *?, +?|&\verb|最短マッチ|\\ %\hline
\verb|\b|&\verb|単語の境にマッチ|\\ %\hline
\verb|\記号|&\verb|特別な意味のあるワードをエスケープする|\\ \hline
\end{tabular}
\end{center}
\end{table}

\newpage

\subsubsection*{printfの使い方}
\begin{description}
\item{構文} \\
\begin{waku}
\begin{verbatim}
printf "フラッグ", 第一項, 第二項,...;
\end{verbatim}
\end{waku}

\item{主なフラッグ}
\begin{description} 
\item{\verb|%s|} 文字列
\item{\verb|%d|} 整数
\item{\verb|%f|} 浮動小数点表示 (\verb|%.3fで小数第三位まで表示|)
\item{\verb|%e|} 科学表記 (\verb|%.3eで仮数を三桁まで表示|)
\item{\verb|\n|} 改行
\item{\verb|\t|} タブ
\end{description}

\item{例文} \\
\begin{waku}
\begin{verbatim}
printf "%\ts%.2f\n", 'pi ~ ', '3.14159';
\end{verbatim}
\end{waku}\\
→pi \verb|~| 3.14\\

\end{description}

\newpage

% このテキストを作成するにあたって参考にした文献，資料を以下にあげます．
% Perlに関する書籍，webページは膨大な数にのぼります．入門書は個々人にあっ
% たものを選べばよいでしょう．以下にあげた本は入門レベルをマスターし，実践
% 的なプログラムを書いていく上で必須のものです．まずざっと目を通しておくこ
% とをお勧めします．そして手元におき，いつでも引けるようにしておけば効率の
% 良いプログラミングが可能になるに違いありません．

\begin{thebibliography}{99}
\bibitem{PPerl} Larry Wall {\it et al.} (2002) Programing Perl第三版，O’REILLY
\bibitem{EPerl} Hall, JN.，Schwarrtz, RL(1999) Effective Perl，アスキー出版局
\bibitem{PerlCGIRef} 藤田郁，三島俊司(2004) Perl/CGIプチリファレンス，技術評論社
\bibitem{PerlCook} Christiansen, T. {\it et al.} (2004) Perlクックブック第二版，O’REILLY
\end{thebibliography}

\printindex

\end{document}