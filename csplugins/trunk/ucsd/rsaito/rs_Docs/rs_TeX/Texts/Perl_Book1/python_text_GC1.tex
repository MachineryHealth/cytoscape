\documentclass{jarticle}

\usepackage[dvips]{graphicx}
\usepackage{wrapfig}
\usepackage{ascmac}
\usepackage{makeidx}
\usepackage{fancyhdr}
\usepackage{fancybox}


\setlength{\oddsidemargin}{0.5cm}
\setlength{\evensidemargin}{0.5cm}
\setlength{\textwidth}{423pt}
\setlength{\topmargin}{0pt}

\newenvironment{waku} 
{\begin{Sbox}\begin{minipage}{0.9\textwidth}} 
{\end{minipage}\end{Sbox}\shadowbox{\TheSbox}} 

\newcounter{question}
\setcounter{question}{1}

\title{{\normalsize 共和国新人特訓講座}\\
GC含有量の解析}
\author{慶應義塾大学先端生命科学研究所}

\makeindex

\begin{document}

\maketitle

\section{PythonによるGenBankファイルの解析}\index{GenBank}

GenBankは米国のNCBI(国立バイオテクノロジー情報センター)が管理している膨
大な量の塩基配列・アミノ酸配列情報を搭載した遺伝子データベースです。GenBankフ
ァイル\footnote{ftp://ftp.ncbi.nih.gov/genbank/よりダウンロード可能。}に
は塩基配列はもちろんのこと、どの部分がタンパク質をコードしているかなど、
それらの配列に付随する有益な情報が載せられており、プログラムを使った網羅
的な解析をする上で大変有用です。そこでこの節ではGenBankファイルの処理
の基本を学びます。


\section{GenBankファイルの構造}
\begin{description}
\item{解説} GenBankのファイルは基本的に次のような構造になっています．\\
\begin{waku}
\begin{small}
\begin{verbatim}
LOCUS エントリー名
そのエントリーの塩基配列に関する情報
                    :                   
                    :
ORIGIN
そのエントリーの塩基配列
                    :                   
                    :                   
//
LOCUS エントリー名
そのエントリーの塩基配列に関する情報
                    :
                    : 
ORIGIN
そのエントリーの塩基配列
                    :                   
                    :                   
//
LOCUS エントリー名
                    :
                    :
そのエントリーの塩基配列
                    :                   
                    :
//
\end{verbatim}
\end{small}
\end{waku}\\

各塩基配列はエントリーという単位で格納されています．そして各エントリーは
塩基配列の情報を記述するヘッダ部分(LOCUSからORIGINの間)と実際の塩基配列
の情報が書かれている部分(ORIGINから//の間)に分かれています．またエントリー中の記述の意味の
例を次のページに示しました。霊長類，脊椎
動物などのGenBankファイルには複数のエントリーが含まれています．しかし，
大腸菌の全ゲノム配列などのGenBankファイルには1つのエントリーしか含まれ
ていません．通常配列解析を行う場合は，GenBank中の各エントリー中の塩基配
列と塩基配列に関する情報を照らし合わせながら，解析を行います．

\end{description}

\section{初歩的な塩基配列処理}
\begin{description}

\item{問題\refstepcounter{question}\label{ht5}\thequestion} では解析のごく初歩的な例として，各エントリーの配列の先頭と末端5塩基を表示する
プログラムを作成しましょう．次のエントリーをそのプログラムの入力とすると，gaatt, ctatgが出力
されるはずです．\\

\begin{waku}
\begin{small}
\begin{verbatim}
LOCUS       HSAPC3B       558 bp    RNA             PRI       10-NOV-1994
DEFINITION  Human mRNA for pre-apolipoprotein CIII. ←この配列はどういうものか、
ACCESSION   X01388                                    その定義が記述されている
NID         g28727
KEYWORDS    apolipoprotein; lipoprotein; signal peptide.
SOURCE      human.
  ORGANISM  Homo sapiens ← 生物名
            Eukaryotae; mitochondrial eukaryotes; Metazoa/Eumycota group;
            Metazoa; Eumetazoa; Bilateria; Coelomata; Deuterostomia; Chordata;
            Vertebrata; Gnathostomata; Osteichthyes; Sarcopterygii; Choanata;
            Tetrapoda; Amniota; Mammalia; Theria; Eutheria; Archonta; 
            Primates; Catarrhini; Hominidae; Homo.
REFERENCE   1  (bases 1 to 558)
  AUTHORS   Levy-Wilson,B., Appleby,V., Protter,A., Auperin,D. and
            Seilhamer,J.J.
  TITLE     Isolation and DNA sequence of full-length cDNA for human
            preapolipoprotein CIII
  JOURNAL   DNA 3 (5), 359-364 (1984)
  MEDLINE   85076166
FEATURES             Location/Qualifiers
     source          1..558
                     /organism="Homo sapiens"
     CDS             72..371  ←コード領域
                     /codon_start=1             ↓コードされているタンパク質名
                     /product="pre-apolipoprotein CIII" 
                     /db_xref="PID:g28728"      ↓コードされているアミノ酸配列
                     /translation="MQPRVLLVVALLALLASARASEAEDASLLSFMQGYMKHATKTA
                     KDALSSVQESQVAQQARGWVTDGFSSLKDYWSTVKDKFSEFWDLDPEVRPTSAVAA"
     sig_peptide     72..131
     mat_peptide     132..368
                     /product="apolipoprotein CIII"
     misc_feature    532..537
                     /note="polyA signal"
\end{verbatim}

\noindent
\verb|BASE COUNT      107 a    175 c    143 g    133 t|

\verb|ORIGIN  ↓ここから下が実際の塩基配列(下線部分がCDS)|

\verb|        1 gaattctttt tttttttttt tttgttgctc agttcatccc tagaggcagc tgctccagga|

\verb|       61 acagaggtgc c|\underline{\tt atgcagccc cgggtactcc ttgttgttgc cctcctggcg ctcctggcct}

\verb|      121 |\underline{\tt ctgcccgagc ttcagaggcc gaggatgcct cccttctcag cttcatgcag ggttacatga}

\verb|      181 |\underline{\tt agcacgccac caagaccgcc aaggatgcac tgagcagcgt gcaggagtcc caggtggccc}

\verb|      241 |\underline{\tt agcaggccag gggctgggtg accgatggct tcagttccct gaaagactac tggagcaccg}

\verb|      301 |\underline{\tt ttaaggacaa gttctctgag ttctgggatt tggaccctga ggtcagacca acttcagccg}

\verb|      361 |\underline{\tt tggctgcctg a}\verb|gacctcaat accccaagtc cacctgccta tccatcctgc gagctccttg|

\verb|      421 ggtcctgcaa tctccagggc tgcccctgta ggttgcttaa aagggacagt attctcagtg|

\verb|      481 ctctcctacc ccacctcatg cctggccccc ctccaggcat gctggcctcc caataaagct|

\verb|      541 ggacaagaag ctgctatg|

\verb|//|
\end{small}
\end{waku}\\\\
まずseqという変数に塩基配列を格納していき，格納し終わった段階でseqの先頭と末尾の5塩基を表示するという方法を考えましょう．\\
塩基配列が格納されている部分はORIGINから//の間です．実はORIGINから//の間
の文字を取り出すという方法を使った方が正確ですが，これについては後ほど触
れることにして，ここでは塩基配列が書かれている行が，\\
\\
空白 数字 空白 塩基配列
\\\\
という順番で並んでいることを利用しましょう．これは正規表現と呼ばれるパターンマッチの表現で表すと，\\
\begin{waku}
\begin{verbatim}
import re   # なるべくプログラムの先頭の方にに配置
pat_nuc = re.compile(r"^ *[0-9]+ [a-z]")
\end{verbatim}
\end{waku}\\
になります．次にこの条件に合致する行から塩基配列を取り出して格納しておく必要があります．まず，塩基配列以外の文字（数値，空白など）を,\\
\begin{waku}
\begin{verbatim}
import re                         # なるべくプログラムの先頭に配置
pat_spc = re.compile(r"[^a-z]")   # なるべくプログラムの先頭の方にに配置
line = pat_spc.sub("", line)
\end{verbatim}
\end{waku}\\
によって取り除き，次に塩基配列格納変数\verb|seq|に以下のような文を使って塩基配列を追加していきます．\\
\begin{waku}
\begin{verbatim}
seq += line
\end{verbatim}
\end{waku}\\
\verb|そして//という行を見つけたら，seqの先頭と末尾の5文字を表示します．|これは、\\
\begin{waku}
\begin{verbatim}
print seq[0:5], seq[-5:]
\end{verbatim}
\end{waku}\\
のようにするといいでしょう． なお，先頭の文字は1番目ではなく0番目から始まることに注意して下さい．
また先頭にLOCUSという文字列が現れたら，新しいエントリーの始まりなので，\\
\begin{waku}
\begin{verbatim}
seq = ""
\end{verbatim}
\end{waku}\\
として中味を空にします．\\
\begin{waku}
\begin{small}
\begin{verbatim}
#!/usr/bin/env python

import sys
import re

pat_nuc = re.compile(r"^ *[0-9]+ [a-z]")
pat_spc = re.compile(r"[^a-z]")

seq = "";

fh = open(sys.argv[1])
for line in fh:
    if line.startswith("LOCUS"):
        seq = ""
    elif pat_nuc.search(line):
        line = pat_spc.sub("", line)
        seq += line
    elif line.startswith("//"):
        pass # ここは自分で考えて書き換えましょう。

fh.close()
\end{verbatim}
\end{small}
\end{waku}\\
このプログラムのファイル名を\verb|head_tail_seq.py|、処理の対象となるGenBankファイルをtest.seq\footnote{
GenBankのサンプルファイルはhttp://www.bioinfo.sfc.keio.ac.jp/class/genpro/Seqs/test.seqよりダウンロード可能。
このファイルには複数のエントリーが含まれています。
}とすると、
\verb|chmod +x ./head_tail_seq.py|で実行権を与えた後、\\
\begin{waku}
\begin{verbatim}
./head_tail_seq.py test.seq
\end{verbatim}
\end{waku}\\
と打ち込みます。
\end{description}

\section{ゲノムのGC含有量の解析}
\label{gc_content}

\begin{description}
\item[解説] GC含有量\footnote{GC含量、GC contentとも呼ばれます。}は核酸配列の性質を調べる上で基本的な指標で、以下のように定義されます。

\begin{displaymath}
\mbox{GC含有量}=\frac{\mbox{対象とする核酸配列に含まれるCとGの数}}{\mbox{対象とする核酸配列の長さ}}
\end{displaymath}

例えば、\tt{ACTCAATGAG}という核酸配列のGC含有量は40\%になります。核酸配列のGC含有量には以下のような生物学的意義や応用があります。

\begin{itemize}
\item 核酸の立体構造上の安定性、二次構造のできやすさ
\item ゲノム全体の塩基組成
\item ゲノム上の遺伝子領域の予測
\item ゲノム上の外来性領域の予測
\end{itemize}

\item[問題\refstepcounter{question}\label{ex_gc}\thequestion] 大腸菌のゲノム配列\footnote{
大腸菌のゲノム配列はhttp://www.bioinfo.sfc.keio.ac.jp/class/genpro/Seqs/ecoli.gbkよりダウンロード可能。}
上のGC含有量の
推移を計算しましょう。また計算結果をMicrosoft Excelなどを用い
て、図\ref{gccont1}のようなグラフにしましょう。

まず与えられた核酸配列のGC含有量を計算する関数\verb+calc_gc+を以下のように作成します。\\
\begin{waku}
\begin{verbatim}
def calc_gc(seq_frag):
   gc_count = seq_frag.count("c") + seq_frag.count("g")
   return 1.0 * gc_count / len(seq_frag)
\end{verbatim}
\end{waku}\\
ここで、\verb+seq_frag.count("c")+は\verb+$seq_frag+中に含まれ
るcの数を数えます。
これを配列の長さ\verb|len(seq_frag)|で割ればGC含有量が計算できます。このとき、
1.0を掛けて小数演算であることを明示します。
この関数を\\
\begin{waku}
\begin{verbatim}
print calc_gc("acgta")
\end{verbatim}
\end{waku}\\
のように呼び出すと、0.4が表示されるでしょう。
さて次に塩基配列の読み込みですが、問題\ref{ht5}では塩基配列が書かれている行の
パターンマッチを行ってした。しかしここではより厳密に、
次のように"ORIGIN"以下の行から"//"の部分までの塩基配列を読み込み、それを返す関数\verb+get_sequence+を
作成します。\\
\begin{waku}
\begin{verbatim}
def get_sequence(fh):
    seq = ""
    for line in fh: # 塩基配列の行を一行読み込む
        if line.startswith("//"): # //を見つけたらそこで終了
            break
        else:
            line = pat_spc.sub("", line)
               # 塩基配列の行に含まれる数字、空白などを削除する
            seq += line # seqに配列全体を格納

    return seq
\end{verbatim}
\end{waku}\\
この関数はORIGINを見つけた後、\\
\begin{waku}
\begin{verbatim}
seq = get_sequence(fh) #ファイルハンドルを渡す
\end{verbatim}
\end{waku}\\
とファイルハンドルを引数にして呼び出すことによって、塩基配列が\verb|seq|に代入されます。

さて次にGenBankファイルを読み込んで、"ORIGIN"を見つけた後、\verb+get_sequence+を呼び出す
部分を作成します。\\
\begin{waku}
\begin{verbatim}
import sys

fh = open(sys.argv[1], "r")
seq = ""
for line in fh:
   if line.startswith("ORIGIN"):
      seq = get_sequence(fh) 

fh.close()
\end{verbatim}
\end{waku}

%%%%%

\begin{figure}
\begin{itembox}[l]{大容量GenBank塩基配列の処理}
関数\verb|get_sequence|は
塩基配列がそれほど長くない場合に有効です．しかし，ヒトゲノムの
GenBankファイルなど塩基配列が数十億の長さになる場合は，マシンによっては
処理が困難になってしまいます．そこでこのような場合は，塩基配列だ
けが書かれているファイルを次の関数を用いて作成します．\\
\begin{waku}
\begin{verbatim}
def save_sequence(filename, fh): 
    
    seqfh = open(filename, "w");
    # filenameという名前のファイルを書きこみ用にオープンする

    for line in fh:
        if line.startswith("//"):
            break
        else:
            line = pat_spc.sub("", line)
               # 塩基配列の行に含まれる数字、空白などを削除する
            seqfh.write(line);

    seqfh.close()

\end{verbatim}
\end{waku}\\
この関数を\\
\begin{waku}
\begin{verbatim}
save_sequence("seq.tmp", fh)
\end{verbatim}
\end{waku}\\
のように呼び出します．すると塩基配列だけが書かれた"seq.tmp"というファイルが
作成されます。そして塩基配列を読み込むときは、次のようにseq.tmpをopenし，
seek関数とread関数を使って塩基配列の任意の場所を読み込むといいでしょう。\\
\begin{waku}
\begin{verbatim}
seqfh = open("seq.tmp", "r");
   # 塩基配列だけが書かれたファイル"seq.tmp"をオープン
seqfh.seek(100, 0);
   # 塩基配列の100番目から読み込みを開始する
seq = seqfh.read(3);
   # 3文字読みとって、それを$seqに格納する
print seq
seqfh.close()
\end{verbatim}
\end{waku}
\end{itembox}
\end{figure}

\begin{figure}
\begin{center}
\includegraphics[scale=0.5]{figs/gccont_win.eps}
\end{center}
\caption{ウィンドウを使用したゲノム上のGC含有量推移の計算}
\label{gcskew_win}
\begin{quotation}
\begin{small}
この例ではウィンドウの大きさを5塩基、移動幅を3塩基に設定した。ウィンドウの中の数値はGC含有量を表す。
\end{small}
\end{quotation}
\vspace{1em}
\end{figure}

そして図\ref{gcskew_win}に示すように、
ゲノム配列上にウィンドウを置き、ウィンドウ中のGC含有量を計算し、ウィンド
ウを移動させるというステップを繰り返します。次のプログラムではウィンドウの大き
さを1000塩基、移動幅を500塩基に設定しています。\\
\begin{waku}
\begin{verbatim}
win_size = 1000
step = 500
pos = 0
while pos + win_size <= len(seq):
    seq_frag = seq[pos:pos + win_size]
    gc_content = calc_gc(seq_frag)
    print pos, gc_content
    pos += step
\end{verbatim}
\end{waku}

\begin{figure}
\begin{center}
\includegraphics[scale=0.5]{Figs/gccont1.eps}
\end{center}
\caption{大腸菌とマイコプラズマ菌のゲノム中のGC含有量}
\label{gccont1}
\end{figure}

\item{問題\stepcounter{question}\thequestion }  
GC skewはゲノム配列の片方の鎖のCの偏りを表す指標で以下の式で定義されます。
\begin{displaymath}
\mbox{GC skew}=\frac{\mbox{対象とする核酸配列に含まれるCの数}-\mbox{対象とする核酸配列に含まれるGの数}}{\mbox{対象とする核酸配列に含まれるCとGの数}}
\end{displaymath}
ゲノム中のGC skewの推移を表すプログラムを作成し、実行結果を図にしてみましょう。
大腸菌など生物によっては複製開始点を基点としてGC skewに興味深い大きな変動が見られるでしょう。
\end{description}


\end{document}
