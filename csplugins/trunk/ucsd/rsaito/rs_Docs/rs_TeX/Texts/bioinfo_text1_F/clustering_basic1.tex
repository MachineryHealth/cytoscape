\chapter{遺伝子発現データのクラスタリング}

\begin{abstract}
クラスタリングは類似したデータを集めることです。近年酵母菌を初めとした様々
な生物種で多量の遺伝子発現データが公開されていますが、それらの中から遺伝
子の発現制御関係を抽出するなど何らかのデータマイニングをする上で、クラス
タリングは最も基本的な手法と言えます。そこで本章では、遺伝子発現データの
クラスタリングの基本について学習します。
\end{abstract}

\section{遺伝子発現データ}

１つの生物が持つ遺伝子の数は大腸菌で約4,000、酵母菌で約6,000、ヒトでは数
万と言われています。その中には常に発現しているような遺伝子もあれば、時期特
異的に発現する遺伝子もあり、また多細胞生物では、組織特異的に発現するものもあ
ります。多くの遺伝子は、細胞にとって必要なときに発現すると考えられます。

例えば細胞分裂を起こすときには、細胞分裂に関係した遺伝子が発現し、大
腸菌に熱を与えたとき、ヒートショック関連の遺伝子が発現して、細胞を守ります。

逆に考えると例えば、細胞に紫外線を当てたときに発現する遺伝子群の多くは細
胞を紫外線から守る機能を持っているのではないかと考えられます。そこである生
物が持つ全ての遺伝子の発現量をモニタリングすることができれば、紫外線を当
てたときに発現量が上がる遺伝子群を全て抽出することにより、紫外線から細胞
を守る働きがあると思われる遺伝子の候補を抽出できることになります。

マイクロアレイ(図\ref{microarray_princ1})という装置が開発されて以来、多
くの遺伝子の発現量を同時に計測できるようになり、酵母菌を初め、多数の生
物についてゲノム全体の遺伝子の発現量の測定が行われ、遺伝子発現データが
公開されています\cite{label_Derisi,label_scer_marray}。

\begin{figure}
\begin{center}
\includegraphics[scale=0.5]{Figures_EPS/microarray_princ1.eps}
\end{center}
\caption{遺伝子の発現量の比を測るマイクロアレイ}
\label{microarray_princ1}
\begin{quotation}
遺伝子Aが条件αと比べて条件βでどれくらい発現しているかをマイクロアレイ
を使って調べる方法を示す。チップ上に遺伝子Aのプローブとなる配列（相
補的な配列）を貼り付けておく。条件αで得られた転写産物をcDNAに逆転写し、
緑色に蛍光標識を付ける。また条件βで得られた転写産物もcDNAに逆転写し、こ
ちらは赤色に蛍光標識を付ける。これらの標識したcDNAをチップ上でハイブリさ
せると、条件αにおける遺伝子Aの発現量の方が多ければチップは緑色の蛍光を
発し、条件βにおける遺伝子Aの発現量の方が多ければ赤色の傾向を発する。こ
うして条件αとβにおける遺伝子Aの発現量の比を知ることができる。
\end{quotation}
\end{figure}

\section{発現相関の定量化}

多数の遺伝子について多量の遺伝子発現データが与えられたとき、遺伝子の発現
制御の構造を推定することが可能になります。例えば、図\ref{transcr_F_reg1}
のように、ある転写因子(TF)が2つの遺伝子の発現を制御しているとき、その転写因
子が発現すれば、2つの遺伝子の発現も同時に上がり、転写因子が発現しなくな
れば、2つの遺伝子の発現も同時に下がることになります\footnote{
リプレッサーの場合は逆に、発現するとそのターゲットとなる遺伝子の発現量は下がる。}。

\begin{figure}
\includegraphics[scale=0.4]{Figures_EPS/transcr_F_reg1.eps}
\caption{転写因子と発現パターンの関係}
\label{transcr_F_reg1}
\end{figure}

このように転写制御において、緊密な関係のある遺伝子群の発現パターンは類似
する傾向にあります。逆に類似した発現パターンを示す遺伝子群は転写制御において
密接な関係にあることが推測されます。そこで多量な遺伝子の発現データから類似
した発現パターンを示すものを抽出することができれば、近い制御関係にある遺
伝子をまとめることが可能です。

では、遺伝子の発現パターンの類似性を測定するためにはどのような尺度が考え
られるでしょうか？まず考えられるのは、ユークリッド距離です。今、遺伝子1
の発現データ\(x_{11},x_{12},x_{13},\cdots,x_{1n}\)と、遺伝子2の発現デー
タ\(x_{21},x_{22},x_{23},\cdots,x_{2n}\)が与えられたとすると、ユークリッ
ド距離\(d\)は

\begin{displaymath}
d=\sqrt{\sum_{k=1}^{n}(x_{1k}-x_{2k})^{2}}
\end{displaymath}

\noindent
と定義されます。これは図\ref{euclid_dist}に示すように、2つの遺伝子の発
現量の多次元上の「距離」を表し、小さければ小さいほど発現量が似ているこ
とを表します。ユークリッド距離は発現レベルの絶対値が意味を持つような場
合に有効です。

\begin{figure}
\begin{center}
\includegraphics[scale=0.4]{Figures_EPS/euclid_dist.eps}
\vspace{2em}
\end{center}
\caption{ユークリッド距離}
\label{euclid_dist}
\begin{quotation}
2つの遺伝子\(x_{1}\)および\(x_{2}\)の発現パターンの例を示した。縦軸が各
遺伝子の発現レベルを表し、横軸はその発現レベルが観測された条件(時間や組織、
栄養状態など) を表す。同じ条件における遺伝子の発現レベルの距離を矢印付きの
線で表した。ユークリッド距離は、この距離の二乗の総和の平方根である。
\end{quotation}
\end{figure}

しかしユークリッド距離を使うと、波形の形が似ていても発現レベルが大きく異なる
場合、距離が大きくなってしまいます。そこでもう１つよく使われるのがピアソンの相関
係数で、これを使うと、遺伝子発現パターンの波形の類似性を定量することが
可能です。2つの遺伝子の発現の相関は以下のように求めることができます。

遺伝子1の発現データ\(x_{11},x_{12},x_{13},\cdots,x_{1n}\)と、
遺伝子2の発現データ\(x_{21},x_{22},x_{23},\cdots,x_{2n}\)が与えられたとします。
まず、平均\(\mu\)と分散\(\sigma^{2}\)を以下の式により求めます
\footnote{
遺伝子発現データのクラスタリングの先駆的な研究を行ったEisenら
\cite{label_Eisen}はこの式で平均を0として発現相関を計算している。なお、
遺伝子の発現データを標本として捉える場合、標本平均は
\(\overline{x_{i}}=\frac{1}{n}\sum_{k=1}^{n}x_{ik}\)、標本分散は
\(s^{2}=\frac{1}{n-1}\sqrt{\sum_{k=1}^{n}(x_{ik}-\overline{x_{i}})}\)で
求める。また標本相関係数は、
\(\frac{1}{n-1}\sum_{k=1}^{n}\frac{x_{1k}-\overline{x_{1}}}{s_{1}}\frac 
{x_{2k}-\overline{x_{2}}}{s_{2}}\)となる。
}

\[\mu_{i} = \frac{1}{n}\sum_{k=1}^{n}x_{ik}
\qquad
\sigma_{i}^{2} = \frac{\sum_{k=1}^{n}(x_{ik}-\mu_{i})^2}{n}
\]

ただし\(i\)は遺伝子番号(この例では1または2)を表します。
次に\(x_{1}\)と\(x_{2}\)のデータの標準化を行います。

\[z_{ij}=\frac{x_{ij}-\mu_{i}}{\sigma_{i}}\]

こうすると、元の遺伝子発現データがどのような分布をしていても、それを変換
した\(z_{i}\)は平均が0、分散が1になります。そして相関係数\(r\)を以下の式
で計算します。

\[r=\frac{1}{n}\sum_{k=1}^{n}z_{1k}z_{2k}\]

\(z_{1k}\)と\(z_{2k}\)の発現パターンが類似していれば、\(z_{1k}\)と
\(z_{2k}\)が同時に正または負になる機会が多くなり、その積の和である\(r\)
は正に大きくなることが分かります。逆に\(z_{1k}\)と\(z_{2k}\)の発現パターンが
ちょうど正反対であれば、\(z_{1k}\)と\(z_{2k}\)の符号が逆になる機会が多く
なり、その積の和である\(r\)は負に大きくなります。また\(z_{1k}\)と\(z_{2k}\)
の間に相関がなければ、\(z_{1k}z_{2k}\)は正の値も負の値もとるようになり、
その和は0に近くなります。

\(z_{1}\)も\(z_{2}\)も平均が0、分散が1なので、\(t \in R\)について、

\[\frac{1}{n}\sum_{k=1}^{n}(z_{1i}-tz_{2i})^{2}=(t-r)^{2}-r^{2}+1 \geq 0\]

\noindent
が成立します。任意の\(t \in R\)に対して\((t-r)^{2} \geq 0\)なので、
\(-1 \leq r \leq 1\)となります。

\begin{figure}
\includegraphics[scale=0.6]{Figures_EPS/corr_sample1.eps}
\caption{曲線の類似性と相関係数}
\label{corr_sample1}
\end{figure}

図\ref{corr_sample1}に2つの遺伝子の発現パターンの例と、その相関係数を載せました。
この図より、

\begin{itemize}
\item 発現パターンが似ているとき、相関係数\(r\)は1に近づく
\item 発現パターンに相関がないとき、相関係数\(r\)は0に近づく
\item 発現パターンが逆になるとき、相関係数\(r\)は-1に近づく
\end{itemize}

\noindent
ということが分かると思います。


\section{遺伝子発現データの階層的クラスタリング}

前節で遺伝子間の類似性の定量に相関係数などの指標が使えることを説明しました。
それでは、類似性の高い遺伝子群が同じグループに含まれるようにグルーピング
をするにはどうすればいいでしょうか？

このように似た性質のデータをグループごとに集めることをクラスタリングと
呼びます。効果的なクラスタリングを行う１つの方法は階層的クラスタリング
です\cite{label_Eisen,MA_tanoshi}。このクラスタリングでは最も似ている（発現相関が高い)データの対から
順番にクラスタリングを行い、階層構造を構築します。具体的な方法を４つ
の遺伝子発現量の架空データを用いて図\ref{hie_clu1}を使いながら説明します。

\begin{figure}
\includegraphics[scale=0.6]{Figures_EPS/hie_clu2.eps}
\caption{階層的クラスタリングの例}
\label{hie_clu1}
\begin{quotation}
一番上に4つのデータ(Data0 〜 Data3)を示す。左側の表が発現相関、右の図が
階層的クラスタリングの途中経過を表す。
\end{quotation}
\end{figure}

\begin{enumerate}
\item 全通りの遺伝子間の発現相関を求める（その結果を図のStep 1の表に示す）。この例では相関係数を用いる。
\item 最も発現相関の高かった遺伝子の組を１つに統合(Step 1の右)。図の例ではData 2と
Data 3の発現相関が最も高いので、これを１つにまとめる(図の右の木構造参照)。
\item 再び全通りの組の発現相関を求める(Step 2の左の表)。
\item 再び遺伝子またはクラスターの組を統合。この例では、Data0とData1が統合される(Step 2の右)。
\item Data0 + Data1のクラスターと、Data2 + Data3のクラスターの発現相関は-0.44(Step 3の左)。最後に残ったこの２つのクラスターが統合される(Step 3の右)。
\end{enumerate}

統合を繰り返していくと、最終的に全てが１つの枝に統合される
ので(Step 3)、そこでアルゴリズムは終了となります。

遺伝子間の発現相関は前述の相関係数を使って計算することができます。ではク
ラスターと遺伝子、あるいはクラスター間の遺伝子の発現相関はどのように求め
ればよいでしょうか？最も単純な方法は、最短距離法です。これは例えばクラス
ターAとBの発現相関を求める場合、Aに含まれる遺伝子とBに含まれる遺伝子の全
通りの相関係数を計算し、その中で最も高い相関係数がクラスターA,B間の相関
係数になります\footnote{他に全通りの相関係数の中で最も低い相関係数をクラ
スター間の相関係数とする最長距離法や、全通りの相関係数の平均をクラスター
間の相関係数とする平均距離法などがある。詳しくは文献\cite{multi_nonmat}
などを参照。}。
Data0 + Data1のクラスターとData2 + Data3のク
ラスターの発現相関を計算する場合、全通りの相関係数はData0とData2の\(-0.50\)、
Data0とData3の\(-0.44\)、Data1とData2の\(-0.55\)、Data1とData3の\(-0.46\)の４つにな
り、最も高いのは\(-0.44\)なので、これがこの２つのクラスターの発現相関となり
ます。

最短距離法を使った階層的クラスタリングの実装例を以下に示します。この例
ではCLUSTERという構造体の配列clで各クラスターに含まれる遺伝子を管理してい
ます。

\noindent
\underline{\hspace{10cm}}
\begin{verbatim}
#define N_DATA 4 /* データ数 */
#define DIM 21

/* クラスター情報 */
struct CLUSTER {
  int n; /* データ数 */
  int gene[N_DATA]; /* 保持しているデータ番号の集合 */
}; 

/* プロトタイプ宣言 */
double  corr_single(double a[], double b[], int n);
double  corr_clust(struct CLUSTER& a, struct CLUSTER& b,
                   double d[N_DATA][N_DATA]);
void merge(struct CLUSTER& a, struct CLUSTER& b, struct CLUSTER& merged);

/* n次元データa, bの相関係数を計算する */
double corr_single(double a[], double b[], int n){
  int i;
  double d = 0.0;
  double mean_a, mean_b;
  double var_a, var_b;
  double corr;
  
  for(mean_a = 0, i = 0;i < n;i ++)mean_a += a[i] / n;
  for(mean_b = 0, i = 0;i < n;i ++)mean_b += b[i] / n;
  for(var_a = 0, i = 0;i < n;i ++)
    var_a += (a[i] - mean_a)*(a[i] - mean_a) / n;
  for(var_b = 0, i = 0;i < n;i ++)
    var_b += (b[i] - mean_b)*(b[i] - mean_b) / n;
  for(corr = 0, i = 0;i < n;i ++)
    corr += (a[i] - mean_a) / sqrt(var_a)
      * (b[i] - mean_b) / sqrt(var_b) / n;

  return corr;
}

/* クラスターa, bの要素間の相関を計算する */
double corr_clust(struct CLUSTER& a, struct CLUSTER& b,
                  double d[N_DATA][N_DATA]){
  int i, k;
  double max;
  
  max = d[ a.gene[0] ][ b.gene[0] ];
  for (i = 0; i < a.n; i ++){
      for (k = 0; k < b.n; k ++){
          if (max < d[ a.gene[i] ][ b.gene[k] ])
              max = d[ a.gene[i] ][ b.gene[k] ];
        }
    }
  return max;
}

/* クラスターa, bを統合し、結果をクラスターnewに入れる */
void merge(struct CLUSTER& a, struct CLUSTER& b, struct CLUSTER& merged){
  int i, n;
  
  n = 0;
  for (i = 0; i < a.n; i ++)
      merged.gene[ n++ ] = a.gene[i];
  for (i=0; i < b.n; i++)
      merged.gene[ n++ ] = b.gene[i];
  merged.n = n;
}

/* 次元数dimのデータ群dataを階層的クラスタリング
   データ数N_DATAはグローバル変数として与えられる */
void h_cluster(double data[N_DATA][DIM]){
  int i, j, n;
  double d[N_DATA][N_DATA];   /* データ間の相関行列 */
  double corr, corr_max;      /* データ間の相関 */
  int c1, c2;
  
  static struct CLUSTER cl[N_DATA]; /* クラスター情報 */
  static struct CLUSTER w;     /* ワーク用 */
  
  /* クラスター情報の初期化 */
  for (i=0; i < N_DATA; i++){
      cl[i].n = 1;
      cl[i].gene[0] = i;
    }
  
  /* 相関行列の作成 */
  for (i = 0; i < N_DATA; i++)
      for (j = 0; j < N_DATA; j++)
        d[i][j] = corr_single(data[i], data[j], DIM);
  
  /* 階層的クラスタリング */
  n = N_DATA - 1;
  while (n > 0){
    corr_max = -1.0;
    for (i = 0; i < n; i ++){
        for (j = i + 1; j <= n; j ++){
              corr = corr_clust(cl[i], cl[j], d);
            if (corr > corr_max){ 
                corr_max = corr;
                c1 = i, c2 = j;
              }	    
          }
      }

    printf("[ Merge %d ] Merging the following two clusters:\n",
           N_DATA - n - 1);
    printf("(1) Cluster containing data #");
    for(i = 0;i < cl[ c1 ].n;i ++){
      printf("%d", cl[ c1 ].gene[i]);
      if(i < cl[ c1 ].n - 1)putchar(',');
    }
    printf("\n(2) Cluster containing data #");
    for(i = 0;i < cl[ c2 ].n;i ++){
      printf("%d", cl[ c2 ].gene[i]);
      if(i < cl[ c2 ].n - 1)putchar(',');
    }
    printf("\nDistance between these two clusters = %lf\n\n", corr_max);
    
    merge(cl[ c1 ], cl[ c2 ], w); /* クラスターを統合 */
    cl[ c1 ] = w; /* クラスターc2をc1へ統合して格納 */	  
    cl[ c2 ] = cl[n]; /* クラスターc2を破棄し、一番後ろのクラスターを代わりに格納 */
    n--; /* クラスターを１つ減らす */
  }
}
\end{verbatim}
\noindent
\underline{\hspace{10cm}}

図\ref{hie_clu1}のデータを用いたプログラムの実行結果を以下に示します。

\noindent
\underline{\hspace{10cm}}
\begin{verbatim}
[ Merge 0 ] Merging the following two clusters:
(1) Cluster containing data #2
(2) Cluster containing data #3
Distance between these two clusters = 0.947762
\end{verbatim}
\noindent
\underline{\hspace{10cm}}

この時点でデータ2とデータ3の相関係数が0.95と最も高かったので、1つのクラ
スターとして統合されました。

\noindent
\underline{\hspace{10cm}}
\begin{verbatim}
[ Merge 1 ] Merging the following two clusters:
(1) Cluster containing data #0
(2) Cluster containing data #1
Distance between these two clusters = 0.897216
\end{verbatim}
\noindent
\underline{\hspace{10cm}}

次にデータ0とデータ1の相関係数が0.90と最も高かったので、1つのクラスター
として統合されました。

\noindent
\underline{\hspace{10cm}}
\begin{verbatim}
[ Merge 2 ] Merging the following two clusters:
(1) Cluster containing data #0,1
(2) Cluster containing data #2,3
Distance between these two clusters = -0.438644
\end{verbatim}
\noindent
\underline{\hspace{10cm}}

最後にデータ0,1を含むクラスターと、データ2,3を含むクラスターが１つのク
ラスターとして統合されました。このときのクラスター間の相関係数は-0.44で
す。

\begin{figure}
\includegraphics[scale=0.5]{Figures_EPS/eisen_h_clust.eps}
\caption{酵母菌発現データの階層的クラスタリング}
\label{eisen_h_clust}
\begin{quotation}
グラフは酵母菌の６つの遺伝子の発現パターンを表しており、横軸が発現レベ
ルを計測した条件、縦軸が発現レベルを表す。発現データはEisen et
al.\cite{label_Eisen} より取得した。左下の表は6つの遺伝子間の発現相関を
表す。右下は階層的クラスタリングの結果。相関が高かった組の枝を短く表示
し、相関が低かった組の枝は長く表示した。
\end{quotation}
\end{figure}

図\ref{eisen_h_clust}に酵母菌の6つの遺伝子の発現データの階層的クラスタ
リング結果を載せました。TDH2とENO2は解糖に関係する酵素、
RPL9AとRPS31はリボソームのサブユニット、PDS1とAPC4は細胞周期に関係する
遺伝子です。発現相関が高いものほど枝の長さを短くしました。TDH２とENO2が
まず最初にクラスタリングされ、次にRPL9AとRPS31、PDS1とAPC4というように
機能的に関連した遺伝子が最初にクラスタリングされていくのが分かります。
TDH2+ENO2のクラスターとRPL9A+RPS31のクラスターには多少相関が見られ、
PDS1+APC4のクラスターより先に統合されていることが分かります。


\section{遺伝子発現データの非階層的クラスタリング}
\label{section_kmeans}

非階層的クラスタリングもデータ群を似た性質のものが集まるようにするアルゴ
リズムです。しかしその名の通り、階層構造は取りません。非階層的クラスタリ
ングの中でもよく使われるのが、K平均アルゴリズム\cite{machine_L}です。こ
のアルゴリズムでは、最終的にデータを\(k\)個のクラスターに分けます。その
詳細なアルゴリズムを、各要素が２次元データである場合を例に解説します。

各遺伝子に対して２つの条件で発現レベルの測定が行われた場合、データは２
次元になります。分かりやすくするためこの発現データを図
\ref{exp_plot_2d} に示すように２次元平面上にプロットして考えましょう。

\begin{figure}
\includegraphics[scale=0.5]{Figures_EPS/exp_plot_2d.eps}
\caption{２つの条件で測られた発現レベルの２次元平面へのプロット}
\label{exp_plot_2d}
\end{figure}

\begin{figure}
\includegraphics[scale=0.5]{Figures_EPS/kmeans_ex2.eps}
\caption{K平均アルゴリズムの概要}
\label{kmeans_ex2}
\end{figure}

図\ref{kmeans_ex2}では５個の２次元データ(●)がプロットされています。こ
れを\(k\)個のグループにクラスタリングするにはまず、参照点と呼ばれる点
(○)を\(k\)個配置します(a)。この例では\(k=2\)の場合を示しています。そし
て各データが最も近い参照点に属するようにします(b)。この例では距離をユー
クリッド距離によって測っています。図では、各点とその所属する参照点を直
線で結んでいます。そして同じ参照点に属するデータは同じクラスターに属す
るものとみなします。

次に各クラスターに属する点の座標から重心(☆)を求めます(c)。そして次に参
照点を重心の方向へ移動させます(d, e)。この例では、参照点から重心までの直
線距離の2/3を移動距離としています。そしてあとは(b)と同じようにまた、各デ
ータが最も近い参照点に属するようにします(f)。今回は(9,3)の点の所属が左側
の参照点から右側の参照点に変わっているのが分かると思います。これを各参照
点と重心が重なって収束するまで繰り返します。

まとめると、K平均アルゴリズムは以下のように要約されます。

\begin{enumerate}
\item \(k\)個の参照点を配置する。
\item \label{KM_nearest} 各データの所属する参照点を決める。各データの所属を最も近い参照点とする
\item 各クラスターに属するデータの重心を計算する。
\item 参照点を重心の方向へわずかに移動させる
\item \ref{KM_nearest}に戻る
\end{enumerate}

\noindent
以上のステップを、収束するまで繰り返します。

K平均アルゴリズムの実装例を以下に示します。

\underline{\hspace{10cm}}
\begin{verbatim}
/* 
(1) CLUSTERSはクラスターの数kを表す
(2) DIMはデータの次元数
(3) POINTSはデータの数
(4) RATIOは毎回の参照点移動時に、(重心の位置 - 参照点の位置)の何倍(<1)の距離を移動させるかを表す 
ともに#defineで定義すること
*/

void kmeans(){
  static double ref_position[CLUSTERS][DIM];
  /* 各参照点の座標。最初の添え字は何番目の参照点かを表し、二番目の添え字は参照点の次元を表す。 */
  static double points[POINTS][DIM];
  /* 各データの座標。最初の添え字は何番目のデータかを表し、二番目の添え字は各データの次元を表す。 */
  static int points_belong[CLUSTERS][POINTS];
  /* 各データが所属する参照点。例えばi番目のデータがk番目の参照点に属していた場合、points_belong[i][k] = 1となる。そうでない場合は、points_belong[i][k] = 0となる。 */

  int i, j, k, iteration;

  static int next_points_belong[CLUSTERS][POINTS];
  /* 次のステップで各データが所属する参照点 */

  static double target_position[CLUSTERS][DIM];
  /* 重心の位置。最初の添え字が何番目の参照点かを表し、二番目の添え字が各データの次元を表す */

  initialize(ref_position, points);
  /* 初期化。各データをpointsに格納し、参照点をref_positionに入れる */

  for(iteration = 0; iteration < 1000;iteration ++){ /* 1000回のループ(収束したときに止めてもよい) */
    determine_cluster(next_points_belong, ref_position, points);
    /* 各データが次に所属する参照点を決定する */

    for(i = 0;i < CLUSTERS;i ++)
      for(j = 0;j < POINTS;j ++)
         points_belong[i][j] = next_points_belong[i][j];
    /* 各データが所属する参照点を更新 */

    calc_gravity_center(points_belong, target_position, ref_position, points);
    /* 各クラスターの重心を求め、target_positionに格納する。 */

    for(i = 0;i < CLUSTERS;i ++){
      for(k = 0;k < DIM;k ++){
        ref_position[i][k] +=
           (target_position[i][k] - ref_position[i][k]) * RATIO;

      }
    } /* 参照点を重心の方向に向かって移動させる */

  }
}
\end{verbatim}
\underline{\hspace{10cm}}

\begin{figure}
\includegraphics[scale=0.5]{Figures_EPS/eisen_kmeans.eps}
\caption{酵母菌発現データのK平均アルゴリズムによるクラスタリング}
\label{eisen_kmeans}
\begin{quotation}
図中の折れ線は各クラスターの参照点を表している。
TDH2,ENO2,RPL9A,RPS31がクラスター\#0に、PDS1とAPC4がクラスター\#1に入っている。
\end{quotation}
\end{figure}

図\ref{eisen_kmeans}に階層的クラスタリングで使用したデータセットをK平均
アルゴリズムでクラスタリングした結果を示します。この例ではユークリッド
距離を類似性の指標として使いました。図には２つのクラスターの参照点を折
れ線として示しています。\(k=2\)でクラスタリングを行っており、
TDH2,ENO2,RPL9A,RPS31がクラスター\#0に、PDS1とAPC4がクラスター\#1に入り
ました。図\ref{eisen_h_clust}と比較しましょう。階層的クラスタリングでは
TDH2+ENO2+RPL9A+RPS31というクラスターが4回目のクラスターの統合でできま
したが、それがK平均アルゴリズムでは１つのクラスターにまとまっています。
図\ref{eisen_h_clust}発現パターンのグラフで中央より少し右のところで発現
レベルが大きく上がっていたPDS1とAPC4がK平均アルゴリズムで同じクラスター
になり、図\ref{eisen_kmeans}の参照点を表す線がPDS1およびAPC4の発現パター
ンと良く似た形になっているのが分かります。また同様に
TDH2,ENO2,RPL9A,RPS31は図\ref{eisen_h_clust}で逆に発現レベルが大きく下
がっていましたが、4つとも同じクラスターになり、参照点を表す折れ線がこれ
らの遺伝子の発現パターンと類似しているのが分かります。

このようにK平均アルゴリズムを使うと、データを指定したグループ数(\(k\))
にクラスタリングできるのが分かります。

\begin{practice}
\item 遺伝子1の発現レベル\(x_{11},x_{12},x_{13},\cdots,x_{1n}\)と、
遺伝子2の発現レベル\(x_{21},x_{22},x_{23},\cdots,x_{2n}\)が
\(x_{2i}=ax_{1i}+b\)(\(1 \leq i \leq n\)、\(a,b\)は定数)の関係にあるとき、
この２つの遺伝子の発現レベルの相関係数は1になることを示しましょう。
\item 階層的クラスタリングを行うアルゴリズムを実装し、実際の発現データを階層的クラスタリングにかけてみましょう。
\item \ref{section_kmeans}のプログラムを動かすのに必要な関数
initialize, determine\verb+_+cluster, calc\verb+_+gravity\verb+_+center, mainを
完成させて、K平均アルゴリズムを実装したプログラムを動かしましょ
  う。
\end{practice}


