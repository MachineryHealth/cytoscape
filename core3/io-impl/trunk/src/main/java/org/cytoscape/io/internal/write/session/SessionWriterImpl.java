/*
 Copyright (c) 2006,2010 The Cytoscape Consortium (www.cytoscape.org)

 The Cytoscape Consortium is:
 - Institute for Systems Biology
 - University of California San Diego
 - Memorial Sloan-Kettering Cancer Center
 - Institut Pasteur
 - Agilent Technologies

 This library is free software; you can redistribute it and/or modify it
 under the terms of the GNU Lesser General Public License as published
 by the Free Software Foundation; either version 2.1 of the License, or
 any later version.

 This library is distributed in the hope that it will be useful, but
 WITHOUT ANY WARRANTY, WITHOUT EVEN THE IMPLIED WARRANTY OF
 MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.  The software and
 documentation provided hereunder is on an "as is" basis, and the
 Institute for Systems Biology and the Whitehead Institute
 have no obligations to provide maintenance, support,
 updates, enhancements or modifications.  In no event shall the
 Institute for Systems Biology and the Whitehead Institute
 be liable to any party for direct, indirect, special,
 incidental or consequential damages, including lost profits, arising
 out of the use of this software and its documentation, even if the
 Institute for Systems Biology and the Whitehead Institute
 have been advised of the possibility of such damage.  See
 the GNU Lesser General Public License for more details.

 You should have received a copy of the GNU Lesser General Public License
 along with this library; if not, write to the Free Software Foundation,
 Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
 */

package org.cytoscape.io.internal.write.session;

import java.io.File;
import java.io.FileWriter;
import java.io.PrintWriter;
import java.io.Writer;
import java.util.List;

import org.cytoscape.property.session.*;
import org.cytoscape.property.bookmark.*;

import com.sun.xml.bind.marshaller.NamespacePrefixMapper;

import org.cytoscape.model.CyEdge;
import org.cytoscape.model.CyNetwork;
import org.cytoscape.model.CyNode;
import org.cytoscape.model.CyTableUtil;
import org.cytoscape.view.model.View;
import org.cytoscape.view.model.CyNetworkView;
import org.cytoscape.io.CyFileFilter;
import org.cytoscape.io.write.CyNetworkViewWriterManager;
import org.cytoscape.io.write.PropertyWriterManager;
import org.cytoscape.session.CySession;
import org.cytoscape.work.AbstractTask;
import org.cytoscape.work.TaskMonitor;

import javax.swing.*;
import javax.swing.tree.DefaultMutableTreeNode;
import javax.xml.bind.JAXBContext;
import javax.xml.bind.JAXBException;
import javax.xml.bind.Marshaller;
import javax.xml.stream.XMLStreamException;
import java.awt.*;
import java.io.*;
import java.math.BigInteger;
import java.net.URISyntaxException;
import java.net.URL;
import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.*;
import java.util.List;
import java.util.zip.ZipEntry;
import java.util.zip.ZipOutputStream;

import org.cytoscape.io.write.CyWriter;
import org.cytoscape.work.TaskMonitor;
import org.cytoscape.work.AbstractTask;
import org.cytoscape.session.CySession;

/**
 * Write session states into files.<br>
 * Basic functions of this class are:<br>
 * <ul>
 * <li> 1. Create network files</li>
 * <li> 2. Create session state file</li>
 * <li> 3. Get properties file locations</li>
 * <li> 4. Zip them into one session file "*.cys" </li>
 * </ul>
 *
 * @version 1.0
 * @since 2.3
 * @see cytoscape.data.readers.XGMMLReader
 * @author kono
 *
 */
public class SessionWriterImpl extends AbstractTask implements CyWriter {

	// These values will be replaced.
	private static final char[] INVALID_CHAR = {'[', '\\', '/', ':', '*', '?', 
	                                            '"', '<', '>', '|', ']'};
	
	// cysession.xml document version
	private static final String cysessionVersion = "0.9";

	// Enumerate types (node & edge)
	public static final int NODE = 1;

	public static final int EDGE = 2;
	private static final String DEFAULT_VS_NAME = "default";

	// Number of Cytopanels. Currently, we have 3 panels.
	private static final int CYTOPANEL_COUNT = 3;

	// Number of setting files in the cys file.
	// For now, we have cysession.xml, vizmap.prop, cytoscape.prop, and
	// bookmarks.
	private static final int SETTING_FILE_COUNT = 4;

	// Name of CySession file.
	private static final String CYSESSION_FILE_NAME = "cysession.xml";
	private static final String VIZMAP_FILE = "session_vizmap.props";
	private static final String CYPROP_FILE = "session_cytoscape.props";
	private static final String BOOKMARKS_FILE = "session_bookmarks.xml";

	// Extension for the xgmml file
	private static final String XGMML_EXT = ".xgmml";

	// Package name generated by JAXB.
	// This file was created from "cysession.schema"
	private final String packageName = "org.cytoscape.io.internal.generated";

	// Root of the network tree
	private static final String TREE_ROOT = "root";

	// File name for the session
	private Map<String,Long> networkMap;
	private String sessionNote = "You can add note for this session here.";

	// The following are JAXB-generated objects defined in CySession.xml. 
//	private ObjectFactory factory;
	private Cysession cysession;
	private NetworkTree tree;
	private SessionState sState;
	private List<Network> netList;
	private Cytopanels cytoPanels;
	private Plugins plugins;

	private final String sessionDirName;
	private final String sessionDir;
	private ZipOutputStream zos; 
	private TaskMonitor taskMonitor;

	private final OutputStream outputStream;
	private final CySession session;
	private final CyNetworkViewWriterManager networkViewWriterMgr;
	private final PropertyWriterManager propertyWriterMgr;
	private final CyFileFilter xgmmlFilter;
	private final CyFileFilter bookmarksFilter;

	public SessionWriterImpl(final OutputStream outputStream, final CySession session, final CyNetworkViewWriterManager networkViewWriterMgr, PropertyWriterManager propertyWriterMgr, CyFileFilter xgmmlFilter, CyFileFilter bookmarksFilter) {
		this.outputStream = outputStream;
		this.session = session;
		this.networkViewWriterMgr = networkViewWriterMgr;
		this.propertyWriterMgr = propertyWriterMgr;
		this.xgmmlFilter = xgmmlFilter;
		this.bookmarksFilter = bookmarksFilter;

		// For now, session ID is time and date
		final DateFormat df = new SimpleDateFormat("yyyy_MM_dd-HH_mm");
		sessionDirName = "CytoscapeSession-" + df.format(new Date()); 
		sessionDir = sessionDirName + "/"; 

		networkMap = new HashMap<String,Long>();
	}


	/**
	 * Write current session to a local .cys file.
	 *
	 * @throws Exception
	 */
	@Override
	public void run(TaskMonitor taskMonitor) throws Exception {
		this.taskMonitor = taskMonitor;
		
		zos = new ZipOutputStream(outputStream); 

		for (CyNetworkView netView : session.getNetworkViews())
			zipNetwork(netView);
		zipCySession();
		zipVizmapProps();
		zipCytoscapeProps();
		zipBookmarks();
		zipFileListMap();

		zos.close();
	}


	/**
	 * Utility to replace invalid chars in the XGMML file name.<br>
	 *
	 * @param fileName
	 *            Original file name directly taken from the title.
	 * @return Modified file name without invalid chars.
	 *
	 */
	private String getValidFileName(String fileName) {
		
		String newFileName = fileName;
		Integer i = 0;
		for(Character ch : INVALID_CHAR) 
			newFileName = newFileName.replace(ch.toString(), (i++).toString());
		
		return newFileName;
	}

	/**
	 * Initialize objects for the marshaller.
	 *
	 * @throws JAXBException
	 */
	private void initObjectsForDataBinding() throws JAXBException {
	/*
		factory = new ObjectFactory();

		cysession = factory.createCysession();
		cysession.setSessionNote(sessionNote);

		tree = factory.createNetworkTree();
		sState = factory.createSessionState();
		setDesktopStates();
		cysession.setSessionState(sState);
		cytoPanels = getCytoPanelStates();
		netList = tree.getNetwork();
		sState.setPlugins(plugins);
		sState.setCytopanels(cytoPanels);
		//sState.setServer(getServerState());
		*/
	}

	private void setDesktopStates() throws JAXBException {

	/*	
		DesktopSize dSize = factory.createDesktopSize();
		NetworkFrames frames = factory.createNetworkFrames();
		Component[] networkFrames = Cytoscape.getDesktop().getNetworkViewManager().getDesktopPane()
		                                     .getComponents();

		for (int i = 0; i < networkFrames.length; i++) {
			if(networkFrames[i] instanceof JInternalFrame) {
				JInternalFrame networkFrame = (JInternalFrame) networkFrames[i];
				NetworkFrame frame = factory.createNetworkFrame();
				frame.setFrameID(networkFrame.getTitle());
				frame.setWidth(BigInteger.valueOf(networkFrame.getWidth()));
				frame.setHeight(BigInteger.valueOf(networkFrame.getHeight()));
				frame.setX(BigInteger.valueOf(networkFrame.getX()));
				frame.setY(BigInteger.valueOf(networkFrame.getY()));
				frames.getNetworkFrame().add(frame);
			}
		}

		dSize.setHeight(BigInteger.valueOf(Cytoscape.getDesktop().getSize().height));
		dSize.setWidth(BigInteger.valueOf(Cytoscape.getDesktop().getSize().width));

		Desktop desktop = factory.createDesktop();
		desktop.setDesktopSize(dSize);
		desktop.setNetworkFrames(frames);
		sState.setDesktop(desktop);
		*/
	}

	/**
	 * Writes the vizmap.props file to the session zip.
	 */
	private void zipVizmapProps() throws IOException {

		zos.putNextEntry(new ZipEntry(sessionDir + VIZMAP_FILE) );

		session.getVizmapProperties().store(zos, "VizMap Properties File");

		zos.closeEntry();
	}

	/**
	 * Writes the cytoscape.props file to the session zip.
	 */
	private void zipCytoscapeProps() throws IOException {
	
		zos.putNextEntry(new ZipEntry(sessionDir + CYPROP_FILE) );

		session.getCytoscapeProperties().store(zos, "Cytoscape Property File");

		zos.closeEntry();
	}

	/**
	 * Writes the bookmarks.xml file to the session zip.
	 */
	private void zipBookmarks() throws Exception {

		zos.putNextEntry(new ZipEntry(sessionDir + BOOKMARKS_FILE) );

		CyWriter bookmarksWriter = propertyWriterMgr.getWriter(session.getBookmarks(), bookmarksFilter, zos );
		bookmarksWriter.run(taskMonitor);

		zos.closeEntry();

		bookmarksWriter = null;
	}

	/**
	 * Writes a network file to the session zip. 
	 *
	 * @throws URISyntaxException
	 * @throws JAXBException
	 * @throws XMLStreamException
	 */
	private void zipNetwork(final CyNetworkView view) throws Exception {
		final CyNetwork network = view.getModel();

		String xgmmlFile = getValidFileName( network.attrs().get("name",String.class) + XGMML_EXT );
		zos.putNextEntry(new ZipEntry(sessionDir + xgmmlFile) );

		// Write the XGMML file *without* our graphics attributes
		// We'll let the Vizmapper handle those
		CyWriter xgmmlWriter = networkViewWriterMgr.getWriter(view, xgmmlFilter, zos );
		xgmmlWriter.run(taskMonitor);

		zos.closeEntry();

		xgmmlWriter = null;
	}

	/**
	 * Create cysession.xml file.
	 *
	 * @throws Exception
	 */
	private void zipCySession() throws Exception {
		final JAXBContext jc = JAXBContext.newInstance(packageName, this.getClass().getClassLoader());

		initObjectsForDataBinding();
		cysession.setId(sessionDirName);

		// Document version. Maybe used in the future.
		cysession.setDocumentVersion(cysessionVersion);

		getNetworkTree();
		cysession.setNetworkTree(tree);

		Marshaller m = jc.createMarshaller();
		m.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT, Boolean.TRUE);
		// TODO wtf?
		//m.setProperty("com.sun.xml.bind.namespacePrefixMapper",
		 //             new NamespacePrefixMapperForCysession());

		zos.putNextEntry(new ZipEntry(sessionDir + CYSESSION_FILE_NAME) );

		m.marshal(cysession, zos);

		zos.closeEntry();
		m = null;
		cysession = null;
	}

	/**
	 * Writes any files from plugins to the session file.
	 *
	 * @throws IOException
	 */
	private void zipFileListMap() throws IOException {

		// fire an event to tell plugins we're ready to save!
		Map<String, List<File>> pluginFileMap = session.getPluginFileListMap(); 

		// now write any files to the zip files
		if ((pluginFileMap != null) && (pluginFileMap.size() > 0)) {
			byte[] buf = new byte[5000];
			Set<String> pluginSet = pluginFileMap.keySet();
		
			for (String pluginName : pluginSet) {
				List<File> theFileList = (List<File>) pluginFileMap.get(pluginName);
		
				if ((theFileList == null) || (theFileList.size() == 0))
					continue;
	
				for (File theFile : theFileList) {
					if ((theFile == null) || (!theFile.exists()))
						continue;
	
					zos.putNextEntry(new ZipEntry( sessionDir + "plugins/" + pluginName + 
					                               "/" + theFile.getName() ) );

					// copy the file contents to the zip output stream
					FileInputStream fileIS = new FileInputStream(theFile);
					int numRead = 0;
			        while ((numRead = fileIS.read(buf)) > -1)
		            	zos.write(buf, 0, numRead);
					fileIS.close();

					zos.closeEntry();
				}
			}
		}
	}

	/**
	 * Get information about the current session status.
	 *
	 * This includes the following: 1. List of networks opened/created by the
	 * user. 2. Status of the network. 3. relationship between
	 * network-attributes Build GML file into xml
	 *
	 * Extract current NetworkPanel state for saving.
	 */
	private void getNetworkTree() throws Exception {
	/*
		// Tree table storeed in the Network Panel
		JTreeTable treeTable;

		// Get network panel
		CytoscapeDesktop cyDesktop = Cytoscape.getDesktop();
		NetworkPanel netPanel = cyDesktop.getNetworkPanel();

		// Get list of networks
		treeTable = netPanel.getTreeTable();

		Iterator itr = networks.iterator();

		// Visit each node in the tree
		while (itr.hasNext()) {
			CyNetwork network = (CyNetwork) itr.next();
			Long networkID = network.getSUID();
			String networkName = network.attrs().get("title",String.class);

			networkMap.put(networkName, networkID);
		}

		if (treeTable != null) {
			// Extract root node in the tree
			DefaultMutableTreeNode root = (DefaultMutableTreeNode) netPanel.getNetworkNode(TREE_ROOT);

			walkTree(root);
		}
		*/
	}

	/**
	 * Visit all tree node and save the status in the model.
	 *
	 * @param node
	 * @throws JAXBException
	 */
	private void walkTree(DefaultMutableTreeNode node) throws JAXBException {
	/*
		// Check number of children for this node.
		int childCount = node.getChildCount();

		// Create Network object for this node.
		String fileName = node.getUserObject().toString() + XGMML_EXT;
		Network curNode = factory.createNetwork();
		curNode.setFilename(getValidFileName(fileName));
		curNode.setId(node.getUserObject().toString());

		CyNetwork curNet = Cytoscape.getNetwork( networkMap.get(node.getUserObject().toString()));
		GraphView curView = viewMap.get(curNet.getSUID());

		if (!node.getUserObject().toString().equals("Network Root")) {
			String visualStyleName = null;

			if (curView != null) {
				VisualStyle curVS = Cytoscape.getVisualMappingManager().getVisualStyleForView( curView );

				if (curVS != null) {
					visualStyleName = curVS.getName();
				}
			}

			if (visualStyleName == null) {
				visualStyleName = DEFAULT_VS_NAME;
			}

			curNode.setVisualStyle(visualStyleName);
		} else {
			curNode.setVisualStyle(DEFAULT_VS_NAME);
		}

		if (Cytoscape.getNetworkView(networkMap.get(node.getUserObject().toString())) == Cytoscape
		                                                                                          .getNullNetworkView()) {
			curNode.setViewAvailable(false);
		} else {
			curNode.setViewAvailable(true);
		}

		Parent parent = null;
		parent = factory.createParent();

		if (node.getParent() == null) {
			parent.setId("NULL");
			curNode.setParent(parent);
		} else {
			// Set current network as the parent of child networks.
			DefaultMutableTreeNode curParent = (DefaultMutableTreeNode) node.getParent();
			parent.setId(curParent.getUserObject().toString());
			curNode.setParent(parent);
		}

		List<Child> children = curNode.getChild();

		for (int i = 0; i < childCount; i++) {
			// Exctract a network from the Network Panel.
			DefaultMutableTreeNode child = (DefaultMutableTreeNode) node.getChildAt(i);

			// Create Child object
			Child childNetwork = factory.createChild();
			childNetwork.setId(child.getUserObject().toString());
			children.add(childNetwork);

			if (child.isLeaf()) {
				// Reached to the leaf of network tree.
				// Need to create leaf node here.
				Network leaf = factory.createNetwork();
				String childFileName = child.getUserObject().toString() + XGMML_EXT;
				leaf.setFilename(getValidFileName(childFileName));
				leaf.setId(child.getUserObject().toString());

				GraphView leafView = Cytoscape.getNetworkView(networkMap.get(child.getUserObject().toString()));

				String leafVisualStyleName = null;

				if (leafView != Cytoscape.getNullNetworkView()) {
					VisualStyle leafVS = Cytoscape.getVisualMappingManager().getVisualStyleForView( leafView );

					if (leafVS != null) {
						leafVisualStyleName = leafVS.getName();
					}
				}

				if (leafVisualStyleName == null) {
					leafVisualStyleName = DEFAULT_VS_NAME;
				}

				leaf.setVisualStyle(leafVisualStyleName);

				Long targetID = networkMap.get(child.getUserObject().toString());

				Parent tempParent = factory.createParent();
				tempParent.setId(curNode.getId());
				leaf.setParent(tempParent);

				CyNetwork targetNetwork = Cytoscape.getNetwork(targetID);
				GraphView curNetworkView = Cytoscape.getNetworkView(targetID);

				if (curNetworkView == Cytoscape.getNullNetworkView()) {
					leaf.setViewAvailable(false);
				} else {
					leaf.setViewAvailable(true);
				}

				//
				// This is for Metanode. Will be used in the future...
				//
				// factory.createViewableNodes(); while (it.hasNext()) { String
				// viewableID = ((CyNode) it.next()) .getSUID(); Node
				// viewableNode = factory.createNode();
				// viewableNode.setId(viewableID);
				// vn.getNode().add(viewableNode); } leaf.setViewableNodes(vn);
				 //

				//
				// Add selected & hidden nodes/edges foe leaf nodes.
				 //
				SelectedNodes sn = (SelectedNodes) getSelectedObjects(NODE, targetNetwork);

				if (sn != null) {
					leaf.setSelectedNodes(sn);
				}

				SelectedEdges se = (SelectedEdges) getSelectedObjects(EDGE, targetNetwork);

				if (se != null) {
					leaf.setSelectedEdges(se);
				}

				HiddenNodes hn = (HiddenNodes) getHiddenObjects(NODE, curNetworkView);
				HiddenEdges he = (HiddenEdges) getHiddenObjects(EDGE, curNetworkView);

				if (hn != null) {
					leaf.setHiddenNodes(hn);
				}

				if (he != null) {
					leaf.setHiddenEdges(he);
				}

				netList.add(leaf);
			} else {
				walkTree(child);
			}
		}

		//
		// Add hidden/selected nodes and edges
		//
		Long targetID = networkMap.get(node.getUserObject().toString());
		CyNetwork targetNetwork = Cytoscape.getNetwork(targetID);

		//
		// This is for metanode. will be used in the future.
		//
		// if (curNode.getId() != "Network Root") { Iterator it =
		// factory.createViewableNodes(); while (it.hasNext()) {
		//
		// String viewableID = ((CyNode) it.next()).getSUID(); Node
		// viewableNode = factory.createNode(); viewableNode.setId(viewableID);
		// vn.getNode().add(viewableNode); } curNode.setViewableNodes(vn); }
		 //
		SelectedNodes sn = (SelectedNodes) getSelectedObjects(NODE, targetNetwork);

		if (sn != null) {
			curNode.setSelectedNodes(sn);
		}

		SelectedEdges se = (SelectedEdges) getSelectedObjects(EDGE, targetNetwork);

		if (se != null) {
			curNode.setSelectedEdges(se);
		}

		// Extract hidden nodes and edges
		GraphView curNetworkView = Cytoscape.getNetworkView(targetID);

		if (curNetworkView != Cytoscape.getNullNetworkView()) {
			HiddenNodes hn = (HiddenNodes) getHiddenObjects(NODE, curNetworkView);
			HiddenEdges he = (HiddenEdges) getHiddenObjects(EDGE, curNetworkView);

			if (hn != null) {
				curNode.setHiddenNodes(hn);
			}

			if (he != null) {
				curNode.setHiddenEdges(he);
			}
		}

		// Add current network to the list.
		netList.add(curNode);
		*/
	}

	/**
	 *
	 * @param type
	 *            Type of the object (node or edge)
	 * @param view
	 *            Current network view.
	 * @return JAXB object (HiddenNodes or HiddenEdges)
	 * @throws JAXBException
	 */
	private Object getHiddenObjects(int type/*, GraphView view*/) throws JAXBException {
	/*
		// List-up all hidden nodes
		if (type == NODE) {
			HiddenNodes hn = factory.createHiddenNodes();
			List<Node> hNodeList = hn.getNode();

			CyNode targetNode = null;
			String curNodeName = null;

			for (Iterator i = view.getNodeViewsIterator(); i.hasNext();) {
				NodeView nview = (NodeView) i.next();

				// Check if the node is hidden or not.
				// If it's hidden, store in the session file.
				if (view.showGraphObject(nview)) {
					targetNode = (CyNode) nview.getNode();
					curNodeName = Integer.toString(targetNode.getIndex());

					Node tempNode = factory.createNode();
					tempNode.setId(curNodeName);

					hNodeList.add(tempNode);

					// Keep them hidden...
					view.hideGraphObject(nview);
				}
			}

			if (hn.getNode().size() != 0) {
				return hn;
			} else {
				return null;
			}
		} else if (type == EDGE) {
			HiddenEdges he = factory.createHiddenEdges();
			List<Edge> hEdgeList = he.getEdge();

			CyEdge targetEdge = null;
			String curEdgeName = null;

			for (Iterator i = view.getEdgeViewsIterator(); i.hasNext();) {
				EdgeView eview = (EdgeView) i.next();

				// Check if the edge is hidden or not.
				// If it's hidden, store in the session file.
				if (view.showGraphObject(eview)) {
					targetEdge = (CyEdge) eview.getEdge();
					curEdgeName = Integer.toString(targetEdge.getIndex());

					Edge tempEdge = factory.createEdge();
					tempEdge.setId(curEdgeName);
					tempEdge.setSource(Integer.toString(targetEdge.getSource().getIndex()));
					tempEdge.setTarget(Integer.toString(targetEdge.getTarget().getIndex()));
					tempEdge.setInteraction(targetEdge.attrs().get(Semantics.INTERACTION, String.class));
					hEdgeList.add(tempEdge);
					// Keep them hidden...
					view.hideGraphObject(eview);
				}
			}

			if (he.getEdge().size() != 0) {
				return he;
			} else {
				return null;
			}
		}

		*/
		return null;
	}

	/**
	 * List all selected nodes and edges in the session file.
	 *
	 * @param type
	 *            Tyoe if object (node or edge)
	 * @param curNet
	 *            Current network
	 * @return
	 * @throws JAXBException
	 */
	private Object getSelectedObjects(int type, CyNetwork curNet) throws JAXBException {
	/*
		if (type == NODE) {

			List<CyNode> selectedNodes = CyDataTableUtil.getNodesInState(curNet,"selected",true);

			if ( selectedNodes.size() <= 0 )
				return null; 

			SelectedNodes sn = factory.createSelectedNodes();
			List<Node> sNodeList = sn.getNode();

			for ( CyNode targetNode : selectedNodes ) {
				String curNodeName = Integer.toString(targetNode.getIndex());
				Node tempNode = factory.createNode();
				tempNode.setId(curNodeName);

				sNodeList.add(tempNode);
			}
			return sn;

		} else if (type == EDGE) {

			List<CyEdge> selectedEdges = CyDataTableUtil.getEdgesInState(curNet,"selected",true);

			if (selectedEdges.size() <= 0) 
				return null;

			SelectedEdges se = factory.createSelectedEdges();
			List<Edge> sEdgeList = se.getEdge();

			for ( CyEdge targetEdge : selectedEdges ) {
				String curEdgeName = Integer.toString(targetEdge.getIndex());
				Edge tempEdge = factory.createEdge();
				tempEdge.setId(curEdgeName);
				tempEdge.setSource(Integer.toString(targetEdge.getSource().getIndex()));
				tempEdge.setTarget(Integer.toString(targetEdge.getTarget().getIndex()));
				tempEdge.setInteraction(targetEdge.attrs().get(Semantics.INTERACTION,String.class));
				sEdgeList.add(tempEdge);
			}

			return se;
		}

		*/
		return null;
	}

	/**
	 * Extract states of the 3 Cytopanels.
	 *
	 * @return
	 * @throws JAXBException
	 *
	 * Note: We will store the states of plugins near future. The location of
	 * those states will be stored here.
	 */
	private Cytopanels getCytoPanelStates() throws JAXBException {
	/*
		Cytopanels cytoPanels = factory.createCytopanels();
		List<Cytopanel> cytoPanelList = cytoPanels.getCytopanel();

		String[] cytopanelStates = new String[CYTOPANEL_COUNT + 1];
		int[] selectedPanels = new int[CYTOPANEL_COUNT + 1];

		// Extract states of 3 panels.
		cytopanelStates[1] = Cytoscape.getDesktop().getCytoPanel(SwingConstants.WEST).getState()
		                              .toString();
		selectedPanels[1] = Cytoscape.getDesktop().getCytoPanel(SwingConstants.WEST)
		                             .getSelectedIndex();

		cytopanelStates[2] = Cytoscape.getDesktop().getCytoPanel(SwingConstants.SOUTH).getState()
		                              .toString();
		selectedPanels[2] = Cytoscape.getDesktop().getCytoPanel(SwingConstants.SOUTH)
		                             .getSelectedIndex();

		cytopanelStates[3] = Cytoscape.getDesktop().getCytoPanel(SwingConstants.EAST).getState()
		                              .toString();
		selectedPanels[3] = Cytoscape.getDesktop().getCytoPanel(SwingConstants.EAST)
		                             .getSelectedIndex();

		for (int i = 1; i < (CYTOPANEL_COUNT + 1); i++) {
			Panels internalPanels = factory.createPanels();
			List<Panel> iPanelList = internalPanels.getPanel();
			Panel iPanel = factory.createPanel();
			iPanel.setId("test");

			iPanelList.add(iPanel);

			Cytopanel curCp = factory.createCytopanel();
			curCp.setId("CytoPanel" + i);
			curCp.setPanelState(cytopanelStates[i]);
			curCp.setSelectedPanel(Integer.toString(selectedPanels[i]));
			curCp.setPanels(internalPanels);
			cytoPanelList.add(curCp);
		}

		return cytoPanels;
		*/
		return null;
	}

	/**
	 * Set session note.<br>
	 * Session note can be anything, it is just like a memo pad for the session.
	 * NOTE: session note should be set before calling writeSessionToDisk().
	 *
	 * @param note
	 *            Session note string.
	 * @uml.property name="sessionNote"
	 */
	public void setSessionNote(String note) {
		this.sessionNote = note;
	}

	// TODO
	/**
	 * Check loaded ontologies and save those states in cysession.xml.
	 *
	 * @return Server object
	private Server getServerState() {
		Server server = factory.createServer();
		OntologyServer os = factory.createOntologyServer();

		Set<String> ontoNames = Cytoscape.getOntologyServer().getOntologyNames();
		Map<String, URL> sources = Cytoscape.getOntologyServer().getOntologySources();

		for (String name : ontoNames) {
			Ontology onto = factory.createOntology();
			onto.setName(name);
			onto.setHref(sources.get(name).toString());
			os.getOntology().add(onto);
		}

		server.setOntologyServer(os);

		return server;
	}
	 */
}


class NamespacePrefixMapperForCysession extends NamespacePrefixMapper {
	/**
	 * Returns a preferred prefix for the given namespace URI.
	 *
	 * This method is intended to be overrided by a derived class.
	 *
	 * @param namespaceUri
	 *            The namespace URI for which the prefix needs to be found.
	 *            Never be null. "" is used to denote the default namespace.
	 * @param suggestion
	 *            When the content tree has a suggestion for the prefix to the
	 *            given namespaceUri, that suggestion is passed as a parameter.
	 *            Typicall this value comes from the QName.getPrefix to show the
	 *            preference of the content tree. This parameter may be null,
	 *            and this parameter may represent an already occupied prefix.
	 * @param requirePrefix
	 *            If this method is expected to return non-empty prefix. When
	 *            this flag is true, it means that the given namespace URI
	 *            cannot be set as the default namespace.
	 *
	 * @return null if there's no prefered prefix for the namespace URI. In this
	 *         case, the system will generate a prefix for you.
	 *
	 * Otherwise the system will try to use the returned prefix, but generally
	 * there's no guarantee if the prefix will be actually used or not.
	 *
	 * return "" to map this namespace URI to the default namespace. Again,
	 * there's no guarantee that this preference will be honored.
	 *
	 * If this method returns "" when requirePrefix=true, the return value will
	 * be ignored and the system will generate one.
	 */
	public String getPreferredPrefix(final String namespaceUri, final String suggestion,
	                                 boolean requirePrefix) {
		// I want this namespace to be mapped to "xsi"
		if ("http://www.w3.org/2001/XMLSchema-instance".equals(namespaceUri))
			return "xsi";

		// Xlink
		if ("http://www.w3.org/1999/xlink".equals(namespaceUri)) {
			return "xlink";
		}

		// otherwise I don't care. Just use the default suggestion, whatever it
		// may be.
		return suggestion;
	}

	/**
	 *  DOCUMENT ME!
	 *
	 * @return  DOCUMENT ME!
	 */
	public String[] getPreDeclaredNamespaceUris() {
		return new String[] {
		           "http://www.w3.org/2001/XMLSchema-instance", "http://www.w3.org/1999/xlink",
		       };
	}
}
